<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ramo de orquídeas (noche)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@600;700&family=Cormorant+Garamond:wght@500;600&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg1:#070814;
      --bg2:#0b1030;
      --bg3:#151a40;
    }
    *{box-sizing:border-box}
    html,body{height:100%; overscroll-behavior:none;}
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(900px 650px at 50% 10%, var(--bg3), var(--bg2), var(--bg1));
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
          -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
}
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}

    @supports(height: 100dvh){
      canvas{ height:100dvh; }
    }

    #hud{
      position:fixed;
      left:12px; top:12px;
      z-index:2;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.88);
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: 0.2px;
      user-select:none;
      -webkit-user-select:none;
      max-width: min(340px, calc(100vw - 24px));
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    #hud.hidden{ opacity:0; pointer-events:none; }
    #hud .title{ font-weight:600; margin-bottom:6px; }
    #hud .row{ margin:2px 0; opacity:0.92; }
    #hud kbd{
      display:inline-block;
      padding:1px 6px;
      margin:0 2px;
      border-radius:7px;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.10);
      font: 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
  
    #hud{display:none !important;}

    /* FAILSAFE: asegurar que la primera interfaz (carta + texto + botón) SIEMPRE se vea */
    #introScreen{ display:flex !important; opacity:1 !important; visibility:visible !important; }
    #loveWrap, #letter, #paperContent, #introTextBlock, #introMsg, #introTitle, #introBtn{ opacity:1 !important; visibility:visible !important; }

  
    /* ===== Intro "carta de amor" (estilo sobre + rosa) ===== */
    canvas{ will-change: opacity, filter, transform; opacity:0; filter: blur(10px) saturate(0.92); transform: scale(1.02); transition: opacity 1200ms ease, filter 1200ms ease, transform 1200ms ease; }
    canvas.show{ opacity:1; filter:none; transform: none; }

    #introScreen{
      position: fixed;
      will-change: opacity, transform, filter;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      padding:
        calc(22px + env(safe-area-inset-top))
        calc(22px + env(safe-area-inset-right))
        calc(22px + env(safe-area-inset-bottom))
        calc(22px + env(safe-area-inset-left));
      overflow: hidden;
      background:
        radial-gradient(1200px 900px at 50% 20%, rgba(255,223,200,0.25), rgba(0,0,0,0) 62%),
        radial-gradient(900px 700px at 20% 30%, rgba(255,190,170,0.18), rgba(0,0,0,0) 60%),
        radial-gradient(900px 700px at 80% 65%, rgba(120,70,55,0.28), rgba(0,0,0,0) 62%),
        linear-gradient(180deg, #4a2b20 0%, #2d1813 55%, #1a0f10 100%);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    /* textura suave + viñeta */
    #introScreen::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(1200px 900px at 50% 15%, rgba(0,0,0,0), rgba(0,0,0,0.42) 72%),
        repeating-linear-gradient(12deg, rgba(255,255,255,0.035) 0 2px, rgba(0,0,0,0) 2px 7px);
      opacity: 0.55;
      pointer-events:none;
      mix-blend-mode: soft-light;
    }

    /* grano finito */
    #introScreen::after{
      content:"";
      position:absolute;
      inset:0;
      background-image: url("data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20width%3D%27120%27%20height%3D%27120%27%20viewBox%3D%270%200%20120%20120%27%3E%3Cfilter%20id%3D%27n%27%3E%3CfeTurbulence%20type%3D%27fractalNoise%27%20baseFrequency%3D%270.9%27%20numOctaves%3D%272%27%20stitchTiles%3D%27stitch%27/%3E%3C/filter%3E%3Crect%20width%3D%27120%27%20height%3D%27120%27%20filter%3D%27url%28%23n%29%27%20opacity%3D%270.22%27/%3E%3C/svg%3E");
      background-size: 140px 140px;
      opacity: 0.18;
      pointer-events:none;
      mix-blend-mode: overlay;
    }

    #loveWrap{
      position: relative;
      width: min(720px, 100%);
      height: min(86vh, 900px);
      max-height: 900px;
      display:flex;
      align-items:center;
      justify-content:center;
      filter: drop-shadow(0 22px 46px rgba(0,0,0,0.35));
    }

    
    @supports(height: 100dvh){
      #loveWrap{ height: min(86dvh, 900px); }
    }
/* sobre */
    #envelope{
      position:absolute;
      bottom: 8%;
      width: 94%;
      height: 44%;
      border-radius: 18px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.40), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, #d8c2ab, #b79b84);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.55),
        inset 0 -18px 30px rgba(0,0,0,0.18),
        0 30px 70px rgba(0,0,0,0.30);
      transform: rotate(-4deg);
      overflow: hidden;
    }
    #envelope::before{
      content:"";
      position:absolute;
      left:0; right:0; top:0;
      height: 64%;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.28), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, #dec9b4, #c4a991);
      clip-path: polygon(0 0, 100% 0, 50% 76%);
      opacity: 0.55;
      filter: blur(0.2px);
    }
    #envelope::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius: 18px;
      box-shadow: inset 0 0 0 1px rgba(60,35,28,0.20);
      pointer-events:none;
    }

    /* carta */
    #letter{
      position:absolute;
      will-change: transform, opacity, filter;
      top: 6%;
      width: min(560px, 86%);
      height: min(680px, 78%);
      transform: rotate(2deg);
      z-index: 3;
      animation: floatPaper 5.8s ease-in-out infinite;
    }


    /* Transición “pasar página”: la carta sale del sobre y el sello se desvanece */
    #loveWrap.go #letter{
      animation: none;
      transform-origin: 50% 85%;
      transition: transform 920ms cubic-bezier(.18,.95,.18,1), opacity 920ms ease, filter 920ms ease;
      filter: blur(0px);
      opacity: 1;
    }
    #loveWrap.go #letter{
      transform: rotate(10deg) translateY(-170px) scale(0.90);
      opacity: 0;
      filter: blur(3px);
    }
    #loveWrap.go #envelope{
      transition: transform 920ms cubic-bezier(.18,.95,.18,1), opacity 920ms ease, filter 920ms ease;
      transform-origin: 50% 80%;
      filter: blur(0px);
    }
    #loveWrap.go #envelope{
      transform: rotate(-8deg) translateY(46px) scale(0.985);
      opacity: 0.88;
      filter: blur(1px);
    }
    #loveWrap.go #rose{
      transition: transform 920ms cubic-bezier(.18,.95,.18,1), opacity 920ms ease, filter 920ms ease;
      transform-origin: 50% 50%;
    }
    #loveWrap.go #rose{
      transform: rotate(-18deg) scale(1.18) translateY(18px);
      opacity: 0;
      filter: blur(2px);
    }

    
    /* hoja secundaria detrás de la principal (da sensación de “stack” y profundidad) */
    #letter .paperBack{
      position:absolute;
      inset: 0;
      z-index: 0;
      border-radius: 12px;
      transform: rotate(-3deg) translate(14px, 14px);
      background:
        radial-gradient(240px 180px at 18% 22%, rgba(120,80,60,0.12), rgba(0,0,0,0) 66%),
        radial-gradient(520px 340px at 50% 92%, rgba(70,45,35,0.14), rgba(0,0,0,0) 72%),
        linear-gradient(180deg, #d8c9b4 0%, #cfb79a 58%, #c7a787 100%);
      box-shadow:
        0 18px 54px rgba(0,0,0,0.22),
        inset 0 1px 0 rgba(255,255,255,0.55),
        inset 0 -18px 26px rgba(0,0,0,0.08);
      filter: saturate(0.95) contrast(1.02);
      opacity: 0.95;
      pointer-events:none;
    }
    #letter .paperBack::before{
      content:"";
      position:absolute;
      inset:-18px;
      border-radius: inherit;
      background:
        url("data:image/svg+xml,%3Csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20width=%27140%27%20height=%27140%27%3E%3Cfilter%20id=%27n%27%3E%3CfeTurbulence%20type=%27fractalNoise%27%20baseFrequency=%27.75%27%20numOctaves=%272%27%20stitchTiles=%27stitch%27/%3E%3C/filter%3E%3Crect%20width=%27140%27%20height=%27140%27%20filter=%27url(%23n)%27%20opacity=%27.55%27/%3E%3C/svg%3E") repeat,
        repeating-linear-gradient(20deg, rgba(255,255,255,0.04) 0 2px, rgba(0,0,0,0) 2px 12px);
      background-size: 140px 140px, auto;
      opacity: 0.22;
      mix-blend-mode: soft-light;
      pointer-events:none;
      transform: rotate(1deg);
      filter: blur(0.35px);
    }
    #letter .paperBack::after{
      content:"";
      position:absolute;
      right: 0;
      top: 0;
      width: 86px;
      height: 86px;
      background:
        radial-gradient(70px 70px at 80% 20%, rgba(255,255,255,0.55), rgba(255,255,255,0) 70%),
        linear-gradient(135deg, rgba(0,0,0,0.10), rgba(0,0,0,0));
      clip-path: polygon(0 0, 100% 0, 100% 100%);
      opacity: 0.45;
      pointer-events:none;
      border-top-right-radius: 12px;
    }

    @media (max-width: 420px){
      #letter .paperBack{ transform: rotate(-2.4deg) translate(10px, 12px); }
    }
    @media (max-height: 700px){
      #letter .paperBack{ transform: rotate(-2.2deg) translate(10px, 10px); }
    }

#letter .paper{
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      overflow: hidden;
      --framePad: clamp(32px, 5.8vmin, 58px);
      background:
        radial-gradient(260px 240px at 14% 18%, rgba(150,100,70,0.16), rgba(0,0,0,0) 60%),
        radial-gradient(340px 300px at 82% 12%, rgba(150,100,70,0.14), rgba(0,0,0,0) 60%),
        radial-gradient(520px 380px at 50% 88%, rgba(90,55,40,0.18), rgba(0,0,0,0) 72%),
        linear-gradient(180deg, #e3d7c3 0%, #d9c3a6 56%, #d3b798 100%);
      border: none;
      box-shadow:
        0 26px 70px rgba(0,0,0,0.24),
        inset 0 1px 0 rgba(255,255,255,0.72);
      isolation: isolate;
      animation: paperPulse 5.2s ease-in-out infinite;
    }


/* brillo suave en la hoja (destello ascendente, estilo “brillo por el tallo”) */
#letter .paper .paperShimmer{
  position:absolute;
  inset:-18%;
  border-radius: 14px;
  pointer-events:none;
  z-index: 0;
  opacity: 0.55;
  mix-blend-mode: screen;
  filter: blur(6px);
  background:
    linear-gradient(180deg,
      rgba(255,255,255,0.00) 0%,
      rgba(255,255,255,0.00) 34%,
      rgba(255,255,255,0.26) 50%,
      rgba(255,255,255,0.00) 66%,
      rgba(255,255,255,0.00) 100%);
  transform: translateY(60%);
  animation: paperRise 4.6s ease-in-out infinite;
}

@keyframes paperRise{
  0%   { transform: translateY(62%); }
  55%  { transform: translateY(-10%); }
  100% { transform: translateY(-62%); }
}

@keyframes paperPulse{
  0%,100%{
    box-shadow:
      0 26px 70px rgba(0,0,0,0.24),
      inset 0 1px 0 rgba(255,255,255,0.72),
      0 0 0 rgba(255,220,200,0);
  }
  50%{
    box-shadow:
      0 26px 70px rgba(0,0,0,0.24),
      inset 0 1px 0 rgba(255,255,255,0.72),
      0 0 28px rgba(255,220,200,0.18);
  }
}
/* fibras del papel + líneas suaves */
    #letter .paper::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(0deg, rgba(90,55,40,0.045) 0 1px, rgba(0,0,0,0) 1px 28px),
        radial-gradient(240px 170px at 18% 18%, rgba(110,70,50,0.18), rgba(0,0,0,0) 65%),
        radial-gradient(260px 200px at 80% 12%, rgba(110,70,50,0.14), rgba(0,0,0,0) 68%),
        radial-gradient(420px 260px at 50% 92%, rgba(80,50,38,0.18), rgba(0,0,0,0) 72%);
      opacity: 0.35;
      mix-blend-mode: multiply;
      pointer-events:none;
    }
    
#letter .paper::before{
      content:"";
      position:absolute;
      inset:-42px;
      /* Manchas tipo acuarela (muy tenue) */
      background:
        radial-gradient(360px 280px at 22% 28%, rgba(255,160,70,0.28), rgba(255,160,70,0.12) 46%, rgba(255,160,70,0) 72%),
        radial-gradient(420px 320px at 74% 62%, rgba(255,120,70,0.22), rgba(255,120,70,0.09) 48%, rgba(255,120,70,0) 76%),
        radial-gradient(520px 380px at 52% 18%, rgba(255,205,140,0.18), rgba(255,205,140,0.06) 52%, rgba(255,205,140,0) 82%);
      filter: blur(7px) saturate(1.05);
      opacity: 0.55;
      mix-blend-mode: multiply;
      pointer-events:none;
    }

    @media (max-width: 420px){
      #letter .paper::before{ opacity: 0.46; filter: blur(6px) saturate(1.04); }
    }
    @media (max-width: 360px){
      #letter .paper::before{ opacity: 0.42; filter: blur(5px) saturate(1.03); }
    }

#letter .paper::after{
      content:"";
      position:absolute;
      inset:-20px;
      background:
        url("data:image/svg+xml,%3Csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20width=%27160%27%20height=%27160%27%3E%0A%20%20%3Cfilter%20id=%27n%27%3E%0A%20%20%20%20%3CfeTurbulence%20type=%27fractalNoise%27%20baseFrequency=%27.85%27%20numOctaves=%273%27%20stitchTiles=%27stitch%27/%3E%0A%20%20%20%20%3CfeColorMatrix%20type=%27saturate%27%20values=%270%27/%3E%0A%20%20%3C/filter%3E%0A%20%20%3Crect%20width=%27160%27%20height=%27160%27%20filter=%27url(#n)%27%20opacity=%27.55%27/%3E%0A%3C/svg%3E") repeat,
        repeating-linear-gradient(25deg, rgba(255,255,255,0.05) 0 2px, rgba(0,0,0,0) 2px 10px),
        repeating-linear-gradient(-25deg, rgba(0,0,0,0.03) 0 1px, rgba(0,0,0,0) 1px 12px);
      background-size: 160px 160px, auto, auto;
      opacity: 0.32;
      mix-blend-mode: soft-light;
      pointer-events:none;
      transform: rotate(-2deg);
      filter: blur(0.25px) contrast(1.05) brightness(1.02);
    }

    #paperContent{
      position: relative;
      height: 100%;
      padding: calc(var(--framePad) - 4px) var(--framePad) 22px;
      display:flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      gap: 14px;
      text-align: center;
      z-index: 3;
    }

    #introTitle{
      font-family: "Dancing Script", cursive;
      font-weight: 700;
      font-size: clamp(36px, 7.2vw, 66px);
      line-height: 1.05;
      text-align: center;
      color: rgba(55,30,22,0.96);
      margin: 6px 0 8px;
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
    
      white-space: nowrap;
      display: inline-flex;
      align-items: baseline;
      justify-content: center;
      gap: .12em;
      max-width: 100%;
      transform-origin: center top;
    }

    #introTextBlock{
      width: 100%;
      padding: 0;
      border-radius: 0;
      background: transparent;
    }


    #introTitle .heart{
      display:inline-flex;
      align-items: baseline;
      margin-left: .10em;
      transform: translateY(0.14em);
      color: rgba(220, 20, 60, 0.96);
      text-shadow: 0 1px 0 rgba(255,255,255,0.35), 0 10px 24px rgba(220,20,60,0.22);
    }
    #introTitle .heartSvg{
      width: 0.95em;
      height: 0.95em;
      vertical-align: -0.08em;
      overflow: visible;
    }
    #introTitle .heartSvg path{
      fill: none;
      stroke: currentColor;
      stroke-width: 2.35;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    
    #introMsg{
      font-family: "Dancing Script", cursive;
      font-weight: 600;
      font-size: clamp(22px, 4.4vw, 34px);
      line-height: 1.22;
      text-align: center;
      color: rgba(55,30,22,0.92);
      margin: 0 6px 0;
    }

    /* botón como sello de cera */
    #introBtn{
      appearance:none;
      -webkit-appearance:none;
      border: 0;
      padding: 12px 18px;
      border-radius: 999px;
      font-family: "Cormorant Garamond", serif;
      font-weight: 600;
      font-size: 20px;
      letter-spacing: 0.4px;
      color: rgba(255,244,248,0.98);
      background:
        radial-gradient(18px 18px at 30% 28%, rgba(255,255,255,0.24), rgba(0,0,0,0) 70%),
        radial-gradient(60px 60px at 70% 85%, rgba(0,0,0,0.22), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, #b0184f, #7b0f36);
      box-shadow:
        inset 0 2px 10px rgba(255,255,255,0.14),
        inset 0 -14px 22px rgba(0,0,0,0.22),
        0 18px 34px rgba(0,0,0,0.30);
      align-self: center;
      margin-top: 18px;
      cursor: pointer;
      transform: translateZ(0);
      transition: transform 140ms ease, filter 160ms ease;
    }
    #introBtn:hover{ filter: brightness(1.03) saturate(1.05); }
    #introBtn:active{ transform: translateY(1px) scale(0.99); }
    #introBtn:focus-visible{
      outline: 3px solid rgba(255,220,235,0.55);
      outline-offset: 4px;
    }

    /* rosa */
    #rose{
      position:absolute;
      left: 4%;
      bottom: 6%;
      width: 150px;
      height: 150px;
      z-index: 4;
      pointer-events:none;
      transform: rotate(-18deg);
      opacity: 0.98;
      filter: drop-shadow(0 16px 22px rgba(0,0,0,0.28));
      background-repeat: no-repeat;
      background-size: contain;
      background-position: center;
      background-image: url("data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20200%20200%22%3E%0A%20%20%3Cdefs%3E%0A%20%20%20%20%3CradialGradient%20id=%22petal%22%20cx=%220.35%22%20cy=%220.25%22%20r=%220.9%22%3E%0A%20%20%20%20%20%20%3Cstop%20offset=%220%22%20stop-color=%22#ffd0f0%22/%3E%0A%20%20%20%20%20%20%3Cstop%20offset=%220.55%22%20stop-color=%22#ff3fa8%22/%3E%0A%20%20%20%20%20%20%3Cstop%20offset=%221%22%20stop-color=%22#8a004b%22/%3E%0A%20%20%20%20%3C/radialGradient%3E%0A%20%20%20%20%3ClinearGradient%20id=%22leaf%22%20x1=%220%22%20y1=%220%22%20x2=%221%22%20y2=%221%22%3E%0A%20%20%20%20%20%20%3Cstop%20offset=%220%22%20stop-color=%22#4fbf7a%22/%3E%0A%20%20%20%20%20%20%3Cstop%20offset=%221%22%20stop-color=%22#1b5f3d%22/%3E%0A%20%20%20%20%3C/linearGradient%3E%0A%20%20%20%20%3Cfilter%20id=%22s%22%20x=%22-20%%22%20y=%22-20%%22%20width=%22140%%22%20height=%22140%%22%3E%0A%20%20%20%20%20%20%3CfeGaussianBlur%20in=%22SourceAlpha%22%20stdDeviation=%222%22/%3E%0A%20%20%20%20%20%20%3CfeOffset%20dx=%221%22%20dy=%223%22%20result=%22o%22/%3E%0A%20%20%20%20%20%20%3CfeColorMatrix%20in=%22o%22%20type=%22matrix%22%0A%20%20%20%20%20%20%20%20values=%220%200%200%200%200%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%200%200%200%200%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%200%200%200%200%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%200%200%20.25%200%22/%3E%0A%20%20%20%20%20%20%3CfeMerge%3E%0A%20%20%20%20%20%20%20%20%3CfeMergeNode/%3E%0A%20%20%20%20%20%20%20%20%3CfeMergeNode%20in=%22SourceGraphic%22/%3E%0A%20%20%20%20%20%20%3C/feMerge%3E%0A%20%20%20%20%3C/filter%3E%0A%20%20%3C/defs%3E%0A%20%20%3C!--%20stem%20--%3E%0A%20%20%3Cpath%20d=%22M110%20150c-8%2010-18%2018-30%2024%22%20fill=%22none%22%20stroke=%22#2b7a4c%22%20stroke-width=%226%22%20stroke-linecap=%22round%22%20opacity=%220.9%22/%3E%0A%20%20%3Cpath%20d=%22M102%20150c-5%209-11%2015-18%2019%22%20fill=%22none%22%20stroke=%22#1d5d3a%22%20stroke-width=%223%22%20stroke-linecap=%22round%22%20opacity=%220.9%22/%3E%0A%20%20%3C!--%20leaves%20--%3E%0A%20%20%3Cpath%20d=%22M92%20152c-18-6-32-2-46%2010%2018%204%2034%201%2046-10z%22%20fill=%22url(#leaf)%22%20opacity=%220.95%22%20filter=%22url(#s)%22/%3E%0A%20%20%3Cpath%20d=%22M108%20148c20-2%2034%206%2044%2022-20-2-36-10-44-22z%22%20fill=%22url(#leaf)%22%20opacity=%220.95%22%20filter=%22url(#s)%22/%3E%0A%20%20%3C!--%20rose%20--%3E%0A%20%20%3Cg%20filter=%22url(#s)%22%3E%0A%20%20%20%20%3Cpath%20d=%22M114%2040c20%2010%2032%2026%2030%2046-2%2018-16%2032-34%2040-18%208-36%206-50-6-14-12-18-30-10-48%208-18%2026-30%2064-32z%22%20fill=%22url(#petal)%22/%3E%0A%20%20%20%20%3Cpath%20d=%22M118%2055c10%206%2016%2014%2014%2024-2%2012-12%2020-24%2026-12%206-24%206-34-2-10-8-12-18-6-30%206-12%2018-20%2050-18z%22%20fill=%22rgba(255,220,236,0.18)%22/%3E%0A%20%20%20%20%3Cpath%20d=%22M118%2062c6%204%208%208%207%2014-1%208-8%2014-16%2018-8%204-16%204-22-2-6-5-7-11-4-18%204-8%2012-13%2035-12z%22%20fill=%22rgba(255,255,255,0.16)%22/%3E%0A%20%20%20%20%3Cpath%20d=%22M116%2072c4%203%205%206%204%2010-1%205-6%209-11%2012-6%203-11%203-16-1-4-3-5-7-3-12%203-5%208-9%2026-9z%22%20fill=%22rgba(0,0,0,0.10)%22/%3E%0A%20%20%3C/g%3E%0A%3C/svg%3E");
    }

    #introScreen.hide{
      opacity: 0;
      filter: blur(14px);
      transform: scale(1.02);
      transition: opacity 1100ms ease, filter 1100ms ease, transform 1100ms ease;
      pointer-events: none;
    }

    @keyframes floatPaper{
      0%,100% { transform: rotate(2deg) translateY(0); }
      50%     { transform: rotate(2deg) translateY(-6px); }
    }

    @media (max-width: 420px){
      #loveWrap{ height: min(90vh, 860px); }
      #rose{ width: 118px; height: 118px; left: 2%; bottom: 5%; }
      #letter{ width: 92%; height: 78%; }
      #introBtn{ font-size: 18px; padding: 11px 16px; }
    }

    @media (prefers-reduced-motion: reduce){
      #letter .paper{ animation: none !important; }
      #letter .paper .paperShimmer{ animation: none !important; opacity: 0 !important; }
      #letter{ animation: none; }
      #introScreen, #introScreen.hide, canvas{ transition: none !important; }
    }

  
    
    /* Marco doble en la hoja (dos líneas) */
    .paperFrame{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
      z-index: 2;
      opacity: .70;
      color: rgba(70,40,30,.72);
      mix-blend-mode: multiply;
      filter: blur(.05px);
    }
    .paperFrame .thin{ stroke-width: 2.0; }

/* margen doble en toda la hoja (dos líneas tipo papelería) */


    /* Texto seleccionable dentro de la hoja */
    #paperContent, #introMsg, #introTitle{
      user-select: text;
      -webkit-user-select: text;
    }

    @media (max-width: 420px){
      #introScreen::after{ opacity: 0.12; }
      #letter .paper .paperShimmer{ opacity: 0.35; }
    }


    @media (max-height: 700px){
      #loveWrap{ height: 94vh; }
      #envelope{ height: 40%; bottom: 6%; }
      #letter{ top: 4%; height: 80%; }
    }
    @supports(height: 100dvh){
      @media (max-height: 700px){
        #loveWrap{ height: 94dvh; }
      }
    }

    @media (max-width: 360px){
      #introBtn{ font-size: 17px; padding: 10px 14px; }
      #rose{ width: 104px; height: 104px; }
    }

  

/* === Papel "libreta vieja pero especial" (estático + pigmentos) === */
#letter{ animation: none !important; }

#letter .paper{
  animation: none !important; /* quita paperPulse */
  --pigA: 0.82;
  --pigB: 0.60;
  background:
    radial-gradient(340px 280px at 16% 18%, rgba(140,95,65,0.14), rgba(0,0,0,0) 62%),
    radial-gradient(420px 320px at 82% 16%, rgba(140,95,65,0.12), rgba(0,0,0,0) 64%),
    radial-gradient(680px 520px at 50% 92%, rgba(90,60,45,0.15), rgba(0,0,0,0) 74%),
    linear-gradient(180deg, #f2e9d7 0%, #e7d6bd 58%, #e1cdb1 100%);
}

#letter .paper .paperShimmer{
  display: none !important;
  animation: none !important;
  opacity: 0 !important;
}

#letter .paper::before{
  content:"";
  position:absolute;
  inset:-44px;
  background:
    radial-gradient(520px 360px at 18% 28%, rgba(235,165,90,0.18), rgba(235,165,90,0.08) 42%, rgba(235,165,90,0) 72%),
    radial-gradient(560px 420px at 78% 64%, rgba(220,140,90,0.16), rgba(220,140,90,0.07) 44%, rgba(220,140,90,0) 76%),
    radial-gradient(620px 440px at 52% 16%, rgba(255,215,150,0.14), rgba(255,215,150,0.05) 50%, rgba(255,215,150,0) 84%),
    radial-gradient(220px 220px at 28% 72%, rgba(145,95,60,0) 52%, rgba(145,95,60,0.14) 56%, rgba(145,95,60,0) 66%),
    repeating-linear-gradient(0deg, rgba(90,55,40,0.030) 0 1px, rgba(0,0,0,0) 1px 30px),
    repeating-linear-gradient(90deg, rgba(90,55,40,0.012) 0 1px, rgba(0,0,0,0) 1px 42px);
  z-index: 1;
  filter: blur(5px) saturate(1.08) contrast(1.05);
  opacity: var(--pigA);
  mix-blend-mode: multiply;
  pointer-events:none;
}

#letter .paper::after{
  content:"";
  position:absolute;
  inset:-26px;
  z-index: 2;
  background:
    radial-gradient(circle at 8px 8px, rgba(150,85,55,0.26) 0 1.1px, rgba(0,0,0,0) 2.4px),
    radial-gradient(circle at 12px 18px, rgba(210,150,95,0.20) 0 0.9px, rgba(0,0,0,0) 2.2px),
    url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22240%22%20height%3D%22240%22%3E%0A%20%20%3Cdefs%3E%0A%20%20%20%20%3Cfilter%20id%3D%22b%22%20x%3D%22-20%25%22%20y%3D%22-20%25%22%20width%3D%22140%25%22%20height%3D%22140%25%22%3E%0A%20%20%20%20%20%20%3CfeGaussianBlur%20stdDeviation%3D%220.35%22%2F%3E%0A%20%20%20%20%3C%2Ffilter%3E%0A%20%20%3C%2Fdefs%3E%0A%20%20%3Cg%20filter%3D%22url%28%23b%29%22%3E%0A%20%20%20%20%3Ccircle%20cx%3D%2277.7%22%20cy%3D%2236.2%22%20r%3D%221.90%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22197.1%22%20cy%3D%2222.6%22%20r%3D%221.77%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%2251.5%22%20cy%3D%2220.6%22%20r%3D%221.44%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%2221.8%22%20cy%3D%22101.9%22%20r%3D%222.25%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22227.4%22%20cy%3D%22151.4%22%20r%3D%221.77%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22138.5%22%20cy%3D%2295.2%22%20r%3D%222.55%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22133.6%22%20cy%3D%2232.0%22%20r%3D%221.44%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%2228.3%22%20cy%3D%2274.0%22%20r%3D%222.23%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%2224.7%22%20cy%3D%22137.1%22%20r%3D%220.98%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22131.5%22%20cy%3D%2215.1%22%20r%3D%220.72%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22119.1%22%20cy%3D%22127.6%22%20r%3D%222.15%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%22140.5%22%20cy%3D%22108.8%22%20r%3D%221.20%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22167.8%22%20cy%3D%2258.6%22%20r%3D%221.75%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%22118.8%22%20cy%3D%2282.4%22%20r%3D%221.50%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%22235.2%22%20cy%3D%2228.3%22%20r%3D%221.44%22%20fill%3D%22%23d88a4a%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2236.5%22%20cy%3D%22117.4%22%20r%3D%220.68%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22183.5%22%20cy%3D%22137.5%22%20r%3D%222.35%22%20fill%3D%22%23d88a4a%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2281.6%22%20cy%3D%2284.0%22%20r%3D%221.59%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2216.5%22%20cy%3D%2222.5%22%20r%3D%221.14%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%2214.6%22%20cy%3D%22168.4%22%20r%3D%221.89%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2268.3%22%20cy%3D%2292.6%22%20r%3D%221.94%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22225.8%22%20cy%3D%2285.3%22%20r%3D%221.82%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2214.1%22%20cy%3D%22184.4%22%20r%3D%220.86%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%2295.5%22%20cy%3D%22220.0%22%20r%3D%221.59%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22107.8%22%20cy%3D%22131.9%22%20r%3D%222.37%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%22207.4%22%20cy%3D%2266.8%22%20r%3D%221.43%22%20fill%3D%22%23d88a4a%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%22163.9%22%20cy%3D%2291.3%22%20r%3D%221.06%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%2242.3%22%20cy%3D%2255.7%22%20r%3D%221.07%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%22199.5%22%20cy%3D%2243.8%22%20r%3D%221.16%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22100.5%22%20cy%3D%2288.6%22%20r%3D%221.73%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22165.7%22%20cy%3D%22123.7%22%20r%3D%221.84%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22109.6%22%20cy%3D%22209.0%22%20r%3D%222.50%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%2294.2%22%20cy%3D%2295.8%22%20r%3D%220.81%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2214.9%22%20cy%3D%2216.2%22%20r%3D%221.02%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%2226.4%22%20cy%3D%22144.2%22%20r%3D%220.80%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%2236.3%22%20cy%3D%2224.4%22%20r%3D%221.33%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%2216.9%22%20cy%3D%2249.9%22%20r%3D%221.35%22%20fill%3D%22%23d88a4a%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%22229.3%22%20cy%3D%22144.5%22%20r%3D%221.55%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22203.7%22%20cy%3D%22238.3%22%20r%3D%221.53%22%20fill%3D%22%23a4633e%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2274.8%22%20cy%3D%2234.6%22%20r%3D%222.10%22%20fill%3D%22%23d88a4a%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%22114.9%22%20cy%3D%22166.1%22%20r%3D%221.63%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22228.2%22%20cy%3D%22126.8%22%20r%3D%220.89%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%22219.4%22%20cy%3D%22182.0%22%20r%3D%221.20%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22167.1%22%20cy%3D%2262.7%22%20r%3D%221.33%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%2285.4%22%20cy%3D%2253.5%22%20r%3D%221.68%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%2279.1%22%20cy%3D%2253.5%22%20r%3D%222.22%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22193.5%22%20cy%3D%22196.4%22%20r%3D%222.08%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%2248.0%22%20cy%3D%22118.3%22%20r%3D%222.06%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22189.6%22%20cy%3D%22113.3%22%20r%3D%220.99%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%22229.6%22%20cy%3D%22107.3%22%20r%3D%222.47%22%20fill%3D%22%23d88a4a%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%22229.2%22%20cy%3D%2287.5%22%20r%3D%221.04%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22112.8%22%20cy%3D%2281.1%22%20r%3D%221.57%22%20fill%3D%22%23e2a06a%22%20opacity%3D%220.12%22%2F%3E%3Ccircle%20cx%3D%22201.7%22%20cy%3D%22115.1%22%20r%3D%221.91%22%20fill%3D%22%23c07a3a%22%20opacity%3D%220.18%22%2F%3E%3Ccircle%20cx%3D%22200.3%22%20cy%3D%2228.8%22%20r%3D%221.38%22%20fill%3D%22%23b46b3e%22%20opacity%3D%220.16%22%2F%3E%3Ccircle%20cx%3D%22114.7%22%20cy%3D%2242.8%22%20r%3D%222.18%22%20fill%3D%22%23d88a4a%22%20opacity%3D%220.14%22%2F%3E%3Ccircle%20cx%3D%2220.8%22%20cy%3D%22227.1%22%20r%3D%226.75%22%20fill%3D%22%23b86a43%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%2296.3%22%20cy%3D%22227.2%22%20r%3D%226.76%22%20fill%3D%22%23d77b3f%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%22238.3%22%20cy%3D%226.6%22%20r%3D%226.16%22%20fill%3D%22%23b86a43%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%22193.6%22%20cy%3D%2235.1%22%20r%3D%227.22%22%20fill%3D%22%23b86a43%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%22157.7%22%20cy%3D%2284.1%22%20r%3D%225.97%22%20fill%3D%22%23d77b3f%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%225.1%22%20cy%3D%22191.8%22%20r%3D%226.77%22%20fill%3D%22%23d77b3f%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%22126.4%22%20cy%3D%22224.1%22%20r%3D%225.45%22%20fill%3D%22%23d77b3f%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%22198.3%22%20cy%3D%2250.7%22%20r%3D%224.63%22%20fill%3D%22%23b86a43%22%20opacity%3D%220.10%22%2F%3E%3Ccircle%20cx%3D%22120.3%22%20cy%3D%22183.3%22%20r%3D%224.97%22%20fill%3D%22%23e4a16a%22%20opacity%3D%220.08%22%2F%3E%3Ccircle%20cx%3D%22100.6%22%20cy%3D%2231.5%22%20r%3D%227.60%22%20fill%3D%22%23b86a43%22%20opacity%3D%220.10%22%2F%3E%0A%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E") repeat,
    url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22180%22%20height%3D%22180%22%3E%0A%20%20%3Cfilter%20id%3D%22n%22%3E%0A%20%20%20%20%3CfeTurbulence%20type%3D%22fractalNoise%22%20baseFrequency%3D%220.85%22%20numOctaves%3D%223%22%20stitchTiles%3D%22stitch%22%2F%3E%0A%20%20%20%20%3CfeColorMatrix%20type%3D%22saturate%22%20values%3D%220%22%2F%3E%0A%20%20%3C%2Ffilter%3E%0A%20%20%3Crect%20width%3D%22180%22%20height%3D%22180%22%20filter%3D%22url%28%23n%29%22%20opacity%3D%220.6%22%2F%3E%0A%3C%2Fsvg%3E") repeat,
    repeating-linear-gradient(25deg, rgba(255,255,255,0.045) 0 2px, rgba(0,0,0,0) 2px 10px),
    repeating-linear-gradient(-25deg, rgba(0,0,0,0.028) 0 1px, rgba(0,0,0,0) 1px 12px);
  background-size: 26px 26px, 34px 34px, 240px 240px, 180px 180px, auto, auto;
  background-position: 0 0, 12px 20px, 0 0, 40px 60px, 0 0, 0 0;
  opacity: var(--pigB);
  mix-blend-mode: multiply;
  pointer-events:none;
  transform: rotate(-2deg);
  filter: blur(0.20px) contrast(1.12) brightness(1.02);
}

@media (max-width: 420px){
  #letter .paper{ --pigA: 0.74; --pigB: 0.54; }
  #letter .paper::before{ filter: blur(4.6px) saturate(1.06) contrast(1.05); }
}


</style>
</head>
<body>
  <canvas id="c" role="img" aria-label="Animación de un ramo de orquídeas bajo un cielo estrellado con nubes, luna y la constelación de Capricornio y Leo"></canvas>

  <div id="introScreen" role="dialog" aria-modal="true" aria-labelledby="introTitle" aria-describedby="introMsg">
    <div id="loveWrap">
      <div id="envelope" aria-hidden="true"></div>

      <div id="letter" aria-hidden="false">
        <div class="paperBack" aria-hidden="true"></div>
        <div class="paper">

          <div class="paperShimmer" aria-hidden="true"></div>


          <svg class="paperFrame" viewBox="0 0 600 800" aria-hidden="true" focusable="false" preserveAspectRatio="none">
            <g>
              <rect x="28" y="28" width="544" height="744" rx="22" fill="none" stroke="currentColor" opacity=".22" class="thin"/>
              <rect x="44" y="44" width="512" height="712" rx="18" fill="none" stroke="currentColor" opacity=".16" class="thin"/>
            </g>
          </svg>

<div id="paperContent">
            <div id="introTextBlock">
              <div id="introMsg">recuerda que son con mucho cariño</div>
              <div id="introTitle">para ti, preciosa <span class="heart" aria-hidden="true">
                <svg class="heartSvg" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                  <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5C2 6 3.99 4 6.5 4c1.74 0 3.41.81 4.5 2.09C12.09 4.81 13.76 4 15.5 4C18.01 4 20 6 20 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
              </span></div>
            </div>

            <button id="introBtn" type="button" aria-label="Abrir la carta">Toca aquí</button>
</div>
        </div>
      </div>

      <div id="rose" aria-hidden="true"></div>
    </div>
  </div>

  <script>
(() => {
  'use strict';

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  // ===== Intro overlay (móvil + desktop) =====
  const introScreen = document.getElementById('introScreen');
  const introBtn    = document.getElementById('introBtn');

  // Enfoca el botón para accesibilidad/teclado (sin desplazar la vista)
  requestAnimationFrame(() => {
    try { introBtn && introBtn.focus({ preventScroll:true }); } catch(_){}
  });

  const paperEl  = document.querySelector('#letter .paper');

  const titleEl = document.getElementById('introTitle');

  function fitIntroTitle(){
    if(!titleEl || !paperEl) return;
    // reset
    titleEl.style.transform = '';
    // available width inside margins
    const framePad = parseFloat(getComputedStyle(paperEl).getPropertyValue('--framePad')) || 40;
    const maxW = Math.max(120, paperEl.clientWidth - framePad*2 - 10);
    // force no-wrap while measuring
    const w = titleEl.scrollWidth || titleEl.getBoundingClientRect().width;
    if(w > maxW){
      const s = Math.max(0.80, maxW / w);
      titleEl.style.transform = `scale(${s})`;
    }
  }
window.addEventListener('resize', () => requestAnimationFrame(() => { fitIntroTitle(); }), {passive:true});
  try{
    if(document.fonts && document.fonts.ready){
      document.fonts.ready.then(() => requestAnimationFrame(() => { fitIntroTitle(); }));
    }
  }catch(_){}
  requestAnimationFrame(() => { fitIntroTitle(); });
  // Mantén el canvas escondido hasta el toque/click
  canvas.classList.remove('show');

  let _started = false;
  function startExperience(){
    if(_started) return;
    _started = true;

    // Inicia la “generación” del ramo a partir del toque
    // La retrasamos un poco para que no te pierdas el inicio mientras se desvanece la carta.
    try{ restartIntro(380); }catch(_){}

    // Transición visual (tipo “pasar página”)
    try{ document.getElementById('loveWrap')?.classList.add('go'); }catch(_){}
    canvas.classList.add('show');
    if(introScreen) setTimeout(()=>{ try{ introScreen.classList.add('hide'); }catch(_){} }, 180);

    // Arranca la animación
    start();

    // Limpia overlay al final del fade
    setTimeout(()=>{ try{ introScreen && introScreen.remove(); }catch(_){} }, 1450);
  }

  // En móvil, NO confíes solo en "click". Usa pointer y touch también.
  const bindStart = (el) => {
    if(!el) return;
    const opts = { passive:true, once:true };
    if (window.PointerEvent) {
      el.addEventListener('pointerup', startExperience, opts);
    } else {
      el.addEventListener('touchend', startExperience, opts);
      el.addEventListener('click', startExperience, opts);
    }
  };
  bindStart(introBtn);

  // Permite tocar en cualquier parte de la carta (móvil friendly)
  if(introScreen){
    const tapAnywhere = (e)=>{
      // Si fue el botón, ya lo maneja el propio botón
      try{ if(e && e.target && e.target.closest && e.target.closest('#introBtn')) return; }catch(_){}
      startExperience();
    };
    introScreen.addEventListener('pointerup', tapAnywhere, {passive:true});
    introScreen.addEventListener('touchend',  tapAnywhere, {passive:true});
    introScreen.addEventListener('click',     tapAnywhere, {passive:true});
  }

  window.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' ') startExperience();
  });


  const hud = document.getElementById('hud');

  let HAS_FILTER = false; try{ ctx.filter = 'none'; HAS_FILTER = (typeof ctx.filter !== 'undefined'); }catch(_){ HAS_FILTER = false; }

  let W = 0, H = 0, DPR = 1;

  const TAU = Math.PI * 2;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rgba  = (r,g,b,a)=>`rgba(${r},${g},${b},${a})`;



  // HSL -> RGB (para dar colores aleatorios bonitos sin depender de una lista fija)
  function hslToRgb(h, s, l){
    h = ((h % 360) + 360) % 360;
    s = clamp(s/100, 0, 1);
    l = clamp(l/100, 0, 1);

    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = h / 60;
    const x = c * (1 - Math.abs((hp % 2) - 1));

    let r1=0, g1=0, b1=0;
    if(hp >= 0 && hp < 1){ r1=c; g1=x; b1=0; }
    else if(hp < 2){ r1=x; g1=c; b1=0; }
    else if(hp < 3){ r1=0; g1=c; b1=x; }
    else if(hp < 4){ r1=0; g1=x; b1=c; }
    else if(hp < 5){ r1=x; g1=0; b1=c; }
    else { r1=c; g1=0; b1=x; }

    const m = l - c/2;
    return {
      r: Math.round((r1+m)*255),
      g: Math.round((g1+m)*255),
      b: Math.round((b1+m)*255)
    };
  }
// Color estable por semilla (rosa intenso difuminado)
// Nota: hslToRgb usa grados y s/l en 0..100
const colorFromSeed = (seed)=>{
  let s = (seed >>> 0) || 1;
  const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

  // Rosas: 320..345° (magenta)
  const hDeg = lerp(320, 345, rnd());

  // Saturación y luminancia en rangos agradables
  const satP = lerp(70, 96, rnd());
  const ligP = lerp(44, 68, rnd());

  const rgb = hslToRgb(hDeg, satP, ligP);

  // Empuja hacia blanco para que se vea “difuminado” (pastel)
  const w = lerp(0.08, 0.32, rnd());

  return {
    r: clamp(Math.round(lerp(rgb.r, 255, w)), 150, 255),
    g: clamp(Math.round(lerp(rgb.g, 255, w)), 45, 230),
    b: clamp(Math.round(lerp(rgb.b, 255, w)), 110, 255),
  };
};

// ===== Intro: generación del ramo al abrir =====
// master: 0..1 controla el “construir” tallo -> hojas -> pétalos.
const INTRO = { active: true, t0: performance.now(), dur: 5200 };

const smoothstep = (a,b,x) => {
  const t = clamp((x - a) / Math.max(1e-6, (b - a)), 0, 1);
  return t*t*(3 - 2*t);
};

const easeOutCubic = (t)=> 1 - Math.pow(1 - clamp(t,0,1), 3);

const cubic = (t, a,b,c,d) => {
  const u = 1 - t;
  return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
};

function strokeCubicPartial(x0,y0,x1,y1,x2,y2,x3,y3,u, stepsMax=28){
  const uu = clamp(u, 0, 1);
  const steps = Math.max(2, Math.floor(stepsMax * uu));
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  for(let i=1;i<=steps;i++){
    const tt = uu * (i/steps);
    ctx.lineTo(
      cubic(tt, x0,x1,x2,x3),
      cubic(tt, y0,y1,y2,y3)
    );
  }
  ctx.stroke();
  return {
    x: cubic(uu, x0,x1,x2,x3),
    y: cubic(uu, y0,y1,y2,y3)
  };
}
// ---- Helpers: tallos con taper + detalle ----
function cubicD(t, a,b,c,d){
  const u = 1 - t;
  return 3*u*u*(b - a) + 6*u*t*(c - b) + 3*t*t*(d - c);
}
function pointOnCubic(t, x0,y0,x1,y1,x2,y2,x3,y3){
  return { x: cubic(t, x0,x1,x2,x3), y: cubic(t, y0,y1,y2,y3) };
}
function normalOnCubic(t, x0,y0,x1,y1,x2,y2,x3,y3){
  const dx = cubicD(t, x0,x1,x2,x3);
  const dy = cubicD(t, y0,y1,y2,y3);
  const len = Math.hypot(dx, dy) || 1;
  const tx = dx/len, ty = dy/len;
  return { tx, ty, nx: -ty, ny: tx, ang: Math.atan2(ty, tx) };
}
// Dibuja una cúbica hasta u con grosor variable (taper). Mantiene el mismo strokeStyle para ser rápido.
function strokeCubicTaperPartial(x0,y0,x1,y1,x2,y2,x3,y3,u,w0,w1, stepsMax=34){
  const uu = clamp(u, 0, 1);
  const steps = Math.max(3, Math.floor(stepsMax * uu));
  let px = x0, py = y0;
  for(let i=1;i<=steps;i++){
    const tt = uu * (i/steps);
    const x = cubic(tt, x0,x1,x2,x3);
    const y = cubic(tt, y0,y1,y2,y3);
    const k = (i/steps);
    // taper suave: más grueso abajo, más delgado arriba
    const w = lerp(w0, w1, smoothstep(0.0, 1.0, k));
    ctx.lineWidth = w;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(x, y);
    ctx.stroke();
    px = x; py = y;
  }
  return {x:px, y:py};
}
function drawStemNode(tt, x0,y0,x1,y1,x2,y2,x3,y3, r, alpha=0.10){
  const p = pointOnCubic(tt, x0,y0,x1,y1,x2,y2,x3,y3);
  const n = normalOnCubic(tt, x0,y0,x1,y1,x2,y2,x3,y3);

  ctx.save();
  // sombra del nodo
  ctx.globalCompositeOperation = 'multiply';
  ctx.globalAlpha = alpha;
  ctx.fillStyle = 'rgba(0,0,0,0.30)';
  ctx.beginPath();
  ctx.ellipse(p.x - n.nx*r*0.35, p.y - n.ny*r*0.35, r*1.10, r*0.55, n.ang, 0, TAU);
  ctx.fill();

  // brillo leve del nodo (lado luna)
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = alpha*0.75;
  ctx.fillStyle = 'rgba(210,255,230,0.35)';
  ctx.beginPath();
  ctx.ellipse(p.x + n.nx*r*0.28, p.y + n.ny*r*0.28, r*0.88, r*0.42, n.ang, 0, TAU);
  ctx.fill();
  ctx.restore();
}

// ---- Brillo ascendente (tallo -> flor) durante la generación ----
// u1: posición 0..1 a lo largo del tallo, seg: largo del segmento (0..1)
function drawStemGlowSegment(x0,y0,x1,y1,x2,y2,x3,y3,u1, seg, scale, a){
  if(a <= 0) return;
  const uu = clamp(u1, 0, 1);
  const u0 = clamp(uu - seg, 0, uu);
  const p0 = pointOnCubic(u0, x0,y0,x1,y1,x2,y2,x3,y3);
  const p1 = pointOnCubic(uu, x0,y0,x1,y1,x2,y2,x3,y3);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = 0.72 * a;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  ctx.shadowColor = 'rgba(255,245,220,0.85)';
  ctx.shadowBlur  = 18 * scale;

  const lg = ctx.createLinearGradient(p0.x, p0.y, p1.x, p1.y);
  lg.addColorStop(0, 'rgba(255,255,255,0)');
  lg.addColorStop(0.35, 'rgba(255,255,255,0.22)');
  lg.addColorStop(1, 'rgba(255,255,255,0.88)');
  ctx.strokeStyle = lg;
  ctx.lineWidth = Math.max(1.4, 2.55 * scale);

  const steps = 16;
  ctx.beginPath();
  for(let i=0;i<=steps;i++){
    const tt = lerp(u0, uu, i/steps);
    const px = cubic(tt, x0,x1,x2,x3);
    const py = cubic(tt, y0,y1,y2,y3);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // cabeza del brillo
  const r = 22 * scale;
  const rg = ctx.createRadialGradient(p1.x, p1.y, 0, p1.x, p1.y, r);
  rg.addColorStop(0, `rgba(255,255,255,${0.26*a})`);
  rg.addColorStop(0.35, `rgba(255,235,200,${0.16*a})`);
  rg.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = rg;
  ctx.beginPath();
  ctx.arc(p1.x, p1.y, r, 0, TAU);
  ctx.fill();

  ctx.restore();
}

function drawBloomGlow(x, y, col, u, scale){
  const a = clamp(u, 0, 1);
  if(a <= 0) return;

  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = 0.42 * a;

  const r = 34 * scale;
  const rg = ctx.createRadialGradient(x, y, 0, x, y, r);
  rg.addColorStop(0, `rgba(255,255,255,${0.22*a})`);
  rg.addColorStop(0.24, `rgba(${col.r},${col.g},${col.b},${0.20*a})`);
  rg.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = rg;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, TAU);
  ctx.fill();

  ctx.restore();
}



function restartIntro(delayMs=0){
  INTRO.active = true;
  INTRO.t0 = performance.now() + (delayMs||0);
}


  // Campo de viento global (compartido por pasto y orquídeas)
  const windField = (t) => {
    if(CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) return 0;
    // combinación lenta (natural y suave)
    return (Math.sin(t*0.00055)*0.78 + Math.sin(t*0.00023 + 1.7)*0.34);
  };

  const shuffleInPlace = (arr) => {
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  };

  const makePRNG = (seed) => {
    let s = (seed >>> 0) || 1;
    return () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);
  };

  const CONFIG = {
    stars: 320,
    twinkle: 0.90,
    sway: 0.65,
    reduceMotion: false,
    forceFlowerMotion: true,
    shootingStars: 1,

    // 0..1: “corona/picos” (arriba del tulipán). 0 = casi lisa
    crownStrength: 0.008,

    // Texto “en estrellas”
    starText: 'hoy o mañana, pero contigo',
    starTextStrength: 0.95    ,

    // Rendimiento / calidad
    maxFPS: 60,
    dprCap: 1.8,
    grassAnimFactor: 1.0,
    grassDetail: 1,
    debug: false,
    quality: 2,
    hud: false,
    autoQuality: false

  };

  try{
    const m = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
    if(m && m.matches) CONFIG.reduceMotion = true;
  }catch(_){}


  // ===== Persistencia + HUD =====
  const STORAGE_KEY = 'daily_flowers_settings_v1';

  function loadSettings(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);
      if(!s || typeof s !== 'object') return;

      if(typeof s.quality === 'number') CONFIG.quality = clamp(s.quality, 0, 2);
      if(typeof s.reduceMotion === 'boolean') CONFIG.reduceMotion = s.reduceMotion;
      if(typeof s.shootingStars === 'number') CONFIG.shootingStars = s.shootingStars ? 1 : 0;
      if(typeof s.hud === 'boolean') CONFIG.hud = s.hud;
      if(typeof s.autoQuality === 'boolean') CONFIG.autoQuality = s.autoQuality;
    }catch(_){}
  }

  function saveSettings(){
    try{
      const s = {
        quality: CONFIG.quality ?? 2,
        reduceMotion: !!CONFIG.reduceMotion,
        shootingStars: CONFIG.shootingStars ? 1 : 0,
        hud: !!CONFIG.hud,
        autoQuality: !!CONFIG.autoQuality
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
    }catch(_){}
  }

  function setHudVisible(v){
    CONFIG.hud = !!v;
    if(hud) hud.classList.toggle('hidden', !CONFIG.hud);
    saveSettings();
  }

  function updateHUD(force){
    if(!hud) return;
    const now = performance.now();
    if(!force && updateHUD._t && (now - updateHUD._t) < 250) return;
    updateHUD._t = now;

    hud.classList.toggle('hidden', !CONFIG.hud);

    const qName = QUALITY_PRESETS?.[CONFIG.quality ?? 2]?.name ?? 'alta';
    const rm = CONFIG.reduceMotion ? 'ON' : 'OFF';
    const ss = CONFIG.shootingStars ? 'ON' : 'OFF';
    const aq = CONFIG.autoQuality ? 'ON' : 'OFF';

    hud.innerHTML =
      '<div class="title">Daily flowers panel</div>' +
      '<div class="row"><kbd>Q</kbd> calidad: <b>' + qName + '</b> | <kbd>A</kbd> auto: <b>' + aq + '</b></div>' +
      '<div class="row"><kbd>M</kbd> motion: <b>' + rm + '</b> | <kbd>S</kbd> fugaces: <b>' + ss + '</b></div>' +
      '<div class="row"><kbd>E</kbd> export PNG | <kbd>P</kbd> foto | <kbd>R</kbd> re-generar | <kbd>H</kbd> ocultar panel</div>';
  }

  loadSettings();


// ===== Calidad rápida (Q) y atajos =====
const QUALITY_PRESETS = [
  { name: 'baja',  dpr: 1.15, stars: 140, twinkle: 0.65, sway: 0.16, shoot: 0, grass: 0.55, grassDetail: 0, fps: 40 },
  { name: 'media', dpr: 1.40, stars: 200, twinkle: 0.75, sway: 0.22, shoot: 1, grass: 0.80, grassDetail: 0, fps: 55 },
  { name: 'alta',  dpr: 1.80, stars: 240, twinkle: 0.80, sway: 0.28, shoot: 1, grass: 1.00, grassDetail: 1, fps: 60 }
];

function applyQuality(level, doResize=true){
  const q = QUALITY_PRESETS[clamp(level,0,2)];
  CONFIG.quality = clamp(level,0,2);
  CONFIG.dprCap = q.dpr;
  CONFIG.stars = q.stars;
  CONFIG.twinkle = q.twinkle;
  CONFIG.sway = q.sway;
  CONFIG.shootingStars = q.shoot;
  CONFIG.grassAnimFactor = q.grass;
  CONFIG.grassDetail = (typeof q.grassDetail === 'number') ? q.grassDetail : 1;
  CONFIG.maxFPS = q.fps;
  if(doResize) requestResize();
  saveSettings();
  updateHUD(true);
}

// aplica preset guardado sin forzar resize inmediato
applyQuality(CONFIG.quality ?? 2, false);
setHudVisible(CONFIG.hud);
updateHUD(true);

function cycleQuality(){
  applyQuality((CONFIG.quality ?? 2) === 2 ? 1 : ((CONFIG.quality ?? 2) === 1 ? 0 : 2));
}


function exportPNG(filename){
  const name = filename || 'daily_flowers.png';
  try{
    // Congela un frame limpio antes de exportar
    const t = performance.now();
    const prevRM = CONFIG.reduceMotion;
    CONFIG.reduceMotion = true;

    drawSky(t);
    rebuildFieldCache();
    if(fieldCache){ ctx.drawImage(fieldCache, 0, 0, fieldCache.width / DPR, fieldCache.height / DPR); }
    drawBouquet(t);
    drawTapSparkles(t);

    CONFIG.reduceMotion = prevRM;

    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }catch(_){
    try{
      const url = canvas.toDataURL('image/png');
      window.open(url, '_blank');
    }catch(__){}
  }
}

function photoExport(){
  // “Modo foto”: pausa movimiento, dibuja un frame y exporta.
  // (No hace upscale agresivo para no freír la memoria del navegador.)
  exportPNG('your_daily_flowers.png');
}

window.addEventListener('keydown', (e) => {
  const k = (e.key || '').toLowerCase();

  if(k === 'q'){ cycleQuality(); }

  if(k === 'a'){
    CONFIG.autoQuality = !CONFIG.autoQuality;
    saveSettings();
    updateHUD(true);
  }

  if(k === 'm'){
    CONFIG.reduceMotion = !CONFIG.reduceMotion;
    saveSettings();
    requestResize(); // reconstruye caches (incluye cielo estático)
    updateHUD(true);
  }

  if(k === 's'){
    CONFIG.shootingStars = CONFIG.shootingStars ? 0 : 1;
    saveSettings();
    updateHUD(true);
  }

  if(k === 'h'){
    setHudVisible(!CONFIG.hud);
    updateHUD(true);
  }

  if(k === 'e'){
    exportPNG();
  }

  if(k === 'p'){
    photoExport();
  }

  if(k === 'r'){
    restartIntro();
  }

}, {passive:true});

  // ===== Stars =====
  const stars = [];
  const starLinks = [];
  const textStars = [];
  const tapSparkles = [];

  // Luz “luna” coherente (arriba-derecha)
  const LIGHT = { x:0.18, y:0.14 };
  const LIGHT_DIR = (() => {
    const dx = 0.74, dy = -0.52;
    const inv = 1 / Math.max(1e-6, Math.hypot(dx,dy));
    return { x: dx*inv, y: dy*inv };
  })();

  const shooting = { active:false, t0:0, dur:0, x0:0,y0:0, x1:0,y1:0 };

  function seedStars(){
    stars.length = 0;
    starLinks.length = 0;

    const clusters = [
      {cx: 0.28, cy: 0.20, r: 0.18},
      {cx: 0.72, cy: 0.16, r: 0.20},
      {cx: 0.52, cy: 0.30, r: 0.16},
      {cx: 0.12, cy: 0.12, r: 0.14},   // micro-cúmulo (izq arriba)
      {cx: 0.88, cy: 0.22, r: 0.15},   // micro-cúmulo (der medio)
    ];

    const mwBand = () => {
      const t = Math.random();
      const x = lerp(0.14, 0.92, t);
      const y = lerp(0.48, 0.20, t);
      const off = (Math.random()-0.5) * 0.10;
      return { x: clamp(x + off*0.90, 0, 1), y: clamp(y + off*(-0.55), 0, 1) };
    };

    const pick = () => {
      const r = Math.random();
      if(r < 0.62){
        const x = Math.random();
        const y = Math.pow(Math.random(), 1.55);
        return {x, y};
      }
      if(r < 0.78) return mwBand();

      const c = clusters[(Math.random()*clusters.length)|0];
      const a = Math.random()*TAU;
      const rr = Math.sqrt(Math.random()) * c.r;
      return { x: clamp(c.cx + Math.cos(a)*rr, 0, 1), y: clamp(c.cy + Math.sin(a)*rr, 0, 1) };
    };

    for(let i=0;i<CONFIG.stars;i++){
      const p = pick();
      const yBias = Math.pow(1 - p.y, 1.8);

      const roll = Math.random();
      const big = roll < (0.045 + 0.025*yBias);
      const mid = !big && roll < (0.22 + 0.06*yBias);

      const rBase = big ? (2.2 + Math.random()*3.0)
                  : (mid ? (1.2 + Math.random()*1.4) : (0.55 + Math.random()*0.95));
      const aBase = big ? (0.18 + Math.random()*0.28)
                  : (mid ? (0.10 + Math.random()*0.16) : (0.05 + Math.random()*0.12));

      let hue = 0;
      const temp = Math.random();
      if(temp < 0.10) hue = 205 + Math.random()*35;
      else if(temp < 0.16) hue = 35 + Math.random()*18;
      else if(temp < 0.19) hue = 10 + Math.random()*20; // rojizo raro
      else if(big && temp < 0.45) hue = 200 + Math.random()*60;

      stars.push({
        x: p.x, y: p.y,
        z: big ? 0.92 : (mid ? 0.68 : (0.35 + Math.random()*0.35)),
        r: rBase, a: aBase,
        p: Math.random()*TAU,
        s: (0.25 + Math.random()*0.95),
        hue,
        flare: big ? (0.55 + Math.random()*0.45) : (mid ? (0.18 + Math.random()*0.35) : 0),
        tw: big ? (0.45 + Math.random()*0.40) : (mid ? (0.30 + Math.random()*0.30) : (0.18 + Math.random()*0.22))
      });
    }

    buildConstellations();

    shooting.active = false;
    shooting.t0 = 0;
    shooting.dur = 0;
  }

  function buildConstellations(){
    starLinks.length = 0;
    if(stars.length < 6) return;

    // Conectamos algunas estrellas brillantes en "constelaciones" sutiles (sin volverlo un mapa de metro)
    const ids = stars
      .map((s,i)=>({i, score: s.r * (0.85 + s.a)}))
      .sort((a,b)=>b.score-a.score)
      .slice(0, 18)
      .map(o=>o.i);

    const maxDist = 0.13;
    const used = new Set();

    for(const i of ids){
      let best1=-1,best2=-1;
      let d1=1e9,d2=1e9;

      for(const j of ids){
        if(j===i) continue;
        const dx = stars[i].x - stars[j].x;
        const dy = stars[i].y - stars[j].y;
        const d = Math.hypot(dx,dy);
        if(d > maxDist) continue;

        if(d < d1){ d2=d1; best2=best1; d1=d; best1=j; }
        else if(d < d2){ d2=d; best2=j; }
      }

      const add = (j, dist) => {
        if(j < 0 || !Number.isFinite(dist)) return;
        const a = Math.max(0.016, 0.055 - dist*0.22);
        const key = i<j ? `${i}-${j}` : `${j}-${i}`;
        if(used.has(key)) return;
        used.add(key);
        starLinks.push({i, j, a});
      };

      add(best1, d1);
      add(best2, d2);
    }
  }


  function maybeStartShootingStar(t){
    if(CONFIG.reduceMotion || !CONFIG.shootingStars) return;
    if(shooting.active) return;

    if(Math.random() < 0.0022){
      shooting.active = true;
      shooting.t0 = t;
      shooting.dur = 900 + Math.random()*900;

      const startX = Math.random()*W*0.90;
      const startY = Math.random()*H*0.35;
      const dx = (120 + Math.random()*220);
      const dy = (40 + Math.random()*120);

      shooting.x0 = startX; shooting.y0 = startY;
      shooting.x1 = startX + dx; shooting.y1 = startY + dy;
    }
  }

  function drawShootingStar(t){
    if(!shooting.active) return;

    const u = clamp((t - shooting.t0) / shooting.dur, 0, 1);
    const ease = u*u*(3-2*u);

    const x = lerp(shooting.x0, shooting.x1, ease);
    const y = lerp(shooting.y0, shooting.y1, ease);

    const tail = 120;
    const ang = Math.atan2(shooting.y1 - shooting.y0, shooting.x1 - shooting.x0);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = (1-u) * 0.85;

    const tx = x - Math.cos(ang)*tail;
    const ty = y - Math.sin(ang)*tail;

    const g = ctx.createLinearGradient(tx, ty, x, y);
    g.addColorStop(0, 'rgba(255,255,255,0)');
    g.addColorStop(0.55, 'rgba(255,255,255,0.14)');
    g.addColorStop(1, 'rgba(255,255,255,0.85)');

    ctx.strokeStyle = g;
    ctx.lineWidth = 2.0;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(x, y);
    ctx.stroke();

    ctx.globalAlpha = (1-u) * 0.95;
    ctx.shadowColor = 'rgba(255,255,255,0.8)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x,y, 1.8, 0, TAU);
    ctx.fill();

    ctx.restore();

    if(u >= 1) shooting.active = false;
  }

  // ===== Césped =====
  const grass = [];
  const soil = [];
  const grassAnim1 = [];
  const grassAnim2 = [];

  // Capa extra: pasto en primer plano (para “fusionar” tallos con el suelo)
  const overlayGrass = [];

  // Luciérnagas/polvo brillante cerca del ramo (toque romántico sin matar el rendimiento)
  const fireflies = [];

  let groundCache = null;
  let skyCache = null;
  let staticSkyOverlayCache = null;
  let fieldCache = null;
  let fieldCacheKey = '';
  let fieldBandCache = null;
  let fieldBandCacheKey = '';


  let bouquetShadeCache = null;
  let bouquetShadeKey = '';

  function rebuildBouquetShadeCache(){
    const key = `${W}x${H}@d${DPR.toFixed(2)}`;
    if(bouquetShadeCache && bouquetShadeKey === key) return;
    bouquetShadeKey = key;

    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const hx = W*0.5, hy = H*0.78;
    const hg = g.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
    hg.addColorStop(0, 'rgba(0,0,0,0)');
    hg.addColorStop(1, 'rgba(0,0,0,0.30)');
    g.fillStyle = hg;
    g.fillRect(0,0,W,H);

    bouquetShadeCache = off;
  }

  let bushCache = null;
  let bushCacheKey = '';
  const bloomCache = new Map();

// ===== Sol (cache + generación) =====
let moonCache = null;
let moonCacheR = 0;
let moonCachePad = 0;

function rebuildMoonCache(){
  const r = Math.min(W,H) * 0.062;
  const pad = Math.ceil(r*0.25) + 3;

  const size = Math.ceil((r*2 + pad*2) * DPR);
  const off = document.createElement('canvas');
  off.width  = size;
  off.height = size;

  const g = off.getContext('2d', {alpha:true});
  g.setTransform(DPR,0,0,DPR,0,0);

  const cx = pad + r;
  const cy = pad + r;

  // disco con gradiente (sensación de esfera)
  g.save();
  g.globalCompositeOperation = 'screen';
  g.globalAlpha = 0.92;

  const disc = g.createRadialGradient(cx - r*0.25, cy - r*0.25, r*0.12, cx, cy, r);
  disc.addColorStop(0, 'rgba(255,255,255,0.95)');
  disc.addColorStop(0.42, 'rgba(238,245,255,0.90)');
  disc.addColorStop(0.78, 'rgba(210,225,245,0.86)');
  disc.addColorStop(1, 'rgba(190,205,230,0.82)');

  g.fillStyle = disc;
  g.beginPath();
  g.arc(cx, cy, r, 0, TAU);
  g.fill();

  // sombreado suave (terminador)
  g.globalCompositeOperation = 'multiply';
  g.globalAlpha = 0.22;
  const shade = g.createLinearGradient(cx - r, cy, cx + r, cy);
  shade.addColorStop(0, 'rgba(0,0,0,0.22)');
  shade.addColorStop(0.55, 'rgba(0,0,0,0.00)');
  shade.addColorStop(1, 'rgba(0,0,0,0.14)');
  g.fillStyle = shade;
  g.beginPath();
  g.arc(cx, cy, r, 0, TAU);
  g.fill();

  // textura/cráteres (determinística)
  let ms = (((W*73856093) ^ (H*19349663) ^ 0x9e3779b9) >>> 0) || 1;
  const mrnd = () => (ms = (ms * 1664525 + 1013904223) >>> 0, ms / 4294967296);

  g.save();
  g.beginPath();
  g.arc(cx, cy, r, 0, TAU);
  g.clip();

  // polvo fino
  g.globalCompositeOperation = 'overlay';
  g.globalAlpha = 0.10;
  for(let i=0;i<80;i++){
    const a = mrnd()*TAU;
    const rr = Math.sqrt(mrnd()) * r*0.92;
    const x = cx + Math.cos(a)*rr;
    const y = cy + Math.sin(a)*rr;
    g.fillStyle = 'rgba(255,255,255,0.08)';
    g.fillRect(x, y, 1, 1);
  }

  // cráteres con rim + sombra
  const craterN = 14;
  for(let i=0;i<craterN;i++){
    const a = mrnd()*TAU;
    const rr = Math.sqrt(mrnd()) * r*0.78;
    const px = cx + Math.cos(a)*rr;
    const py = cy + Math.sin(a)*rr;
    const cr = r*(0.06 + mrnd()*0.16);

    // sombra interna
    g.globalCompositeOperation = 'multiply';
    g.globalAlpha = 0.18;
    const cg = g.createRadialGradient(px + cr*0.18, py + cr*0.18, cr*0.15, px, py, cr);
    cg.addColorStop(0, 'rgba(0,0,0,0.00)');
    cg.addColorStop(1, 'rgba(0,0,0,0.38)');
    g.fillStyle = cg;
    g.beginPath();
    g.arc(px, py, cr, 0, TAU);
    g.fill();

    // rim iluminado
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.18;
    const rg = g.createRadialGradient(px - cr*0.25, py - cr*0.25, cr*0.05, px, py, cr);
    rg.addColorStop(0, 'rgba(255,255,255,0.22)');
    rg.addColorStop(1, 'rgba(255,255,255,0.00)');
    g.fillStyle = rg;
    g.beginPath();
    g.arc(px, py, cr, 0, TAU);
    g.fill();
  }

  g.restore();
  g.restore();

  moonCache = off;
  moonCacheR = r;
  moonCachePad = pad;
}

function moonIntroProgress(t){
  if(CONFIG.reduceMotion) return 1;
  if(!INTRO.active) return 1;

  // “se genera” primero, luego el ramo (para que se sienta como una escena construyéndose)
  const start = INTRO.t0 + 120;
  const dur   = 1650;

  const u = clamp((t - start) / dur, 0, 1);
  return smoothstep(0, 1, u);
}

function drawMoon(t){
  const r = Math.min(W,H) * 0.062;
  if(!moonCache || Math.abs(r - moonCacheR) > 0.02) rebuildMoonCache();

  const x = W * LIGHT.x;
  const y = H * LIGHT.y;

  const p = moonIntroProgress(t);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  // halo que “crece”
  const haloOuter = r * (2.0 + 9.5*p);
  const halo = ctx.createRadialGradient(x, y, r*0.22, x, y, haloOuter);
  halo.addColorStop(0, `rgba(255,255,255,${0.22*p})`);
  halo.addColorStop(0.18, `rgba(210,230,255,${0.10*p})`);
  halo.addColorStop(0.52, `rgba(140,190,255,${0.045*p})`);
  halo.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalAlpha = 1;
  ctx.fillStyle = halo;
  ctx.fillRect(0,0,W,H);

  // bloom suave cerca del borde
  const bloomR = r*(1.3 + 2.2*p);
  const bloom = ctx.createRadialGradient(x, y, r*0.6, x, y, bloomR);
  bloom.addColorStop(0, `rgba(255,255,255,${0.18*p})`);
  bloom.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = bloom;
  ctx.beginPath();
  ctx.arc(x, y, bloomR, 0, TAU);
  ctx.fill();

  // disco “aparece” desde el centro (con clip)
  const pad = moonCachePad;
  const drawW = moonCache.width / DPR;
  const drawH = moonCache.height / DPR;
  const dx = x - (r + pad);
  const dy = y - (r + pad);

  if(p < 1){
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, r * clamp(p*1.02, 0, 1), 0, TAU);
    ctx.clip();
    ctx.globalAlpha = 0.98;
    ctx.drawImage(moonCache, dx, dy, drawW, drawH);
    ctx.restore();

    // trazo de contorno “tipo generación”
    ctx.globalAlpha = 0.55 * (0.35 + 0.65*p);
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth = 1.8;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.arc(x, y, r*1.03, -Math.PI/2, -Math.PI/2 + TAU*p);
    ctx.stroke();
  }else{
    ctx.globalAlpha = 1;
    ctx.drawImage(moonCache, dx, dy, drawW, drawH);
  }

  ctx.restore();
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
}
function drawSun(t){
  const r = Math.min(W,H) * 0.064;
  const x = W * LIGHT.x;
  const y = H * LIGHT.y;

  // Aparición “generativa” (igual estilo que la luna)
  const p = moonIntroProgress(t);

  // Micro-ruido determinista rápido (sin Math.random en cada frame)
  let s = ((Math.floor(t/33) ^ 0x9e3779b9) + 12345) >>> 0;
  const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  // 1) Halo principal (cálido) con falloff suave
  const haloOuter = r * (2.6 + 10.5*p);
  const halo = ctx.createRadialGradient(x, y, r*0.18, x, y, haloOuter);
  halo.addColorStop(0.00, `rgba(255,250,230,${0.34*p})`);
  halo.addColorStop(0.10, `rgba(255,220,150,${0.18*p})`);
  halo.addColorStop(0.28, `rgba(255,175,90,${0.075*p})`);
  halo.addColorStop(0.60, `rgba(255,120,55,${0.028*p})`);
  halo.addColorStop(1.00, 'rgba(0,0,0,0)');
  ctx.fillStyle = halo;
  ctx.fillRect(0,0,W,H);

  // 2) “Corona” irregular: pequeñas lenguas de luz alrededor
  ctx.save();
  ctx.translate(x, y);
  ctx.globalAlpha = 0.18 * p;
  ctx.globalCompositeOperation = 'screen';
  const coronaN = 34;
  for(let i=0;i<coronaN;i++){
    const a = (i/coronaN)*TAU + t*0.00022;
    const len = r*(1.25 + 0.60*Math.sin(i*1.7 + t*0.0012));
    const w   = r*(0.20 + 0.12*Math.sin(i*2.3 - t*0.0015));
    const rr  = r*(1.02 + 0.10*Math.sin(i*3.1 + t*0.001));
    const gx  = Math.cos(a)*rr;
    const gy  = Math.sin(a)*rr;

    const g = ctx.createRadialGradient(gx, gy, r*0.03, gx, gy, len);
    g.addColorStop(0.0, 'rgba(255,235,175,0.40)');
    g.addColorStop(0.35,'rgba(255,190,115,0.18)');
    g.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.ellipse(gx, gy, len*0.55, w, a, 0, TAU);
    ctx.fill();
  }
  ctx.restore();

  // 3) Rayos suaves (tipo acuarela), animados muy lento
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(t*0.00010);
  ctx.globalAlpha = 0.11 * p;
  ctx.strokeStyle = 'rgba(255,210,140,0.55)';
  ctx.lineCap = 'round';
  const rayN = 20;
  for(let i=0;i<rayN;i++){
    const a = (i/rayN)*TAU;
    const base = r*(1.10 + 0.06*Math.sin(i*2.1));
    const tip  = r*(2.35 + 0.35*Math.sin(i*1.9 + t*0.001));
    const lw   = 1.2 + 1.0*(0.5 + 0.5*Math.sin(i*1.3));
    ctx.lineWidth = lw;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a)*base, Math.sin(a)*base);
    ctx.lineTo(Math.cos(a)*tip,  Math.sin(a)*tip);
    ctx.stroke();
  }
  ctx.restore();

  // 4) Disco del sol: gradiente con “hot core” y borde más naranja
  // Clip de aparición (para el efecto generativo)
  if(p < 1){
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, r * clamp(p*1.02, 0, 1), 0, TAU);
    ctx.clip();
  }

  const sun = ctx.createRadialGradient(x - r*0.22, y - r*0.18, r*0.08, x, y, r*1.10);
  sun.addColorStop(0.00, 'rgba(255,255,250,1.0)');
  sun.addColorStop(0.40, 'rgba(255,246,190,1.0)');
  sun.addColorStop(0.72, 'rgba(255,205,120,1.0)');
  sun.addColorStop(1.00, 'rgba(255,145,55,1.0)');
  ctx.fillStyle = sun;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, TAU);
  ctx.fill();

  // 5) Textura: granulación sutil + sunspots suaves
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  ctx.globalAlpha = 0.10 * p;
  ctx.fillStyle = 'rgba(120,70,30,0.35)';

  const spots = 7;
  for(let i=0;i<spots;i++){
    const a = rnd()*TAU;
    const rr = r*(0.10 + rnd()*0.65);
    const sx = x + Math.cos(a)*rr;
    const sy = y + Math.sin(a)*rr;
    const sr = r*(0.05 + rnd()*0.10);
    ctx.beginPath();
    ctx.ellipse(sx, sy, sr*(1.2+rnd()*0.6), sr*(0.8+rnd()*0.5), rnd()*0.8, 0, TAU);
    ctx.fill();
  }

  // grano muy fino
  ctx.globalAlpha = 0.06 * p;
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  const grains = 40;
  for(let i=0;i<grains;i++){
    const a = rnd()*TAU;
    const rr = r*(0.08 + rnd()*0.88);
    const gx = x + Math.cos(a)*rr;
    const gy = y + Math.sin(a)*rr;
    const gr = r*(0.008 + rnd()*0.016);
    ctx.beginPath();
    ctx.arc(gx, gy, gr, 0, TAU);
    ctx.fill();
  }
  ctx.restore();

  // 6) Rim light (borde brillante) para que “recorte” bien contra el cielo
  ctx.save();
  ctx.globalAlpha = 0.22 * p;
  ctx.strokeStyle = 'rgba(255,255,245,0.65)';
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.arc(x, y, r*1.01, 0, TAU);
  ctx.stroke();
  ctx.restore();

  if(p < 1){
    ctx.restore(); // clip
    // Trazo “tipo generación” (borde que se completa)
    ctx.globalAlpha = 0.55 * (0.35 + 0.65*p);
    ctx.strokeStyle = 'rgba(255,245,215,0.75)';
    ctx.lineWidth = 1.9;
    ctx.beginPath();
    ctx.arc(x, y, r*1.04, -Math.PI/2, -Math.PI/2 + TAU*p);
    ctx.stroke();
  }

  ctx.restore();
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
}



  function seedSoil(){
    soil.length = 0;
    const gy = H * 0.74;
    const groundH = H - gy;

    const blobs = clamp(Math.floor(W / 160), 6, 12);
    for(let i=0;i<blobs;i++){
      soil.push({
        x: W*(0.05 + Math.random()*0.90),
        y: gy + groundH*(0.25 + Math.random()*0.75),
        r: (90 + Math.random()*220),
        a: (0.08 + Math.random()*0.12)
      });
    }
  }

  function seedGrass(){
    grass.length = 0;

    const gy = H * 0.74;
    const groundH = H - gy;

    // Más pasto “arriba” para que no se vea una banda plana y el ramo no parezca flotando.
    // También damos un poquito más de densidad cerca del centro (donde está el ramo).
    const tufts = clamp(Math.floor(W / 14), 46, 120);
    const bladesBase = 11;
    const bladesExtra = 11;

    const center = W * 0.5;

    for(let t=0;t<tufts;t++){
      const tx = (t + Math.random()*0.85) * (W / tufts);
      const cx = Math.abs(tx - center) / Math.max(1, W*0.5);
      const bonus = (cx < 0.35) ? 3 : 0; // densidad sutil extra al centro

      const tuftSeed = Math.random()*TAU;
      const count = bladesBase + Math.floor(Math.random()*bladesExtra) + bonus;

      for(let i=0;i<count;i++){
        const r = Math.random();
        const layer = (r < 0.50) ? 0 : (r < 0.84 ? 1 : 2);

        // Antes el pasto “nacía” muy abajo. Ahora nace cerca del borde superior del suelo (gy)
        // y se vuelve más alto/denso hacia abajo.
        const baseBand = layer===2 ? 0.22 : (layer===1 ? 0.08 : 0.04);

        // Distribución: capas 0/1 más cerca del horizonte, capa 2 más hacia abajo.
        const u = (layer===2 ? Math.sqrt(Math.random()) : Math.pow(Math.random(), 1.55));
        const ty = gy + groundH*(baseBand + u*(1-baseBand));

        const jitterX = (Math.random()-0.5) * (12 + layer*22);
        const jitterY = (Math.random()-0.5) * (6 + layer*10);

        const depth = clamp((ty - gy) / Math.max(1e-6, groundH), 0, 1);

        const hBase = layer===2 ? 78 : (layer===1 ? 54 : 38);
        const hVar  = layer===2 ? 96 : (layer===1 ? 70 : 50);

        // Más corto cerca del horizonte (depth~0), más largo hacia abajo (depth~1)
        const hScale = (layer===2 ? (0.70 + 0.60*depth) : (0.52 + 0.90*depth));
        const h = (hBase + Math.random()*hVar) * hScale;

        const curlAmp = layer===2 ? 0.65 : (layer===1 ? 0.55 : 0.45);

        const aBase = (layer===2 ? 0.18 : (layer===1 ? 0.14 : 0.11)) + Math.random()*(layer===2 ? 0.22 : (layer===1 ? 0.18 : 0.14));
        // Más transparente arriba, más presente abajo
        const a = aBase * (0.60 + 0.55*depth);

        grass.push({
          layer,
          x: tx + jitterX,
          y: ty + jitterY,
          h,
          w: (layer===2 ? 1.55 : (layer===1 ? 1.05 : 0.78)) + Math.random()*(layer===2 ? 1.55 : (layer===1 ? 1.10 : 0.90)),
          p: tuftSeed + i*0.52 + Math.random()*0.85,
          s: (layer===2 ? 0.72 : (layer===1 ? 0.90 : 0.66)) + Math.random()*(layer===2 ? 1.05 : (layer===1 ? 1.05 : 1.00)),
          a,
          bend: (layer===2 ? 1.35 : (layer===1 ? 1.10 : 0.95)) + Math.random()*0.35,
          curl: (Math.random()-0.5) * curlAmp,
          thick: layer===2 ? (0.55 + Math.random()*0.85) : 0,
          tip: 0.75 + Math.random()*0.9
        });
      }
    }

    grassAnim1.length = 0;
    grassAnim2.length = 0;

    const g1 = [];
    const g2 = [];
    for(const b of grass){
      if(b.layer === 1) g1.push(b);
      else if(b.layer === 2) g2.push(b);
    }

    shuffleInPlace(g1);
    shuffleInPlace(g2);

    const gf = (CONFIG.grassAnimFactor ?? 1.0);

    const max1 = clamp(Math.floor(W * 0.55 * gf), 220, 720);
    const max2 = clamp(Math.floor(W * 0.40 * gf), 180, 600);

    grassAnim1.push(...g1.slice(0, max1));
    grassAnim2.push(...g2.slice(0, max2));
  }


  function seedOverlayGrass(){
    overlayGrass.length = 0;

    const gy = H * 0.74;
    const groundH = H - gy;

    // Densidad moderada: solo una capa “de fusión” para que los tallos no se vean pegados.
    const pr = makePRNG(((W|0)*73856093) ^ ((H|0)*19349663) ^ 0xB00B135);
    const n = clamp(Math.floor(W / 11), 60, 120);

    for(let i=0;i<n;i++){
      const x = pr() * W;
      const centerBias = 1 - Math.abs(x - W*0.5) / Math.max(1, W*0.5); // 0..1
      const y = gy + groundH*(0.05 + pr()*0.24) + (1-centerBias)*groundH*0.015;

      const h = groundH*(0.16 + pr()*0.30) * (0.78 + 0.55*centerBias);
      const w = 0.85 + pr()*1.75;

      overlayGrass.push({
        x, y, h, w,
        a: 0.10 + pr()*0.18,
        p: pr()*TAU,
        s: 0.65 + pr()*1.35,
        bend: 0.70 + pr()*1.10
      });
    }
  }

  function drawOverlayGrass(t, fade=1){
    if(!overlayGrass.length) return;

    const wind = windField(t) * 0.55;
    const step = (CONFIG.grassDetail ?? 1) ? 1 : 2;

    ctx.save();
    // Base: oscuro, para que haya “cuerpo”
    ctx.globalAlpha = 0.55 * fade;
    ctx.strokeStyle = 'rgba(8,44,26,0.85)';

    for(let i=0;i<overlayGrass.length;i+=step){
      const b = overlayGrass[i];

      const gWind = CONFIG.reduceMotion ? 0 : (Math.sin(t*0.00062)*0.86 + Math.sin(t*0.00111)*0.32);
      const micro = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00115*b.s + b.p) * 0.12;

      const tilt = (gWind*0.40 + wind + micro) * 0.22 * CONFIG.sway;
      const x1 = b.x + tilt * (10 + b.bend*8);
      const y1 = b.y - b.h;
      const cx = b.x + tilt * (6 + b.bend*5);
      const cy = b.y - b.h*0.55;

      ctx.lineWidth = b.w;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();
    }

    // Highlight: borde claro sutil (para no verse “plano”)
    ctx.globalAlpha = 0.18 * fade;
    ctx.strokeStyle = 'rgba(210,255,230,0.22)';

    for(let i=0;i<overlayGrass.length;i+=step){
      const b = overlayGrass[i];

      const gWind = CONFIG.reduceMotion ? 0 : (Math.sin(t*0.00062)*0.86 + Math.sin(t*0.00111)*0.32);
      const micro = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00115*b.s + b.p) * 0.12;

      const tilt = (gWind*0.40 + wind + micro) * 0.22 * CONFIG.sway;
      const x1 = b.x + tilt * (10 + b.bend*8);
      const y1 = b.y - b.h;
      const cx = b.x + tilt * (6 + b.bend*5);
      const cy = b.y - b.h*0.55;

      ctx.lineWidth = Math.max(0.7, b.w*0.30);
      ctx.beginPath();
      ctx.moveTo(b.x + 0.8, b.y);
      ctx.quadraticCurveTo(cx + 0.55, cy, x1 + 0.25, y1);
      ctx.stroke();
    }

    ctx.restore();
  }

  function seedFireflies(){
    fireflies.length = 0;

    const pr = makePRNG(((W|0)*83492791) ^ ((H|0)*297657976) ^ 0xF1EEF1E);
    const cx = W * 0.5;
    const gy = H * 0.74;
    const groundH = H - gy;

    const n = clamp(Math.floor(W / 70), 10, 22);
    for(let i=0;i<n;i++){
      const u = pr();
      const x = cx + (pr()*2 - 1) * W*0.32 * (0.40 + 0.60*u);
      const y = gy + groundH*(0.06 + pr()*0.34);
      fireflies.push({
        x, y,
        r: 1.15 + pr()*2.35,
        a: 0.10 + pr()*0.20,
        s: 0.60 + pr()*1.40,
        p: pr()*TAU,
        dx: (pr()*2 - 1) * (12 + pr()*22),
        dy: (pr()*2 - 1) * (8 + pr()*18)
      });
    }
  }

  function drawFireflies(t, fade=1){
    if(!fireflies.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    for(const f of fireflies){
      const tw = CONFIG.reduceMotion ? 0.65 : (0.50 + 0.50*Math.sin(t*0.00110*f.s + f.p));
      const a = f.a * (0.35 + 0.65*tw) * fade;
      if(a <= 0.002) continue;

      const x = f.x + (CONFIG.reduceMotion ? 0 : Math.sin(t*0.00035*f.s + f.p) * f.dx);
      const y = f.y + (CONFIG.reduceMotion ? 0 : Math.cos(t*0.00031*f.s + f.p*1.3) * f.dy);

      ctx.globalAlpha = a;
      ctx.shadowColor = 'rgba(255,240,190,0.65)';
      ctx.shadowBlur  = 18 + f.r*6;

      ctx.fillStyle = 'rgba(255,240,190,0.55)';
      ctx.beginPath();
      ctx.arc(x, y, f.r, 0, TAU);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.globalAlpha = a * 0.75;
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.beginPath();
      ctx.arc(x, y, f.r*0.45, 0, TAU);
      ctx.fill();
    }

    ctx.restore();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }

  function rebuildGroundCache(){
    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const gy = H * 0.74;
    const groundH = H - gy;

    const gy0 = gy - 44; // entra suave arriba del suelo (evita “corte”)
    const gg = g.createLinearGradient(0, gy0, 0, H);
    gg.addColorStop(0, 'rgba(8,14,10,0.0)');
    gg.addColorStop(0.10, 'rgba(8,14,10,0.04)');
    gg.addColorStop(0.22, 'rgba(16,44,28,0.28)');
    gg.addColorStop(0.66, 'rgba(8,22,16,0.60)');
    gg.addColorStop(1, 'rgba(0,0,0,0.78)');
    g.fillStyle = gg;
    g.fillRect(0, gy0, W, H - gy0);

    // variación de tono (parches) para evitar banda plana
    for(let i=0;i<8;i++){
      const x = Math.random()*W;
      const y = gy + Math.random()*groundH;
      const r = 120 + Math.random()*260;
      const pg = g.createRadialGradient(x,y, 10, x,y, r);
      pg.addColorStop(0, `rgba(${18+Math.random()*10|0},${70+Math.random()*50|0},${40+Math.random()*30|0},0.10)`);
      pg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = pg;
      g.fillRect(0, gy-20, W, groundH+40);
    }


    for(const b of soil){
      const rg = g.createRadialGradient(b.x, b.y, 8, b.x, b.y, b.r);
      rg.addColorStop(0, `rgba(25,85,48,${b.a})`);
      rg.addColorStop(0.55, `rgba(12,40,24,${b.a*0.55})`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.fillRect(0,0,W,H);
    }

    g.save();
    g.globalAlpha = 0.10;
    g.fillStyle = 'rgba(255,255,255,0.08)';
    const dots = clamp(Math.floor(W * groundH / 1800), 180, 420);
    for(let i=0;i<dots;i++){
      const x = Math.random()*W;
      const y = gy + Math.random()*groundH;
      const r = 0.6 + Math.random()*1.4;
      g.beginPath();
      g.arc(x,y,r,0,TAU);
      g.fill();
    }
    g.restore();

    const drawStaticBlade = (b, front) => {
      const x0 = b.x, y0 = b.y;
      const len = b.h;
      const tilt = b.curl*0.18;

      const x1 = x0 + tilt * (10 + b.bend*5);
      const y1 = y0 - len;

      const cx = x0 + tilt * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      g.strokeStyle = front ? 'rgba(24,105,62,1)' : 'rgba(16,75,44,1)';
      g.lineWidth = b.w * (front ? 1.10 : 1.0);
      g.beginPath();
      g.moveTo(x0, y0);
      g.quadraticCurveTo(cx, cy, x1, y1);
      g.stroke();

      const old = g.globalAlpha;
      g.globalAlpha = old * (front ? 0.22 : 0.16);
      g.strokeStyle = 'rgba(190,255,220,1)';
      g.lineWidth = Math.max(0.7, b.w*0.30);
      g.beginPath();
      g.moveTo(x0 + 0.7, y0);
      g.quadraticCurveTo(cx + 0.5, cy, x1 + 0.3, y1);
      g.stroke();
      g.globalAlpha = old;
    };

    g.save();
    for(const b of grass){
      if(b.layer !== 0) continue;
      g.globalAlpha = 0.18 + b.a*0.90;
      drawStaticBlade(b, false);
    }
    g.restore();

    g.save();
    for(const b of grass){
      if(b.layer !== 1) continue;
      if(b.h > 90) continue;
      g.globalAlpha = 0.16 + b.a*0.80;
      drawStaticBlade(b, true);
    }
    g.restore();

    const fogTop = gy + groundH*0.18;
    const fog = g.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(1, 'rgba(0,0,0,0.34)');
    g.fillStyle = fog;
    g.fillRect(0, fogTop, W, H - fogTop);

    groundCache = off;
  }
  function rebuildFieldCache(){
    // Campo/montañas de fondo (v3):
    // - Montañas lejanas con picos (ridged noise)
    // - Niebla/atmosfera por capas
    // - Colinas medias con rim light + sombras + textura
    // - Pasto y mini-flores como antes
    // Cacheado para rendimiento.
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@d${DPR.toFixed(2)}@q${q}`;
    if(fieldCache && fieldCacheKey === key) return;
    fieldCacheKey = key;

    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    // PRNG estable
    let s = ((W*912367) ^ (H*12347) ^ ((q+1)*918273)) >>> 0;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const topBand = H*0.56;   // inicio del campo (deja cielo arriba)
    const midBand = H*0.70;

    // Base del campo (gradiente)
    const base = g.createLinearGradient(0, topBand, 0, H);
    base.addColorStop(0, 'rgba(7,18,14,0.18)');
    base.addColorStop(0.30, 'rgba(16,56,34,0.44)');
    base.addColorStop(0.70, 'rgba(12,46,30,0.66)');
    base.addColorStop(1, 'rgba(6,22,14,0.86)');
    g.fillStyle = base;
    g.fillRect(0, topBand, W, H-topBand);

    // Helper: contorno con “bulto” central (zona del ramo)
    const ridgeY = H*0.62;

    // Ridged noise: crea picos más “montaña” (no solo ondas suaves)
    const ridged = (x, freq, phase, power=0.35) => {
      const v = Math.abs(Math.sin(x*freq + phase));
      return Math.pow(v, power);
    };

    // Perfil base (con peak central) + ondas + ridged peaks
    const profile = (x, yEdge, yPeak, wav, bump, seedShift, jag=0.0) => {
      const xn = (x / W) - 0.5;
      const peak = yPeak - Math.exp(-(xn*xn)/(bump*bump)) * (yEdge - yPeak);

      const w1 = Math.sin(xn*(6.0+seedShift) + 0.8) * wav;
      const w2 = Math.sin(xn*(13.5+seedShift*1.1) - 0.4) * (wav*0.46);
      const w3 = Math.sin(xn*(22.0+seedShift*1.7) + 1.1) * (wav*0.22);

      // Ridged term for jagged peaks (mountains)
      const r1 = (ridged(xn, 10.0+seedShift*1.2, 0.7+seedShift*0.9) - 0.55) * (wav*2.4) * jag;
      const r2 = (ridged(xn, 19.0+seedShift*1.6, 1.2-seedShift*0.4) - 0.55) * (wav*1.4) * jag;

      return peak + w1 + w2 + w3 + r1 + r2;
    };

    // Montañas lejanas (mejoradas):
    // - Más capas (profundidad real)
    // - Silueta más fina (más puntos)
    // - Nieve sutil en cumbres + textura ligera
    // - Rim light más creíble (más fuerte hacia el lado de la luna)
    const mountains = [
      {yEdge: H*0.590, yPeak: H*0.515, wav: H*0.018, bump:0.70, a:0.16, seed:0.7, jag:0.76, tint:[34,60,82], snow:0.34},
      {yEdge: H*0.612, yPeak: H*0.538, wav: H*0.022, bump:0.62, a:0.20, seed:1.4, jag:0.86, tint:[26,48,66], snow:0.26},
      {yEdge: H*0.642, yPeak: H*0.558, wav: H*0.028, bump:0.56, a:0.24, seed:2.2, jag:0.96, tint:[18,38,52], snow:0.18},
      {yEdge: H*0.673, yPeak: H*0.584, wav: H*0.033, bump:0.50, a:0.28, seed:3.0, jag:1.06, tint:[10,26,36], snow:0.12},
    ];

    for(let k=0;k<mountains.length;k++){
      const M = mountains[k];
      const steps = 140;           // silueta más suave
      const pts = [];

      // Gradient for mountain body (más “atmosfera” arriba)
      const grad = g.createLinearGradient(0, M.yPeak-60, 0, M.yEdge+170);
      grad.addColorStop(0, `rgba(${M.tint[0]},${M.tint[1]},${M.tint[2]},0.78)`);
      grad.addColorStop(0.55, `rgba(${Math.max(0,M.tint[0]-10)},${Math.max(0,M.tint[1]-14)},${Math.max(0,M.tint[2]-18)},0.62)`);
      grad.addColorStop(1, `rgba(0,0,0,0.66)`);

      // Build profile points once (para todo)
      for(let i=0;i<=steps;i++){
        const x = (i/steps)*W;
        const y = profile(x, M.yEdge, M.yPeak, M.wav, M.bump, M.seed, M.jag);
        pts.push({x,y});
      }

      // Mountain body
      g.save();
      g.globalAlpha = M.a;
      g.fillStyle = grad;
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Haze per-layer (profundidad): cuanto más lejos, más neblina fría
      g.save();
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = 0.08 * (1 - k/(mountains.length-1));
      const hz = g.createLinearGradient(0, M.yPeak-40, 0, M.yEdge+160);
      hz.addColorStop(0, 'rgba(140,190,235,0.22)');
      hz.addColorStop(1, 'rgba(0,0,0,0.0)');
      g.fillStyle = hz;
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Crevices: pliegues oscuros (mejor direccionados)
      if(q >= 2){
        g.save();
        g.globalAlpha = 0.075 + 0.02*k;
        g.strokeStyle = 'rgba(0,0,0,0.58)';
        g.lineWidth = 1.0;
        g.lineCap = 'round';

        // Clip dentro de la montaña
        g.beginPath();
        g.moveTo(0, H);
        for(const p of pts) g.lineTo(p.x, p.y);
        g.lineTo(W, H);
        g.closePath();
        g.clip();

        const lines = 22 + k*10;
        for(let n=0;n<lines;n++){
          const x0 = rnd()*W;
          const yTop = profile(x0, M.yEdge, M.yPeak, M.wav, M.bump, M.seed, M.jag);
          const y0 = yTop + rnd()*((M.yEdge+170)-yTop);

          const tilt = (LIGHT.x - 0.5); // hacia la luna (derecha)
          const dx = (0.6 + rnd()*1.0) * W*0.02 * (tilt>=0 ? 1 : -1);
          const dy = (0.12 + rnd()*0.60) * H*0.095;

          g.beginPath();
          g.moveTo(x0, y0);
          g.quadraticCurveTo(x0 + dx*0.5, y0 + dy*0.45, x0 + dx, y0 + dy);
          g.stroke();
        }
        g.restore();
      }

      // Nieve sutil en cumbres (solo arriba) + algo de “grano”
      if(q >= 2 && M.snow > 0){
        g.save();
        // clip montaña
        g.beginPath();
        g.moveTo(0, H);
        for(const p of pts) g.lineTo(p.x, p.y);
        g.lineTo(W, H);
        g.closePath();
        g.clip();

        // region alta (cerca del peak)
        const ySnow = M.yPeak + (M.yEdge - M.yPeak)*0.34;
        g.globalCompositeOperation = 'screen';
        g.globalAlpha = 0.10 + M.snow*0.28;

        const snowGrad = g.createLinearGradient(0, M.yPeak-50, 0, ySnow+130);
        snowGrad.addColorStop(0, 'rgba(255,255,255,0.70)');
        snowGrad.addColorStop(0.35, 'rgba(220,240,255,0.46)');
        snowGrad.addColorStop(1, 'rgba(200,230,255,0.00)');
        g.fillStyle = snowGrad;

        const patches = 16 + Math.floor(10*(1 - k/(mountains.length-1)));
        for(let p=0;p<patches;p++){
          const x = rnd()*W;
          const yR = profile(x, M.yEdge, M.yPeak, M.wav, M.bump, M.seed, M.jag);
          if(yR > ySnow) continue;
          const r = (W*0.008 + rnd()*W*0.020) * (1.10 - 0.18*k);
          const ang = rnd()*0.9;
          g.beginPath();
          g.ellipse(x, yR + rnd()*18, r*1.35, r*0.85, ang, 0, TAU);
          g.fill();
        }

        // grano leve (textura)
        g.globalAlpha = 0.035 + 0.01*(1 - k/(mountains.length-1));
        g.fillStyle = 'rgba(255,255,255,0.55)';
        const grains = 260 + k*120;
        for(let t=0;t<grains;t++){
          const x = rnd()*W;
          const y = M.yPeak + rnd()*((M.yEdge+160)-M.yPeak);
          if(y < ySnow + 70) continue;
          g.beginPath();
          g.arc(x, y, 0.4 + rnd()*0.9, 0, TAU);
          g.fill();
        }

        g.restore();
      }

      // Rim light (luna): más fuerte hacia la derecha
      g.save();
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = 0.10 + 0.05*k;
      const rim = g.createLinearGradient(W*0.10, 0, W, 0);
      rim.addColorStop(0.00, 'rgba(210,240,255,0.00)');
      rim.addColorStop(0.58, 'rgba(210,240,255,0.18)');
      rim.addColorStop(1.00, 'rgba(210,240,255,0.34)');
      g.strokeStyle = rim;
      g.lineWidth = 1.2 + 0.7*(k/(mountains.length-1));
      g.lineJoin = 'round';
      g.lineCap = 'round';
      g.beginPath();
      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        if(i===0) g.moveTo(p.x, p.y);
        else g.lineTo(p.x, p.y);
      }
      g.stroke();
      g.restore();
    }

    // Niebla atmosférica: separa montañas del campo
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.22;
    const fog = g.createLinearGradient(0, topBand-30, 0, topBand+160);
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(0.35, 'rgba(30,60,70,0.18)');
    fog.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = fog;
    g.fillRect(0, topBand-40, W, 220);
    g.restore();

    // Colinas medias (más verdes, detrás del arbusto)
    const layers = [
      {yEdge: H*0.66, yPeak: ridgeY-20, wav: H*0.016, bump:0.52, a:0.20, sat:0.62, seed:0.8},
      {yEdge: H*0.69, yPeak: ridgeY-16, wav: H*0.020, bump:0.50, a:0.25, sat:0.70, seed:1.4},
      {yEdge: H*0.72, yPeak: ridgeY-12, wav: H*0.026, bump:0.46, a:0.31, sat:0.82, seed:2.0},
      {yEdge: H*0.75, yPeak: ridgeY- 6, wav: H*0.034, bump:0.42, a:0.37, sat:0.94, seed:2.7},
      {yEdge: H*0.79, yPeak: ridgeY+ 4, wav: H*0.046, bump:0.38, a:0.43, sat:1.06, seed:3.3},
    ];

    for(let k=0;k<layers.length;k++){
      const L = layers[k];
      const col = g.createLinearGradient(0, topBand, 0, H);
      col.addColorStop(0, `rgba(30,110,70,${0.07*L.sat})`);
      col.addColorStop(0.55, `rgba(16,70,44,${0.24*L.sat})`);
      col.addColorStop(1, `rgba(4,18,12,${0.46*L.sat})`);

      g.save();
      g.globalAlpha = L.a;
      g.fillStyle = col;

      g.beginPath();
      g.moveTo(0, H);
      const steps = 72;
      const pts = [];
      for(let i=0;i<=steps;i++){
        const x = (i/steps)*W;
        const y = profile(x, L.yEdge, L.yPeak, L.wav, L.bump, L.seed, 0.0);
        pts.push({x,y});
        g.lineTo(x, y);
      }
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Sombras internas
      g.save();
      g.globalCompositeOperation = 'multiply';
      g.globalAlpha = 0.12 + 0.06*(k/layers.length);
      const shade = g.createLinearGradient(0, L.yPeak-20, 0, L.yEdge+90);
      shade.addColorStop(0, 'rgba(0,0,0,0)');
      shade.addColorStop(1, 'rgba(0,0,0,0.45)');
      g.fillStyle = shade;
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Rim light
      g.save();
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = 0.07 + 0.05*(k/layers.length);
      g.strokeStyle = 'rgba(230,255,245,0.22)';
      g.lineWidth = 1.1 + 0.6*(k/layers.length);
      g.lineJoin = 'round';
      g.lineCap = 'round';
      g.beginPath();
      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        if(i===0) g.moveTo(p.x, p.y);
        else g.lineTo(p.x, p.y);
      }
      g.stroke();
      g.restore();

      // Textura: motas + micro “contours”
      const specks = (q>=3?260: q>=2?180:120) * (0.55 + 0.55*(k/layers.length));
      g.save();
      g.globalAlpha = 0.05 + 0.04*(k/layers.length);
      g.fillStyle = 'rgba(255,255,255,0.30)';
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.clip();
      for(let n=0;n<specks;n++){
        const x = rnd()*W;
        const yTop = profile(x, L.yEdge, L.yPeak, L.wav, L.bump, L.seed, 0.0);
        const y = yTop + rnd()*(H - yTop);
        const r = 0.6 + rnd()*1.6;
        g.beginPath();
        g.arc(x, y, r, 0, TAU);
        g.fill();
      }
      if(q>=3){
        g.globalAlpha *= 0.80;
        g.strokeStyle = 'rgba(0,0,0,0.12)';
        g.lineWidth = 1.0;
        for(let n=0;n<22;n++){
          const yOff = (8 + rnd()*38) * (0.55 + 0.55*(k/layers.length));
          g.beginPath();
          for(let i=0;i<pts.length;i++){
            const p = pts[i];
            const yy = p.y + yOff + Math.sin(i*0.35 + n*0.7)*2.0;
            if(i===0) g.moveTo(p.x, yy);
            else g.lineTo(p.x, yy);
          }
          g.stroke();
        }
      }
      g.restore();

      if(k <= 1){
        g.save();
        g.globalAlpha = 0.10;
        const fog2 = g.createLinearGradient(0, topBand, 0, midBand);
        fog2.addColorStop(0, 'rgba(0,0,0,0)');
        fog2.addColorStop(1, 'rgba(0,0,0,0.16)');
        g.fillStyle = fog2;
        g.fillRect(0, topBand, W, midBand-topBand);
        g.restore();
      }
    }

    // Pasto “en perspectiva”
    const grassCount = q>=3 ? 1300 : q>=2 ? 950 : 700;
    g.save();
    g.globalCompositeOperation = 'screen';
    for(let i=0;i<grassCount;i++){
      const t = rnd();
      const y = topBand + (H-topBand)*(t*t);
      const x = rnd()*W;

      const depth = clamp((y-topBand)/(H-topBand), 0, 1);
      const len = (2.0 + rnd()*7.8) * (0.18 + 1.35*depth);
      const tilt = (rnd()*0.8 - 0.4) + (depth-0.5)*0.22;

      const a = 0.014 + 0.050*depth;
      const shade = 0.55 + 0.45*rnd();
      const rr = Math.round(18 + 36*shade);
      const gg2= Math.round(72 + 120*shade);
      const bb = Math.round(38 + 64*shade);

      g.globalAlpha = a;
      g.strokeStyle = `rgba(${rr},${gg2},${bb},0.9)`;
      g.lineWidth = 0.9 + 1.1*depth;
      g.lineCap = 'round';

      g.beginPath();
      g.moveTo(x, y);
      g.lineTo(x + Math.sin(tilt)*len, y - Math.cos(tilt)*len);
      g.stroke();
    }
    g.restore();

    // Florecitas pequeñas
    const flowers = q>=3 ? 440 : q>=2 ? 320 : 240;
    g.save();
    for(let i=0;i<flowers;i++){
      const t = rnd();
      const y = topBand + (H-topBand)*(t*t);
      const x = rnd()*W;

      const depth = clamp((y-topBand)/(H-topBand), 0, 1);
      const size = (0.6 + rnd()*1.7) * (0.22 + 1.05*depth);
      const alpha = (0.06 + 0.10*(1-depth)) * (0.65 + 0.55*rnd());

      const pick = rnd();
      let c = 'rgba(255,220,235,';        // rosa suave
      if(pick < 0.33) c = 'rgba(230,235,255,';      // lavanda frío
      else if(pick < 0.66) c = 'rgba(255,240,215,'; // crema

      g.globalAlpha = alpha;
      g.fillStyle = c + (0.42 + 0.28*rnd()) + ')';
      const r = 1.8*size;
      for(let p=0;p<4;p++){
        const ang = p*(TAU/4) + rnd()*0.22;
        g.beginPath();
        g.ellipse(x + Math.cos(ang)*r, y + Math.sin(ang)*r*0.72, 1.05*size, 0.78*size, ang, 0, TAU);
        g.fill();
      }
      g.globalAlpha = alpha*0.9;
      g.fillStyle = 'rgba(255,215,140,0.40)';
      g.beginPath();
      g.arc(x, y, 0.90*size, 0, TAU);
      g.fill();
    }
    g.restore();

    // Viñeta para integrar con el cielo
    const blend = g.createLinearGradient(0, topBand-40, 0, topBand+120);
    blend.addColorStop(0, 'rgba(0,0,0,0)');
    blend.addColorStop(1, 'rgba(0,0,0,0.18)');
    g.fillStyle = blend;
    g.fillRect(0, topBand-40, W, 160);

    fieldCache = off;
  }

  function rebuildFieldBandCache(){
    // Campo/montañas dibujados SIN cortes: aplicamos una máscara vertical suave en un canvas auxiliar
    rebuildFieldCache();
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@d${DPR.toFixed(2)}@q${q}`;
    if(fieldBandCache && fieldBandCacheKey === key) return;
    fieldBandCacheKey = key;

    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);
    g.clearRect(0,0,W,H);

    if(fieldCache){
      g.drawImage(fieldCache, 0, 0, fieldCache.width / DPR, fieldCache.height / DPR);
    }

    // Máscara: entra suave, se mantiene, sale suave (elimina el “corte”)
    const top = H*0.46;
    const inY = H*0.52;
    const outY= H*0.74;  // cerca del inicio del pasto
    const bot = H*0.82;

    g.globalCompositeOperation = 'destination-in';
    const mask = g.createLinearGradient(0, top, 0, bot);
    const aIn  = (inY - top) / (bot - top);
    const aOut = (outY - top) / (bot - top);
    mask.addColorStop(0.0, 'rgba(0,0,0,0)');
    mask.addColorStop(Math.max(0.01, Math.min(0.35, aIn)),  'rgba(0,0,0,1)');
    mask.addColorStop(Math.max(0.55, Math.min(0.90, aOut)), 'rgba(0,0,0,1)');
    mask.addColorStop(1.0, 'rgba(0,0,0,0)');

    g.fillStyle = mask;
    g.fillRect(0, top-80, W, (bot-top)+160);

    fieldBandCache = off;
  }





  function drawGrass(t){
    if(groundCache){
      ctx.drawImage(groundCache, 0, 0, groundCache.width / DPR, groundCache.height / DPR);
    }
    const gy = H * 0.74;
    const groundH = H - gy;

    const wind = windField(t) * 0.75;

    const detail = (CONFIG.grassDetail ?? 1);
    const step = detail ? 1 : 2;

    const drawBlade = (b, front) => {
      const xN = (b.x / W) - 0.5;
      const gWind = CONFIG.reduceMotion ? 0 : (Math.sin(t*0.00062)*0.92 + Math.sin(t*0.00114)*0.32);
      const gust  = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00035 + xN*2.8) * 0.22;
      const micro = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00120*b.s + b.p) * 0.08;
      const sway  = (gWind*0.55 + gust + micro) * 0.22 * CONFIG.sway;
      const sway2 = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00135*b.s + b.p*0.7) * 0.08;

      const x0 = b.x;
      const y0 = b.y;
      const len = b.h;

      const tilt = (sway + wind + b.curl*0.22);
      const x1 = x0 + tilt * (9 + b.bend*6);
      const y1 = y0 - len;

      const cx = x0 + (tilt + sway2) * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      if(front){
        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.18;
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        ctx.beginPath();
        ctx.ellipse(x0, y0+1.2, 3.2 + b.w, 1.2 + b.w*0.34, 0, 0, TAU);
        ctx.fill();
        ctx.globalAlpha = old;
      }

      if(detail && b.layer === 2){
        const w0 = b.w * (1.00 + b.thick);
        const w1 = Math.max(0.8, w0 * 0.16);

        const t0x = x0, t0y = y0;
        const t1x = cx, t1y = cy;
        const t2x = x1, t2y = y1;

        const dx = t2x - t0x;
        const dy = t2y - t0y;
        const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
        const px = -dy * inv;
        const py =  dx * inv;

        ctx.save();
        ctx.fillStyle = front ? 'rgba(35,125,75,0.72)' : 'rgba(18,88,52,0.72)';

        ctx.beginPath();
        ctx.moveTo(t0x + px*w0, t0y + py*w0);
        ctx.quadraticCurveTo(t1x + px*(w0*0.60), t1y + py*(w0*0.60), t2x + px*w1, t2y + py*w1);
        ctx.lineTo(t2x - px*w1, t2y - py*w1);
        ctx.quadraticCurveTo(t1x - px*(w0*0.52), t1y - py*(w0*0.52), t0x - px*w0, t0y - py*w0);
        ctx.closePath();
        ctx.fill();

        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.24;
        ctx.strokeStyle = 'rgba(215,255,235,0.32)';
        ctx.lineWidth = Math.max(0.8, b.w*0.34);
        ctx.beginPath();
        ctx.moveTo(x0 + px*0.4, y0 + py*0.4);
        ctx.quadraticCurveTo(cx + px*0.2, cy + py*0.2, x1 + px*0.10, y1 + py*0.10);
        ctx.stroke();
        ctx.globalAlpha = old;

        ctx.restore();
      }

      ctx.strokeStyle = front ? 'rgba(22,98,58,1)' : 'rgba(18,72,42,1)';
      ctx.lineWidth = b.w * (front ? 1.12 : 1.0);
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();

      const old = ctx.globalAlpha;
      ctx.globalAlpha = old * (front ? 0.22 : 0.16);
      ctx.strokeStyle = 'rgba(190,255,220,1)';
      ctx.lineWidth = Math.max(0.7, b.w*0.30);
      ctx.beginPath();
      ctx.moveTo(x0 + 0.8, y0);
      ctx.quadraticCurveTo(cx + 0.55, cy, x1 + 0.35, y1);
      ctx.stroke();
      ctx.globalAlpha = old;
    };

    ctx.save();
    for(let i=0;i<grassAnim1.length;i+=step){
      const b = grassAnim1[i];
      ctx.globalAlpha = 0.16 + b.a*0.92;
      drawBlade(b, false);
    }
    ctx.restore();

    ctx.save();
    for(let i=0;i<grassAnim2.length;i+=step){
      const b = grassAnim2[i];
      ctx.globalAlpha = 0.22 + b.a*0.98;
      drawBlade(b, true);
    }
    ctx.restore();


    // Bruma del horizonte: ayuda a que el césped no se vea "pegado" y disimula el corte con los tallos
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const hzTop = gy - 90;
    const hzBot = gy + 40;
    const hz = ctx.createLinearGradient(0, hzTop, 0, hzBot);
    hz.addColorStop(0, 'rgba(120,150,220,0)');
    hz.addColorStop(0.35, 'rgba(120,150,220,0.07)');
    hz.addColorStop(0.70, 'rgba(90,120,200,0.04)');
    hz.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = hz;
    ctx.fillRect(0, hzTop, W, hzBot - hzTop);
    ctx.restore();

    // Sombra suave en la unión: elimina el “corte” y pega el ramo al suelo
    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const seamTop = gy - 18;
    const seamBot = gy + 110;
    const seam = ctx.createLinearGradient(0, seamTop, 0, seamBot);
    seam.addColorStop(0, 'rgba(0,0,0,0)');
    seam.addColorStop(0.45, 'rgba(0,0,0,0.16)');
    seam.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = seam;
    ctx.fillRect(0, seamTop, W, seamBot - seamTop);
    ctx.restore();

    ctx.save();
    const thatchTop = gy + groundH*0.74;
    const tg = ctx.createLinearGradient(0, thatchTop, 0, H);
    tg.addColorStop(0, 'rgba(0,0,0,0)');
    tg.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = tg;
    ctx.fillRect(0, thatchTop, W, H - thatchTop);
    ctx.restore();
    if(detail && !(CONFIG.reduceMotion && !CONFIG.forceFlowerMotion)){
      ctx.save();
      ctx.globalAlpha = 0.05;
      ctx.fillStyle = 'rgba(220,255,240,0.18)';
      const drops = 16;
      for(let i=0;i<drops;i++){
        const x = W*(0.18 + Math.random()*0.64);
        const y = (gy + groundH*0.25) + Math.random()*(groundH*0.70);
        ctx.beginPath();
        ctx.arc(x,y, 0.9 + Math.random()*1.2, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  // ===== Texto hecho con estrellas =====
  function buildStarText(){
    textStars.length = 0;

    const sMin = Math.min(W, H);
    let fontSize = clamp(sMin * 0.09, 26, 58);

    const tc = document.createElement('canvas');
    tc.width = Math.floor(W);
    tc.height = Math.floor(H);
    const g = tc.getContext('2d', {alpha:true});

    const x = tc.width * 0.5;
    const y = tc.height * 0.28;

    g.clearRect(0,0,tc.width,tc.height);
    g.textAlign = 'center';
    g.textBaseline = 'middle';
    g.font = `700 ${Math.round(fontSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;

    const maxW = tc.width * 0.92;
    const mt = g.measureText(CONFIG.starText);
    if(mt.width > maxW){
      fontSize = clamp(fontSize * (maxW / mt.width), 18, fontSize);
      g.font = `700 ${Math.round(fontSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    }

    g.fillStyle = 'rgba(255,255,255,1)';
    g.fillText(CONFIG.starText, x, y);

    const img = g.getImageData(0,0,tc.width,tc.height).data;

    const step = clamp(Math.round(fontSize / 7.2), 3, 7);
    const maxPts = clamp(Math.floor((W*H)/1300), 700, 1700);

    const pr = makePRNG((W*73856093) ^ (H*19349663) ^ 0xC0FFEE);

    const minX = Math.max(0, Math.floor(x - tc.width*0.45));
    const maxX = Math.min(tc.width-1, Math.floor(x + tc.width*0.45));
    const minY = Math.max(0, Math.floor(y - fontSize*1.2));
    const maxY = Math.min(tc.height-1, Math.floor(y + fontSize*1.0));

    const candidates = [];
    for(let yy=minY; yy<=maxY; yy+=step){
      for(let xx=minX; xx<=maxX; xx+=step){
        const idx = (yy*tc.width + xx)*4 + 3;
        const a = img[idx];
        if(a > 20){
          candidates.push({x: xx/tc.width, y: yy/tc.height, a: a/255});
        }
      }
    }

    shuffleInPlace(candidates);
    const chosen = candidates.slice(0, maxPts);

    for(const p of chosen){
      const sizeJ = pr();
      const r = (0.65 + sizeJ*1.25) * (fontSize/46);
      const alpha = (0.10 + p.a*0.35) * CONFIG.starTextStrength;

      const temp = pr();
      let hue = 0;
      if(temp < 0.20) hue = 205 + pr()*30;
      else if(temp < 0.28) hue = 35 + pr()*16;

      textStars.push({
        x: p.x, y: p.y,
        r,
        a: alpha,
        p: pr()*TAU,
        s: 0.55 + pr()*1.05,
        hue,
        flare: (pr() < 0.12) ? (0.15 + pr()*0.35) : 0
      });
    }


    // Corazón hecho con estrellas (en lugar de "<3")
    // Se coloca ARRIBA del texto para que no compita con la lectura.
    {
      const mtW = g.measureText(CONFIG.starText).width;
      const heartScale = fontSize * 0.42;

      // centrado sobre el mensaje
      const hx = clamp(x, heartScale*1.15, tc.width - heartScale*1.15);
      const hy = clamp(y - fontSize*0.95, heartScale*1.20, tc.height*0.55);

      const pushStar = (px, py, sizeMul, aMul)=>{
        const r = (0.62 + pr()*1.15) * (fontSize/46) * sizeMul;
        const alpha = (0.12 + pr()*0.22) * CONFIG.starTextStrength * aMul;
        const hue = 335 + pr()*22; // rosa cálido
        textStars.push({
          x: px, y: py,
          r,
          a: alpha,
          p: pr()*TAU,
          s: 0.70 + pr()*1.10,
          hue,
          flare: (pr() < 0.18) ? (0.18 + pr()*0.40) : 0
        });
      };

      // curva paramétrica de corazón
      const N = 180;
      const curve = [];
      for(let i=0;i<N;i++){
        const tt = (i/N)*TAU;
        const sx = 16*Math.pow(Math.sin(tt), 3);
        const sy = 13*Math.cos(tt) - 5*Math.cos(2*tt) - 2*Math.cos(3*tt) - Math.cos(4*tt);
        curve.push({ x: sx/18, y: -sy/18 });
      }

      // contorno
      for(let i=0;i<curve.length;i+=2){
        const p = curve[i];
        const jx = (pr()*2-1) * 0.025;
        const jy = (pr()*2-1) * 0.025;
        const nx = (hx + (p.x + jx)*heartScale) / tc.width;
        const ny = (hy + (p.y + jy)*heartScale) / tc.height;
        pushStar(nx, ny, 0.95, 1.05);
      }

      // relleno (muestra puntos “hacia adentro” desde la curva)
      const fillN = 110;
      for(let i=0;i<fillN;i++){
        const p = curve[(pr()*curve.length)|0];
        const f = Math.pow(pr(), 0.65); // concentra hacia el interior
        const jx = (pr()*2-1) * 0.020;
        const jy = (pr()*2-1) * 0.020;
        const nx = (hx + (p.x*f + jx)*heartScale) / tc.width;
        const ny = (hy + (p.y*f + jy)*heartScale) / tc.height;
        pushStar(nx, ny, 0.78, 0.88);
      }
    }

    // halo disperso alrededor del texto: suaviza bordes y lo integra al cielo
    const haloBudget = Math.min(28, Math.max(10, Math.floor(textStars.length * 0.20)));
    for(let i=0;i<haloBudget;i++){
      const b = textStars[(Math.random()*textStars.length)|0];
      const hx = clamp(b.x + (Math.random()*2-1)*0.032, 0.02, 0.98);
      const hy = clamp(b.y + (Math.random()*2-1)*0.020, 0.02, 0.60);

      textStars.push({
        x: hx, y: hy,
        r: b.r * (0.55 + Math.random()*0.25),
        a: b.a * (0.22 + Math.random()*0.18),
        tw: b.tw * (0.65 + Math.random()*0.25),
        p: Math.random()*TAU*3
      });
    }

  }

  function drawStarText(t){
    if(!textStars.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    const gx = W*0.5, gy = H*0.28;
    const fontHint = clamp(Math.min(W,H)*0.09, 26, 58);

    // Backdrop oscuro suave para que el mensaje se lea sobre nubes/estrellas
    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    ctx.globalAlpha = 0.28;
    const bg = ctx.createRadialGradient(gx, gy, 0, gx, gy, fontHint*3.2);
    bg.addColorStop(0.0, 'rgba(0,0,0,0.70)');
    bg.addColorStop(0.55,'rgba(0,0,0,0.20)');
    bg.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
    const glow = ctx.createRadialGradient(gx, gy, 10, gx, gy, fontHint*7.5);
    glow.addColorStop(0, 'rgba(210,230,255,0.16)');
    glow.addColorStop(1, 'rgba(210,230,255,0)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = glow;
    ctx.fillRect(0,0,W,H);

    for(const st of textStars){
      const tw = CONFIG.reduceMotion ? 1 : (0.78 + 0.22*Math.sin(t*0.0012*st.s + st.p));
      const alpha = clamp(st.a * (0.95 + 0.85*tw), 0, 1);

      const x = st.x*W;
      const y = st.y*H;

      ctx.globalAlpha = alpha;
      ctx.shadowColor = 'rgba(255,255,255,0.55)';
      ctx.shadowBlur = 9 + st.r*6;

      // Sombra/contorno sutil para contraste (sobre nubes claras)
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = alpha * 0.18;
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.beginPath();
      ctx.arc(x, y, st.r*1.55, 0, TAU);
      ctx.fill();
      ctx.restore();



      ctx.fillStyle = st.hue ? `hsla(${st.hue}, 75%, 92%, 1)` : 'rgba(255,255,255,1)';
      ctx.beginPath();
      ctx.arc(x, y, st.r, 0, TAU);
      ctx.fill();

      if(st.flare){
        ctx.save();
        ctx.shadowBlur = 0;
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = alpha * 0.55 * st.flare;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        const k = 3.0 + st.r*2.0;
        ctx.beginPath();
        ctx.moveTo(x-k, y); ctx.lineTo(x+k, y);
        ctx.moveTo(x, y-k); ctx.lineTo(x, y+k);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }

  // ===== Cielo (cache) =====


  // --- Rendimiento: sprites y layer cacheado (evita sombras/gradientes por estrella cada frame) ---
  let starSprite = null;
  let starSpriteKey = '';
  function rebuildStarSprite(){
    const key = `d${Math.round(DPR*100)}`;
    if(starSprite && starSpriteKey === key) return;
    starSpriteKey = key;

    const size = 40; // px “lógicos”
    const off = document.createElement('canvas');
    off.width = Math.floor(size * DPR);
    off.height = Math.floor(size * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const cx = size/2, cy = size/2;
    const R = size*0.44;

    const rg = g.createRadialGradient(cx, cy, 0, cx, cy, R);
    rg.addColorStop(0.0, 'rgba(255,255,255,0.95)');
    rg.addColorStop(0.18,'rgba(255,255,255,0.38)');
    rg.addColorStop(1.0, 'rgba(255,255,255,0.00)');
    g.fillStyle = rg;
    g.fillRect(0,0,size,size);

    g.fillStyle = 'rgba(255,255,255,1)';
    g.beginPath();
    g.arc(cx, cy, size*0.075, 0, TAU);
    g.fill();

    g.globalAlpha = 0.40;
    g.strokeStyle = 'rgba(255,255,255,0.90)';
    g.lineWidth = 1;
    const k = size*0.18;
    g.beginPath();
    g.moveTo(cx-k, cy); g.lineTo(cx+k, cy);
    g.moveTo(cx, cy-k); g.lineTo(cx, cy+k);
    g.stroke();
    g.globalAlpha = 1;

    starSprite = off;
  }

  function drawStarSprite(g, x, y, r, hue, flare, alpha){
    if(!starSprite) rebuildStarSprite();
    const base = 7.5;
    const fMul = flare ? (1.12 + flare*0.35) : 1.0;
    const sz = Math.max(2, r * base * fMul);

    g.globalAlpha = alpha;
    g.drawImage(starSprite, x - sz/2, y - sz/2, sz, sz);

    if(hue){
      g.save();
      g.globalAlpha = alpha * 0.65;
      g.fillStyle = `hsla(${hue}, 78%, 92%, 1)`;
      g.beginPath();
      g.arc(x, y, Math.max(0.9, r*0.55), 0, TAU);
      g.fill();
      g.restore();
    }
  }

  // Caches: texto del cielo + estrellas (actualizados a 30fps máximo)
  let skyDynCache = null, skyDynCtx = null, skyDynKey = '';
  let skyDynLast = 0;
  let textBackdropCache = null, textBackdropKey = '';

  function rebuildTextBackdropCache(){
    const key = `${W}x${H}@d${DPR.toFixed(2)}@t${CONFIG.starText}`;
    if(textBackdropCache && textBackdropKey === key) return;
    textBackdropKey = key;

    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const gx = W*0.5, gy = H*0.28;
    const fontHint = clamp(Math.min(W,H)*0.09, 26, 58);

    const bg = g.createRadialGradient(gx, gy, 0, gx, gy, fontHint*3.2);
    bg.addColorStop(0.0, 'rgba(0,0,0,0.34)');
    bg.addColorStop(0.55,'rgba(0,0,0,0.12)');
    bg.addColorStop(1.0, 'rgba(0,0,0,0)');
    g.fillStyle = bg;
    g.fillRect(0,0,W,H);

    const glow = g.createRadialGradient(gx, gy, 10, gx, gy, fontHint*7.5);
    glow.addColorStop(0, 'rgba(210,230,255,0.16)');
    glow.addColorStop(1, 'rgba(210,230,255,0)');
    g.fillStyle = glow;
    g.fillRect(0,0,W,H);

    textBackdropCache = off;
  }

  function rebuildSkyDynCache(){
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@d${DPR.toFixed(2)}@q${q}`;
    if(skyDynCache && skyDynKey === key) return;
    skyDynKey = key;

    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    skyDynCache = off;
    skyDynCtx = g;
    skyDynLast = 0;

    rebuildStarSprite();
    rebuildTextBackdropCache();
  }

  function renderSkyDynamic(t){
    if(!skyDynCtx || !skyDynCache) return;

    const fps = clamp(CONFIG.maxFPS || 60, 24, 60);
    const minStep = 1000 / fps;
    if(skyDynLast && (t - skyDynLast) < minStep) return;
    skyDynLast = t;

    const g = skyDynCtx;
    g.setTransform(DPR,0,0,DPR,0,0);
    g.clearRect(0,0,W,H);

    // wisps dinámicos, pero en cache (30fps)
    g.save();
    g.globalCompositeOperation = 'screen';
    const tt = t*0.000016;
    g.globalAlpha = 0.032;
    const baseAlphaWisp = g.globalAlpha;
    for(let i=0;i<3;i++){
      const x = (W*(0.18 + i*0.32) + (Math.sin(tt*2.6 + i)*W*0.08)) % (W+160) - 80;
      const y = H*(0.05 + 0.10*Math.abs(Math.sin(tt*1.9 + i*1.4)));
      const w = Math.min(W,H)*(0.12 + 0.03*Math.sin(tt*2.0 + i));
      const h = w*0.42;
      const fade = clamp(1 - (y - H*0.16)/(H*0.10), 0, 1);
      if(fade <= 0.01) continue;
      g.globalAlpha = baseAlphaWisp * fade;
      const grd = g.createRadialGradient(x, y, w*0.08, x, y, w*0.72);
      grd.addColorStop(0.0, 'rgba(230,245,255,0.14)');
      grd.addColorStop(0.6, 'rgba(150,205,255,0.06)');
      grd.addColorStop(1.0, 'rgba(60,95,150,0.00)');
      g.fillStyle = grd;
      g.beginPath();
      g.ellipse(x, y, w, h, 0, 0, TAU);
      g.fill();
    }
    g.restore();

    rebuildTextBackdropCache();

    if(textBackdropCache){
      g.drawImage(textBackdropCache, 0, 0, textBackdropCache.width / DPR, textBackdropCache.height / DPR);
    }

    // Texto hecho con estrellas (sprite, sin shadowBlur por partícula)
    if(textStars.length){
      g.save();
      g.globalCompositeOperation = 'screen';

      for(const st of textStars){
        const tw = CONFIG.reduceMotion ? 1 : (0.78 + 0.22*Math.sin(t*0.0012*st.s + st.p));
        const alpha = clamp(st.a * (0.95 + 0.85*tw), 0, 1);

        const x = st.x*W;
        const y = st.y*H;

        drawStarSprite(g, x, y, st.r, st.hue, st.flare, alpha);
      }

      g.restore();
    }

    // Estrellas + constelaciones
    g.save();
    g.globalCompositeOperation = 'screen';
    g.lineCap = 'round';
    g.lineJoin = 'round';
    g.strokeStyle = 'rgba(200,220,255,1)';

    for(const L of starLinks){
      const a = stars[L.i];
      const b = stars[L.j];
      starPos(a, t, _spA);
      starPos(b, t, _spB);
      if(_spA.y > H*0.62 || _spB.y > H*0.62) continue;
      g.globalAlpha = L.a;
      g.lineWidth = 1;
      g.beginPath();
      g.moveTo(_spA.x, _spA.y);
      g.lineTo(_spB.x, _spB.y);
      g.stroke();
    }

    for(const st of stars){
      const tw = CONFIG.reduceMotion ? 1 : (0.72 + 0.28*Math.sin(t*0.0011*st.s + st.p)) * (0.85 + st.tw*0.30);
      const alpha = st.a * (0.72 + 0.58*tw) * CONFIG.twinkle;

      starPos(st, t, _spA);
      const x = _spA.x;
      const y = _spA.y;

      drawStarSprite(g, x, y, st.r, st.hue, st.flare, alpha);
    }

    g.restore();

    g.globalCompositeOperation = 'source-over';
    g.globalAlpha = 1;
  }


  const _spA = {x:0,y:0};
  const _spB = {x:0,y:0};

  function starPos(st, t, out){
    const z = (st.z ?? 0.55);
    if(CONFIG.reduceMotion){
      out.x = st.x * W;
      out.y = st.y * H;
      return out;
    }
    const px = (Math.sin(t*0.00009 + st.p) * 5 + Math.sin(t*0.00023 + st.p*0.7) * 2) * z;
    const py = (Math.cos(t*0.00008 + st.p*1.1) * 4 + Math.sin(t*0.00019 + st.p*0.5) * 1.5) * z;
    out.x = st.x * W + px;
    out.y = st.y * H + py;
    return out;
  }

  function drawConstellations(t){
    if(!starLinks.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = 'rgba(200,220,255,1)';

    for(const L of starLinks){
      const a = stars[L.i];
      const b = stars[L.j];
      starPos(a, t, _spA);
      starPos(b, t, _spB);

      // Mantén las líneas en la parte alta del cielo (para no ensuciar el ramo)
      if(_spA.y > H*0.62 || _spB.y > H*0.62) continue;

      ctx.globalAlpha = L.a;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(_spA.x, _spA.y);
      ctx.lineTo(_spB.x, _spB.y);
      ctx.stroke();
    }

    ctx.restore();
  }



  // ===== Constelación específica: Capricornio (estilizada, en el fondo) =====
  function drawCapricornConstellationToCache(g){
    // Coordenadas normalizadas (0..1) para que escale con el canvas.
    // No es un atlas astronómico: es una silueta bonita y reconocible.
    const P = [
      {x:0.12, y:0.23, m:1.25},
      {x:0.21, y:0.17, m:1.10},
      {x:0.31, y:0.20, m:1.20},
      {x:0.39, y:0.26, m:1.05},
      {x:0.31, y:0.31, m:1.00},
      {x:0.23, y:0.30, m:0.95},
      {x:0.15, y:0.31, m:0.90},
      {x:0.18, y:0.37, m:0.85}
    ];

    const E = [
      [0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0],
      [5,7],[7,4]
    ];

    const XOFF = -0.08; // desplaza a la izquierda (evita chocar con la luna)
    const YOFF = -0.12; // sube la constelación (por encima del mensaje)

    const toX = (p)=>clamp((1 - p.x) + XOFF, 0.02, 0.98)*W;
    const toY = (p)=>clamp(p.y + YOFF, 0.02, 0.60)*H;

    g.save();
    g.globalCompositeOperation = 'screen';
    g.lineCap = 'round';
    g.lineJoin = 'round';

    // Bruma suave detrás para integrarlo (muy sutil)
    const cx = W*0.66, cy = H*0.14;
    const haze = g.createRadialGradient(cx, cy, 10, cx, cy, Math.min(W,H)*0.18);
    haze.addColorStop(0, 'rgba(200,220,255,0.06)');
    haze.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = haze;
    g.fillRect(0,0,W,H);

    // Líneas
    g.strokeStyle = 'rgba(200,220,255,1)';
    g.lineWidth = 1.15;
    g.globalAlpha = 0.14;

    for(const [a,b] of E){
      const A = P[a], B = P[b];
      const ax = toX(A), ay = toY(A);
      const bx = toX(B), by = toY(B);

      // evita ensuciar zona baja
      if(ay > H*0.62 || by > H*0.62) continue;

      g.beginPath();
      g.moveTo(ax, ay);
      g.lineTo(bx, by);
      g.stroke();
    }

    // Estrellas (puntos + glow)
    for(const p of P){
      const x = toX(p), y = toY(p);
      if(y > H*0.62) continue;

      const r = 1.15 + p.m*0.95;
      const glowR = 14 + p.m*12;

      g.globalAlpha = 0.20 + p.m*0.06;
      const rg = g.createRadialGradient(x,y, 0, x,y, glowR);
      rg.addColorStop(0, 'rgba(255,255,255,0.24)');
      rg.addColorStop(0.35, 'rgba(210,230,255,0.10)');
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.beginPath();
      g.arc(x,y, glowR, 0, TAU);
      g.fill();

      g.globalAlpha = 0.55;
      g.shadowColor = 'rgba(255,255,255,0.35)';
      g.shadowBlur = 10 + p.m*6;
      g.fillStyle = 'rgba(255,255,255,1)';
      g.beginPath();
      g.arc(x,y, r, 0, TAU);
      g.fill();
      g.shadowBlur = 0;
    }

    g.restore();
  }

  // ===== Constelaciones: Capricornio + Leo (mezcladas) =====
  // Idea: no solo “poner otra”, sino que se vean como una sola composición.
  function drawLeoCapricornBlendToCache(g){
    // Paleta cálida: mezcla naranja + rosa (screen) para que se sienta romántico.
    const COL_A = {r:255, g:150, b: 90};   // naranja suave
    const COL_B = {r:255, g: 95, b:190};   // rosa
    const warm = (a, t=0.5)=>{
      const r = COL_A.r*(1-t) + COL_B.r*t;
      const gg = COL_A.g*(1-t) + COL_B.g*t;
      const b = COL_A.b*(1-t) + COL_B.b*t;
      return `rgba(${r|0},${gg|0},${b|0},${a})`;
    };

    // Helper: dibuja una constelación estilizada y regresa coordenadas en pantalla.
    function drawConst(P, E, xoff, yoff, hazeX, hazeY){
      const toX = (p)=>clamp((1 - p.x) + xoff, 0.02, 0.98)*W;
      const toY = (p)=>clamp(p.y + yoff, 0.02, 0.62)*H;
      const pts = P.map(p=>({x:toX(p), y:toY(p), m:(p.m||1)}));

      g.save();
      g.globalCompositeOperation = 'screen';
      g.lineCap = 'round';
      g.lineJoin = 'round';

      // Bruma suave para integrarlo en el cielo
      const cx = hazeX, cy = hazeY;
      const haze = g.createRadialGradient(cx, cy, 10, cx, cy, Math.min(W,H)*0.22);
      haze.addColorStop(0, warm(0.075, 0.45));
      haze.addColorStop(0.55, warm(0.030, 0.65));
      haze.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = haze;
      g.fillRect(0,0,W,H);

      // Líneas con gradiente naranja->rosa
      const lg = g.createLinearGradient(W*0.40, H*0.05, W*0.86, H*0.32);
      lg.addColorStop(0, warm(0.65, 0.18));
      lg.addColorStop(1, warm(0.62, 0.82));
      g.strokeStyle = lg;
      g.globalAlpha = 0.55;
      g.lineWidth = 1.15;
      g.shadowColor = warm(0.55, 0.70);
      g.shadowBlur = 10;

      for(const [a,b] of E){
        const A = pts[a], B = pts[b];
        g.beginPath();
        g.moveTo(A.x, A.y);
        g.lineTo(B.x, B.y);
        g.stroke();
      }

      // Estrellas: glow cálido + núcleo más blanco para que “brille”
      g.shadowBlur = 0;
      for(const p of pts){
        const x=p.x, y=p.y;
        const r = 1.6 + p.m*1.25;
        const glowR = 18 + p.m*10;

        g.globalAlpha = 0.95;
        const rg = g.createRadialGradient(x,y, 0, x,y, glowR);
        rg.addColorStop(0, warm(0.28, 0.55));
        rg.addColorStop(0.38, warm(0.12, 0.72));
        rg.addColorStop(1, 'rgba(0,0,0,0)');
        g.fillStyle = rg;
        g.beginPath();
        g.arc(x,y, glowR, 0, TAU);
        g.fill();

        g.globalAlpha = 0.55;
        g.shadowColor = warm(0.45, 0.65);
        g.shadowBlur = 12 + p.m*6;
        g.fillStyle = 'rgba(255,255,255,1)';
        g.beginPath();
        g.arc(x,y, r, 0, TAU);
        g.fill();
        g.shadowBlur = 0;
      }

      g.restore();
      return pts;
    }

    // Capricornio: mismo dibujo de antes (solo que con paleta cálida)
    const PCAP = [
      {x:0.12, y:0.23, m:1.25},
      {x:0.21, y:0.17, m:1.10},
      {x:0.31, y:0.20, m:1.20},
      {x:0.39, y:0.26, m:1.05},
      {x:0.31, y:0.31, m:1.00},
      {x:0.23, y:0.30, m:0.95},
      {x:0.15, y:0.31, m:0.90},
      {x:0.18, y:0.37, m:0.85}
    ];
    const ECAP = [
      [0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0],
      [5,7],[7,4]
    ];

    // Leo: “hoz” + triángulo trasero (estilizado). No es atlas, es vibe.
    const PLEO = [
      {x:0.12, y:0.15, m:1.30}, // Régulo (aprox)
      {x:0.19, y:0.11, m:1.05},
      {x:0.27, y:0.12, m:1.00},
      {x:0.35, y:0.16, m:1.00},
      {x:0.41, y:0.22, m:1.10},
      {x:0.37, y:0.28, m:0.95},
      {x:0.29, y:0.31, m:0.95},
      {x:0.20, y:0.28, m:0.90},
      // triángulo trasero
      {x:0.48, y:0.25, m:1.00},
      {x:0.56, y:0.29, m:0.95},
      {x:0.52, y:0.35, m:0.90}
    ];
    const ELEO = [
      [0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0], // hoz
      [4,8],[8,9],[9,10],[10,6]                        // trasero
    ];

    // Posicionamiento: que convivan y se “mezclen” a la derecha, arriba del texto.
    const capPts = drawConst(PCAP, ECAP, -0.07, -0.12, W*0.70, H*0.13);
    const leoPts = drawConst(PLEO, ELEO, -0.22, -0.08, W*0.60, H*0.18);

    // Puente: une ambas constelaciones para que se vean como una composición
    const capA = capPts[2];       // ancla en Capricornio
    const leoA = leoPts[4];       // ancla en Leo
    const bridge = {x:(capA.x+leoA.x)*0.5, y:(capA.y+leoA.y)*0.5, m:1.35};

    g.save();
    g.globalCompositeOperation = 'screen';

    const lg2 = g.createLinearGradient(leoA.x, leoA.y, capA.x, capA.y);
    lg2.addColorStop(0, warm(0.60, 0.82));
    lg2.addColorStop(1, warm(0.60, 0.22));
    g.strokeStyle = lg2;
    g.lineWidth = 1.05;
    g.globalAlpha = 0.50;
    g.setLineDash([4,5]);

    g.beginPath();
    g.moveTo(leoA.x, leoA.y);
    g.quadraticCurveTo(bridge.x, bridge.y-10, capA.x, capA.y);
    g.stroke();
    g.setLineDash([]);

    // Estrella puente
    const glowR = 28;
    const rg = g.createRadialGradient(bridge.x, bridge.y, 0, bridge.x, bridge.y, glowR);
    rg.addColorStop(0, warm(0.30, 0.55));
    rg.addColorStop(0.45, warm(0.12, 0.75));
    rg.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = rg;
    g.beginPath();
    g.arc(bridge.x, bridge.y, glowR, 0, TAU);
    g.fill();

    g.globalAlpha = 0.60;
    g.shadowColor = warm(0.55, 0.65);
    g.shadowBlur = 14;
    g.fillStyle = 'rgba(255,255,255,1)';
    g.beginPath();
    g.arc(bridge.x, bridge.y, 2.6, 0, TAU);
    g.fill();
    g.shadowBlur = 0;

    g.restore();
  }



  function rebuildSkyCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const sky = g.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, 'rgba(12,14,46,1)');
    sky.addColorStop(0.40, 'rgba(7,9,24,1)');
    sky.addColorStop(1, 'rgba(3,3,10,1)');
    g.fillStyle = sky;
    g.fillRect(0,0,W,H);


    // Sol: ahora se dibuja dinámicamente (con “generación”) en drawSky()
// para que aparezca como el ramo cuando inicia / se re-genera.
const neb = (x,y,r, a, cr,cg,cb) => {
      const gg = g.createRadialGradient(x,y, 10, x,y, r);
      gg.addColorStop(0, rgba(cr,cg,cb,a));
      gg.addColorStop(0.55, rgba(cr,cg,cb,a*0.26));
      gg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = gg;
      g.fillRect(0,0,W,H);
    };
    neb(W*0.16, H*0.15, Math.max(W,H)*0.66, 0.09, 120,150,255);
    neb(W*0.82, H*0.20, Math.max(W,H)*0.60, 0.08, 160,120,255);
    neb(W*0.55, H*0.10, Math.max(W,H)*0.52, 0.06, 90,170,255);

    g.save();
    g.translate(W*0.56, H*0.34);
    g.rotate(-0.36);
    const mw = Math.max(W,H)*1.25;
    const mh = Math.max(W,H)*0.24;

    const mg = g.createRadialGradient(0,0, mh*0.03, 0,0, mh);
    mg.addColorStop(0, 'rgba(255,255,255,0.095)');
    mg.addColorStop(0.55, 'rgba(190,210,255,0.040)');
    mg.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = mg;
    g.beginPath();
    g.ellipse(0,0, mw*0.56, mh, 0, 0, TAU);
    g.fill();

    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.38;
    const dust = clamp(Math.floor((W*H)/8500), 160, 460);
    const prDust = makePRNG((W*2654435761) ^ (H*2246822519));
    for(let i=0;i<dust;i++){
      const dx = (prDust()-0.5) * mw*0.85;
      const dy = (prDust()-0.5) * mh*0.55;
      const rr = 0.6 + prDust()*1.9;
      g.fillStyle = 'rgba(255,255,255,0.11)';
      g.beginPath();
      g.arc(dx, dy, rr, 0, TAU);
      g.fill();
    }
    g.restore();

    g.save();
    g.globalCompositeOperation = 'screen';
    const pr = makePRNG((W*73856093) ^ (H*19349663) ^ 0xA53);
    const count = clamp(Math.floor((W*H)/2050), 900, 2400);
    for(let i=0;i<count;i++){
      const x = pr()*W;
      const y = Math.pow(pr(), 1.62) * (H*0.74);
      const a = 0.025 + pr()*0.085;
      const r = (pr()<0.90) ? (0.55 + pr()*0.85) : (0.95 + pr()*1.25);
      const warm = pr() < 0.18;
      g.fillStyle = warm ? `rgba(255,245,230,${a})` : `rgba(210,230,255,${a})`;
      g.beginPath();
      g.arc(x, y, r, 0, TAU);
      g.fill();
    }

    // Cúmulos extra (estático): densidad bonita sin depender solo del render dinámico
    const clusters2 = [
      {cx: W*0.18, cy: H*0.18, r: Math.min(W,H)*0.12, n: 180},
      {cx: W*0.84, cy: H*0.14, r: Math.min(W,H)*0.13, n: 210},
      {cx: W*0.55, cy: H*0.26, r: Math.min(W,H)*0.11, n: 160},
    ];
    for(const c of clusters2){
      for(let k=0;k<c.n;k++){
        const ang = pr()*TAU;
        const rr  = Math.sqrt(pr()) * c.r;
        const x = c.cx + Math.cos(ang)*rr;
        const y = c.cy + Math.sin(ang)*rr;
        if(y > H*0.74) continue;
        const a = 0.018 + pr()*0.045;
        const r = 0.35 + pr()*0.90;
        const warm = pr() < 0.20;
        g.fillStyle = warm ? `rgba(255,245,235,${a})` : `rgba(200,225,255,${a})`;
        g.beginPath();
        g.arc(x, y, r, 0, TAU);
        g.fill();
      }
    }

    g.restore();

    


    // Capa de nubes (estática en cache): suave, semitransparente, deja ver estrellas
    
    // Nubes (mejoradas): 4 capas, densidad con ruido suave, bordes difuminados y variación de grosor
    // Objetivo: que se vean orgánicas sin tapar estrellas, y sin matar FPS.
    
    // Nubes (pocas y dispersas): pequeñas, separadas y con mucha transparencia (no tapan estrellas)
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.13;

    const cloudCount = 5;                 // pocas
    for(let ci=0; ci<cloudCount; ci++){
      const cx = W*(0.06 + pr()*0.88);
      const cy = H*(0.04 + pr()*0.12);    // dispersas en el cielo (parte superior)
      const w = Math.min(W,H) * (0.10 + pr()*0.08); // tamaño moderado
      const h  = w * (0.45 + pr()*0.22);
      const puff = 8 + Math.floor(pr()*6);

      // gradiente suave (muy transparente)
      const a = 0.07 + pr()*0.08;
      const grd = g.createRadialGradient(cx, cy, w*0.05, cx, cy, w*0.55);
      grd.addColorStop(0.0, `rgba(235,245,255,${a*1.05})`);
      grd.addColorStop(0.55,`rgba(160,205,255,${a*0.55})`);
      grd.addColorStop(1.0, `rgba(70,105,155,0.00)`);
      g.fillStyle = grd;

      // puffs para forma orgánica
      for(let p=0;p<puff;p++){
        const t = p/(puff-1);
        const x = cx + (t-0.5)*w*(0.85 + pr()*0.20);
        const y = cy + (pr()*2-1)*h*0.28 + Math.sin((t*TAU)+(pr()*0.8))*h*0.10;
        const r = (w*0.05 + pr()*w*0.07) * (0.85 + 0.50*(1-Math.abs(t-0.5)*1.6));
        g.beginPath();
        g.ellipse(x, y, r, r*(0.70 + pr()*0.30), 0, 0, TAU);
        g.fill();
      }

      // velo muy tenue (cuerpo)
      g.save();
      g.globalAlpha = 0.05;
      g.fillStyle = `rgba(210,235,255,${a*0.75})`;
      g.beginPath();
      g.ellipse(cx, cy, w*0.48, h*0.90, 0, 0, TAU);
      g.fill();
      g.restore();

      // sombra inferior mínima (profundidad)
      g.save();
      g.globalCompositeOperation = 'multiply';
      g.globalAlpha = 0.06;
      g.fillStyle = 'rgba(15,25,45,0.60)';
      g.beginPath();
      g.ellipse(cx, cy + h*0.16, w*0.36, h*0.62, 0, 0, TAU);
      g.fill();
      g.restore();
    }

    g.restore();

    // Luna (vuelve): disco frío + brillo + cráteres sutiles
    const mx = W*LIGHT.x, my = H*LIGHT.y;
    const R  = Math.min(W,H)*0.070;

    // Glow lunar
    g.save();
    g.globalCompositeOperation = 'screen';
    const mglow = g.createRadialGradient(mx, my, R*0.30, mx, my, R*3.0);
    mglow.addColorStop(0.0, 'rgba(210,235,255,0.65)');
    mglow.addColorStop(0.35,'rgba(140,190,235,0.22)');
    mglow.addColorStop(1.0, 'rgba(80,120,170,0.00)');
    g.fillStyle = mglow;
    g.beginPath(); g.arc(mx,my,R*3.0,0,TAU); g.fill();
    g.restore();

    // Disco lunar
    g.save();
    const moon = g.createRadialGradient(mx-R*0.25, my-R*0.18, R*0.20, mx, my, R*1.05);
    moon.addColorStop(0.0, 'rgba(250,252,255,1.0)');
    moon.addColorStop(0.55,'rgba(225,235,245,1.0)');
    moon.addColorStop(1.0, 'rgba(185,205,225,1.0)');
    g.fillStyle = moon;
    g.beginPath(); g.arc(mx,my,R,0,TAU); g.fill();

    // Cráteres (clip dentro del disco)
    g.save();
    g.beginPath(); g.arc(mx,my,R,0,TAU); g.clip();
    const cr = 16;
    for(let k=0;k<cr;k++){
      const a = pr()*TAU;
      const rr = Math.sqrt(pr())*R*0.82;
      const x = mx + Math.cos(a)*rr;
      const y = my + Math.sin(a)*rr;
      const r = R*(0.05 + pr()*0.12);

      g.globalAlpha = 0.10 + pr()*0.10;
      g.fillStyle = 'rgba(110,140,165,0.55)';
      g.beginPath();
      g.ellipse(x+r*0.18, y+r*0.14, r*1.02, r*0.82, a, 0, TAU);
      g.fill();

      g.globalAlpha = 0.10 + pr()*0.14;
      g.fillStyle = 'rgba(255,255,255,0.60)';
      g.beginPath();
      g.ellipse(x-r*0.12, y-r*0.10, r*0.92, r*0.72, a, 0, TAU);
      g.fill();
    }
    g.restore();

    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.22;
    g.strokeStyle = 'rgba(255,255,255,0.55)';
    g.lineWidth = 1.1;
    g.beginPath(); g.arc(mx,my,R*0.98,0,TAU); g.stroke();

    g.restore();

    const vg = g.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.98);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.62)');
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);


    // Constelaciones: Capricornio + Leo (mezcladas)
    drawLeoCapricornBlendToCache(g);
    skyCache = off;
  }

  function rebuildBushCache(){
    // Arbusto envolvente: sube y abraza el ramo completo (detrás de flores/tallos).
    // Se cachea para que se vea orgánico sin quemar FPS.
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@q${q}`;
    if(bushCache && bushCacheKey === key) return;

    bushCacheKey = key;

    const off = document.createElement('canvas');
    off.width = W;
    off.height = H;
    const g = off.getContext('2d');

    const R = Math.min(W,H);

    // --- Base: gradiente de profundidad (desde media pantalla hacia abajo) ---
    const v = g.createLinearGradient(0, H*0.52, 0, H);
    v.addColorStop(0, 'rgba(0,0,0,0)');
    v.addColorStop(0.55, 'rgba(0,0,0,0.10)');
    v.addColorStop(1, 'rgba(0,0,0,0.26)');
    g.fillStyle = v;
    g.fillRect(0, H*0.50, W, H*0.50);

    // --- Masas grandes: crean “volumen” alrededor del ramo, no solo abajo ---
    // Centro + laterales + “cúpula” detrás de las flores
    const lumps = [
      // Cúpula principal (detrás del ramo)
      {x:0.50, y:0.76, s:0.92, a:0.24},
      // Soporte inferior
      {x:0.50, y:0.96, s:0.58, a:0.22},
      {x:0.35, y:0.97, s:0.52, a:0.20},
      {x:0.65, y:0.97, s:0.54, a:0.20},
      // Laterales para “abrazar”
      {x:0.18, y:0.86, s:0.60, a:0.16},
      {x:0.82, y:0.86, s:0.60, a:0.16},
      // Sub-masas para romper simetría
      {x:0.28, y:0.72, s:0.55, a:0.13},
      {x:0.72, y:0.72, s:0.55, a:0.13},
      {x:0.50, y:0.62, s:0.48, a:0.10},
    ];

    for(const L of lumps){
      const cx = W*L.x;
      const cy = H*L.y;
      const rad = R*L.s;

      const rg = g.createRadialGradient(cx, cy, 10, cx, cy, rad);
      rg.addColorStop(0, `rgba(85,190,125,${0.18*L.a/0.24})`);
      rg.addColorStop(0.25, `rgba(65,165,110,${0.24*L.a/0.24})`);
      rg.addColorStop(0.62, `rgba(32,95,65,${0.18*L.a/0.24})`);
      rg.addColorStop(0.88, `rgba(10,40,25,${0.12*L.a/0.24})`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.fillRect(0,0,W,H);
    }

    // --- Textura: hojitas sugeridas (desde mitad hacia abajo y alrededor del ramo) ---
    const count = q>=3 ? 980 : q>=2 ? 720 : 520;

    // PRNG estable por tamaño/calidad
    let s = ((W*73856093) ^ (H*19349663) ^ (q*83492791)) >>> 0;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    g.save();
    g.globalCompositeOperation = 'screen';

    for(let i=0;i<count;i++){
      // sesgo hacia el centro del ramo, con laterales también
      const t = rnd();
      const cx = 0.50 + (rnd()*0.70 - 0.35) * (0.55 + 0.45*t);  // 0.15..0.85
      const px = W*clamp(cx, 0.05, 0.95);

      // sube bastante: 0.50..1.00 con densidad mayor abajo
      const py = H*(0.50 + 0.50*t*t);

      const scale = 0.55 + rnd()*1.85;

      const a = 0.035 + rnd()*0.085;
      const shade = 0.48 + rnd()*0.52;

      // verdes nocturnos
      const rr = Math.round(20 + 55*shade);
      const gg2 = Math.round(80 + 135*shade);
      const bb = Math.round(40 + 85*shade);

      g.globalAlpha = a;

      // trazos cortos tipo hojita
      g.strokeStyle = `rgba(${rr},${gg2},${bb},0.95)`;
      g.lineWidth = 1.10*scale;
      g.lineCap = 'round';

      const ang = rnd()*TAU;
      const len = (2.6 + rnd()*8.4) * scale;

      g.beginPath();
      g.moveTo(px, py);
      g.lineTo(px + Math.cos(ang)*len, py + Math.sin(ang)*len*0.55);
      g.stroke();

      // puntito brillante (rocío/hoja)
      if(i % 3 === 0){
        g.fillStyle = `rgba(${170 + (rnd()*80|0)},${220 + (rnd()*35|0)},${185 + (rnd()*55|0)},0.50)`;
        g.beginPath();
        g.arc(px + Math.cos(ang)*len*0.55, py + Math.sin(ang)*len*0.30, 0.85*scale, 0, TAU);
        g.fill();
      }
    }
    g.restore();

    // Suavizado leve para integrar
    try{
      if(HAS_FILTER){
        g.save();
        g.globalAlpha = 0.26;
        g.filter = 'blur(1.05px)';
        g.drawImage(off, 0, 0);
        g.restore();
      }
    }catch(_){}

    // Viñeta suave para cerrar los bordes
    const vig = g.createRadialGradient(W*0.5, H*0.72, R*0.15, W*0.5, H*0.78, R*1.25);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.16)');
    g.fillStyle = vig;
    g.fillRect(0,0,W,H);

    bushCache = off;
  }




  function rebuildStaticSkyOverlayCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    // === Texto en estrellas (sin animación) ===
    if(textStars.length){
      g.save();
      g.globalCompositeOperation = 'screen';

      const gx = W*0.5, gy = H*0.28;
      const fontHint = clamp(Math.min(W,H)*0.09, 26, 58);
      const glow = g.createRadialGradient(gx, gy, 10, gx, gy, fontHint*7.5);
      glow.addColorStop(0, 'rgba(210,230,255,0.09)');
      glow.addColorStop(1, 'rgba(210,230,255,0)');
      g.globalAlpha = 1;
      g.fillStyle = glow;
      g.fillRect(0,0,W,H);

      for(const st of textStars){
        const alpha = st.a * 1.30; // (0.75 + 0.55*1)
        const x = st.x*W;
        const y = st.y*H;

        g.globalAlpha = alpha;
        g.shadowColor = 'rgba(255,255,255,0.55)';
        g.shadowBlur = 9 + st.r*6;

        g.fillStyle = st.hue ? `hsla(${st.hue}, 75%, 92%, 1)` : 'rgba(255,255,255,1)';
        g.beginPath();
        g.arc(x, y, st.r, 0, TAU);
        g.fill();

        if(st.flare){
          g.save();
          g.shadowBlur = 0;
          g.globalCompositeOperation = 'lighter';
          g.globalAlpha = alpha * 0.40 * st.flare;
          g.strokeStyle = 'rgba(255,255,255,0.55)';
          g.lineWidth = 1;
          const k = 3.0 + st.r*2.0;
          g.beginPath();
          g.moveTo(x-k, y); g.lineTo(x+k, y);
          g.moveTo(x, y-k); g.lineTo(x, y+k);
          g.stroke();
          g.restore();
        }
      }

      g.restore();
      g.globalCompositeOperation = 'source-over';
      g.shadowBlur = 0;
      g.globalAlpha = 1;
    }

    // === Líneas de constelaciones generadas ===
    if(starLinks.length){
      g.save();
      g.globalCompositeOperation = 'screen';
      g.lineCap = 'round';
      g.lineJoin = 'round';
      g.strokeStyle = 'rgba(200,220,255,1)';
      g.lineWidth = 1;

      for(const L of starLinks){
        const a = stars[L.i];
        const b = stars[L.j];
        const ax = a.x * W, ay = a.y * H;
        const bx = b.x * W, by = b.y * H;
        if(ay > H*0.62 || by > H*0.62) continue;

        g.globalAlpha = L.a;
        g.beginPath();
        g.moveTo(ax, ay);
        g.lineTo(bx, by);
        g.stroke();
      }
      g.restore();
    }

    // === Estrellas (sin parallax ni twinkle) ===
    if(stars.length){
      g.save();
      g.globalCompositeOperation = 'screen';

      for(const st of stars){
        const alpha = st.a * 1.30 * CONFIG.twinkle;
        const x = st.x * W;
        const y = st.y * H;

        g.globalAlpha = alpha;

        if(st.r < 1.15){
          g.shadowBlur = 0;
        }else{
          g.shadowColor = 'rgba(255,255,255,0.55)';
          g.shadowBlur = 8 + st.r*3.2;
        }

        g.fillStyle = st.hue ? `hsla(${st.hue}, 80%, 90%, 1)` : 'rgba(255,255,255,1)';
        g.beginPath();
        g.arc(x, y, st.r, 0, TAU);
        g.fill();

        if(st.flare){
          g.save();
          g.globalCompositeOperation = 'lighter';
          g.shadowBlur = 0;

          g.globalAlpha = alpha * 0.42 * st.flare;
          const rg = g.createRadialGradient(x,y, 0, x,y, 18 + st.r*11);
          rg.addColorStop(0, 'rgba(255,255,255,0.20)');
          rg.addColorStop(0.45, 'rgba(255,255,255,0.07)');
          rg.addColorStop(1, 'rgba(255,255,255,0)');
          g.fillStyle = rg;
          g.beginPath();
          g.arc(x,y, 18 + st.r*11, 0, TAU);
          g.fill();

          g.globalAlpha = alpha * 0.28 * st.flare;
          g.strokeStyle = 'rgba(255,255,255,0.55)';
          g.lineWidth = 1;
          const k = 3.6 + st.r*1.6;
          g.beginPath();
          g.moveTo(x-k, y); g.lineTo(x+k, y);
          g.moveTo(x, y-k); g.lineTo(x, y+k);
          g.stroke();
          g.restore();
        }
      }

      g.restore();
      g.shadowBlur = 0;
      g.globalAlpha = 1;
      g.globalCompositeOperation = 'source-over';
    }

    staticSkyOverlayCache = off;
  }


  function drawSky(t){
    if(skyCache){
      ctx.drawImage(skyCache, 0, 0, skyCache.width / DPR, skyCache.height / DPR);
    }else{
      const sky = ctx.createLinearGradient(0, 0, 0, H);
      sky.addColorStop(0, 'rgba(12,14,46,1)');
      sky.addColorStop(0.40, 'rgba(7,9,24,1)');
      sky.addColorStop(1, 'rgba(3,3,10,1)');
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);
    }

    // Reduce-motion: usa overlay estático (muy barato)
    if(CONFIG.reduceMotion && staticSkyOverlayCache){
      ctx.drawImage(staticSkyOverlayCache, 0, 0, staticSkyOverlayCache.width / DPR, staticSkyOverlayCache.height / DPR);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';

      drawMoon(t);
      if(shooting.active) drawShootingStar(t);
      return;
    }

    // Layer dinámico cacheado (30fps): estrellas + constelaciones + texto + wisps
    rebuildSkyDynCache();
    renderSkyDynamic(t);
    if(skyDynCache){
      ctx.drawImage(skyDynCache, 0, 0, skyDynCache.width / DPR, skyDynCache.height / DPR);
    }

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';

    // Sol y fugaces por encima
    drawMoon(t);
    maybeStartShootingStar(t);
    drawShootingStar(t);
  }

  // ===== Hojas =====
  function drawTulipLeaf(attachX, attachY, angle, scale, side){
    const id = ((attachX * 97) ^ (attachY * 193) ^ (side * 911)) | 0;
    const j = (Math.sin(id) * 0.5 + 0.5);

    const len = (95 + j*10) * scale;
    const baseWid = (7.5 + j*1.2) * scale;

    const baseDir = Math.PI/2 + angle;
    const leafAngle = baseDir + side * (0.16 + j*0.03);

    const p0x = attachX, p0y = attachY;
    const p3x = attachX + Math.cos(leafAngle) * len;
    const p3y = attachY - Math.sin(leafAngle) * len;

    const p1x = attachX + side * baseWid * (0.34 + j*0.08);
    const p1y = attachY - len * (0.35 + j*0.05);

    const p2x = attachX + side * baseWid * (0.14 + j*0.06);
    const p2y = attachY - len * (0.82 + j*0.06);

    const bez = (t, a,b,c,d) => {
      const u = 1 - t;
      return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
    };

    const G0 = {r:28,g:88,b:56};
    const G1 = {r:52,g:140,b:88};
    const G2 = {r:96,g:190,b:130};

    const grad = ctx.createLinearGradient(p0x, p0y, p3x, p3y);
    grad.addColorStop(0, rgba(G0.r,G0.g,G0.b, 0.92));
    grad.addColorStop(0.55, rgba(G1.r,G1.g,G1.b, 0.84));
    grad.addColorStop(1, rgba(G2.r,G2.g,G2.b, 0.70));

    const steps = 14;
    const L = [], R = [], C = [];

    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const x = bez(t, p0x,p1x,p2x,p3x);
      const y = bez(t, p0y,p1y,p2y,p3y);
      C.push({x,y});

      const t2 = Math.min(1, t + 0.015);
      const x2 = bez(t2, p0x,p1x,p2x,p3x);
      const y2 = bez(t2, p0y,p1y,p2y,p3y);
      const dx = x2-x, dy=y2-y;
      const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
      const nx = -dy*inv, ny = dx*inv;

      const taper = Math.pow(1 - t, 1.55);
      const w = baseWid * (0.04 + 0.50*taper);

      L.push({x: x + nx*w, y: y + ny*w});
      R.push({x: x - nx*w, y: y - ny*w});
    }

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.14)';
    ctx.shadowBlur = 4 * scale;

    ctx.fillStyle = grad;
    ctx.strokeStyle = 'rgba(255,255,255,0.012)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(L[0].x, L[0].y);
    for(const p of L) ctx.lineTo(p.x, p.y);
    for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i].x, R[i].y);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.stroke();

    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = Math.max(1, 1.15*scale);
    ctx.beginPath();
    for(let i=0;i<C.length;i++){
      const p = C[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.10;
    const edge = side < 0 ? L : R;
    ctx.strokeStyle = 'rgba(180,255,210,0.14)';
    ctx.lineWidth = Math.max(1, 0.9*scale);
    ctx.beginPath();
    for(let i=0;i<edge.length;i++){
      const p = edge[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawLeafSprig(x, y, angle, scale, side){
    const baseDir = Math.PI/2 + angle;
    const a = baseDir + side*(0.30);

    const len = 72 * scale;
    const spread = 14 * scale;

    const tipX = x + Math.cos(a) * len;
    const tipY = y - Math.sin(a) * len;

    const cX = x + side * spread;
    const cY = y - len * 0.55;

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const lg = ctx.createLinearGradient(x, y, tipX, tipY);
    lg.addColorStop(0, 'rgba(8,20,12,0.10)');
    lg.addColorStop(0.55, 'rgba(70,200,130,0.08)');
    lg.addColorStop(1, 'rgba(90,240,160,0.12)');

    ctx.strokeStyle = lg;
    ctx.lineWidth = Math.max(1, 0.9 * scale);

    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(cX, cY, tipX, tipY);
    ctx.stroke();

    ctx.globalAlpha = 0.45;
    ctx.beginPath();
    ctx.moveTo(x + side*2.0*scale, y + 1.3*scale);
    ctx.quadraticCurveTo(cX - side*spread*0.55, cY + len*0.12, tipX - side*3.0*scale, tipY + 1.2*scale);
    ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(120,255,180,0.08)';
    ctx.lineWidth = Math.max(1, 0.8 * scale);
    ctx.beginPath();
    ctx.moveTo(x + side*0.8*scale, y);
    ctx.quadraticCurveTo((x+tipX)*0.5, (y+tipY)*0.5, tipX, tipY);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Pétalos =====
  function getBloomSprite(w, h, col, seed, open, petalsVisible){
    const oQ = Math.round(((open||1) * 20));
    // Suaviza la “generación”: en lugar de 7 pasos (0..6), usamos 25 pasos (0..24) = incrementos de 0.25
    const pvRaw = (petalsVisible==null ? 6 : petalsVisible);
    const pvQ = clamp(Math.round(pvRaw * 4), 0, 24); // 0..24
    const pv = pvQ / 4; // 0..6 (float)
    const key = `${Math.round(w)}x${Math.round(h)}_${col.r},${col.g},${col.b}_${seed}_o${oQ}_p${pvQ}`;
    const cached = bloomCache.get(key);
    if(cached) return cached;
    const ss = (CONFIG.quality>=3 ? 3 : 2);

    // ===== FIX “pétalos cortados” =====
    // El sprite anterior era un poco pequeño en la parte superior: algunos pétalos (len ~ h*1.0
    // + centerY ~ -h*0.62) alcanzaban ~ -1.6h, y ay=1.55h los recortaba.
    // Solución: añadir padding real y subir ay + alto del sprite.
    const pad = Math.ceil(Math.max(w, h) * 0.55);
    const cw  = Math.ceil(w * 3.25 + pad);
    const ch  = Math.ceil(h * 3.00 + w * 0.45 + pad);

    const ax = Math.ceil(cw * 0.50);
    const ay = Math.ceil(h * 1.95 + pad * 0.15);

    const off = document.createElement('canvas');
    off.width  = cw * ss;
    off.height = ch * ss;

    const c2 = off.getContext('2d', { alpha:true });
    c2.setTransform(ss,0,0,ss,0,0);
    c2.translate(ax, ay);

    renderOrchidBloomSprite(c2, w, h, col, seed, oQ/20, pv);

    const obj = { canvas: off, ox: ax, oy: ay, ss };
    bloomCache.set(key, obj);
    return obj;
  }
  
  function renderOrchidBloomSprite(c2, w, h, col, seed, open, petalsVisible){
    // Orquídea más realista (sin volverse una foto ni matar rendimiento):
    // - Formas más redondeadas (menos “punta”), borde ligeramente ondulado
    // - Sub-surface/“translucencia” en bordes, AO suave en el centro
    // - Venas más orgánicas + moteado controlado (no confeti)
    // - Labelo con lóbulos y garganta más profunda
    // - Columna con volumen

    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const pv = clamp((petalsVisible==null?6:petalsVisible), 0, 6); // float
    const appear = pv / 6; // 0..1
    const op = clamp(open==null?1:open, 0, 1);

    const mix = (a,b,t)=>({
      r: Math.round(lerp(a.r,b.r,t)),
      g: Math.round(lerp(a.g,b.g,t)),
      b: Math.round(lerp(a.b,b.b,t))
    });

    // Paleta pétalos: naranja difuminado (cálido, suave)
    const lite = mix(col, {r:255,g:255,b:255}, 0.72);
    const mid  = mix(col, {r:255,g:248,b:235}, 0.52);
    const deep = mix(col, {r:120,g:45,b:10},   0.72);
    const edge = mix(lite,{r:255,g:252,b:245}, 0.82);

    // neutros para micro-variación
    const frostA = {r:255,g:255,b:255};
    const frostB = mix(col, {r:255,g:255,b:255}, 0.90);

    // garganta/centro: marfil cálido tenue (detalle realista, pero discreto)
    const throat = mix({r:255,g:246,b:232}, {r:255,g:255,b:255}, 0.55);
    const throatDeep = mix(deep, {r:130,g: 92,b: 40}, 0.25);

    // labelo (centro): mantiene un toque cálido para contraste
    const lipCol  = mix({r:255,g:220,b:190}, {r:255,g:255,b:255}, 0.35);
    const lipDeep = mix({r:210,g:120,b: 90}, deep, 0.45);

    const centerY = -h*0.58;

    // halo sutil (bloom)
    c2.save();
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.10;
    const haloR = Math.max(w*1.65, h*1.22);
    const halo = c2.createRadialGradient(0, centerY, 6, 0, centerY, haloR);
    halo.addColorStop(0, rgba(col.r,col.g,col.b,0.22));
    halo.addColorStop(0.55, rgba(col.r,col.g,col.b,0.06));
    halo.addColorStop(1, rgba(col.r,col.g,col.b,0));
    c2.fillStyle = halo;
    c2.beginPath();
    c2.ellipse(0, centerY, w*1.26, h*1.10, 0, 0, TAU);
    c2.fill();
    c2.restore();

    // sombra de anclaje
    c2.save();
    c2.globalAlpha = 0.15;
    c2.fillStyle = rgba(0,0,0,0.18);
    c2.beginPath();
    c2.ellipse(0, h*0.03, w*0.34, h*0.12, 0, 0, TAU);
    c2.fill();
    c2.restore();

    const stage = (i)=>{
      // 6 partes: 0 dorsal, 1 sepal izq, 2 sepal der, 3 petal izq, 4 petal der, 5 labelo+columna
      const x = clamp(appear*6 - i, 0, 1);
      return x*x*(3-2*x);
    };

    const drawPetal = (ang, len, wid, alpha, tint, curl, isBack, kind)=>{
      if(alpha <= 0) return;

      c2.save();
      c2.translate(0, centerY);
      c2.rotate(ang);

      // Apertura: open = más extendida
      const spread = lerp(0.80, 1.08, op);
      c2.scale(spread, 1);

      // Curvatura ligera
      c2.transform(1, 0, curl, 1, 0, 0);

      // “Tipo” de pieza: dorsal / sepal / petal (variación de redondeo)
      const tipRound = (kind==='petal') ? 0.50 : (kind==='dorsal' ? 0.42 : 0.44);
      const ruffleAmp = (isBack ? 0.052 : 0.085) * (kind==='petal' ? 1.0 : 0.85);

      // Precalcula forma (determinista dentro de esta pieza)
      const tipY = -len;
      const shoulder = wid*(0.95 + 0.08*rnd());
      const upper = wid*(0.62 + 0.08*rnd());
      const tipW = wid*(tipRound + 0.05*rnd());
      const ruf = wid*ruffleAmp;
      const wob1 = (rnd()*2-1) * ruf;
      const wob2 = (rnd()*2-1) * ruf;
      const tipCtrl = tipY - len*(0.04 + 0.02*rnd());

      const path = ()=>{
        // Silueta más “phalaenopsis”: base estrecha, hombro amplio y punta redondeada,
        // con ondulación fina en el borde (ruffle) que se intensifica hacia el tip.
        const steps = 26;
        const sCurve = (t)=> t*t*(3-2*t);

        const baseHalf = wid * (kind==='petal' ? 0.080 : 0.065) * (0.95 + 0.10*rndLocal(9));
        const midHalf  = shoulder * (0.98 + 0.03*rndLocal(10));
        const tipHalf  = tipW * (0.98 + 0.05*rndLocal(11));
        const midT     = kind==='petal' ? 0.22 : 0.18;

        const halfAt = (t)=>{
          if(t < midT){
            const u = sCurve(t / midT);
            return lerp(baseHalf, midHalf, u);
          } else {
            const u = sCurve((t - midT) / (1 - midT));
            return lerp(midHalf, tipHalf, u);
          }
        };

        const ampBase = ruf * (isBack ? 0.65 : 1.00) * (kind==='petal' ? 1.05 : 0.85);

        c2.beginPath();

        // borde derecho (base→tip)
        for(let i=0;i<=steps;i++){
          const t = i/steps;
          const y = -len*t;

          const amp = ampBase * (0.12 + 0.88*Math.pow(t, 1.25));
          const wob = Math.sin(t*TAU*(2.20 + 0.25*rndLocal(12)) + 1.10 + wob1*0.08) * amp
                    + Math.sin(t*TAU*(3.70 + 0.18*rndLocal(13)) + 2.00 + wob2*0.07) * (amp*0.35);

          const x = halfAt(t) + wob;
          if(i===0) c2.moveTo(x, y);
          else c2.lineTo(x, y);
        }

        // borde izquierdo (regreso tip→base)
        for(let i=steps;i>=0;i--){
          const t = i/steps;
          const y = -len*t;

          const amp = ampBase * (0.12 + 0.88*Math.pow(t, 1.25));
          const wob = Math.sin(t*TAU*(2.15 + 0.25*rndLocal(14)) + 2.20 - wob1*0.07) * amp
                    + Math.sin(t*TAU*(3.55 + 0.18*rndLocal(15)) + 0.60 - wob2*0.06) * (amp*0.35);

          const x = -halfAt(t) - wob;
          c2.lineTo(x, y);
        }

        c2.closePath();
      };

      // Micro-variación sin consumir rnd (para que path() sea idéntico en shadow/fill/clip)
      // Usamos una mini función determinista basada en seed local.
      const rl = (Math.floor((wob1*9973 + wob2*7919 + len*37 + wid*13)*1000) >>> 0) || 1;
      const rndLocal = (k)=>{
        // k: 0..3
        let x = (rl + k*1013) >>> 0;
        x = (x * 1664525 + 1013904223) >>> 0;
        return (x / 4294967296);
      };

      // sombra trasera suave (da separación de capas)
      c2.save();
      c2.globalAlpha = alpha * (isBack ? 0.16 : 0.12);
      c2.fillStyle = rgba(0,0,0,0.22);
      c2.translate(0.8, 1.2);
      path();
      c2.fill();
      c2.restore();

      // gradiente principal (vertical) - naranja difuminado (todas las piezas)
// (un poco más orgánico: micro-variación por pétalo para que no se vea “plástico uniforme”)
const j1 = (rndLocal(31) - 0.5) * 2; // -1..1
const j2 = (rndLocal(32) - 0.5) * 2; // -1..1

const baseT = clamp(0.12 + 0.08*tint + 0.03*j1, 0.08, 0.28);
const baseCol = mix(col, {r:255,g:255,b:255}, baseT);

const deepR = mix(baseCol, {r:145,g:60,b:14}, clamp(0.66 + 0.06*j2, 0.56, 0.78));
const body  = mix(baseCol, {r:255,g:255,b:255}, clamp(0.34 + 0.10*tint, 0.30, 0.52));
const tip   = mix(baseCol, {r:255,g:255,b:255}, clamp(0.64 + 0.12*tint, 0.56, 0.86));
const hi    = mix(body,    {r:255,g:255,b:255}, 0.42);

      // capa difuminada para “bloom” suave (sin filtros pesados)
      c2.save();
      c2.globalAlpha = alpha * (isBack ? 0.34 : 0.42);
      c2.shadowColor = 'rgba(255,165,70,0.30)';
      c2.shadowBlur  = wid * (isBack ? 0.10 : 0.14);
      c2.fillStyle   = rgba(baseCol.r, baseCol.g, baseCol.b, 0.40);
      path();
      c2.fill();
      c2.restore();

      const g = c2.createLinearGradient(0, 0, 0, tipY);
      g.addColorStop(0.00, rgba(deepR.r, deepR.g, deepR.b, 0.82));
      g.addColorStop(0.28, rgba(body.r,  body.g,  body.b,  0.95));
      g.addColorStop(0.72, rgba(hi.r,    hi.g,    hi.b,    0.94));
      g.addColorStop(1.00, rgba(tip.r,   tip.g,   tip.b,   0.92));

      c2.globalAlpha = alpha;
      c2.fillStyle = g;
      path();
      c2.fill();

// sombreado de curvatura (volumen por pétalo)
      c2.save();
      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = alpha * (isBack ? 0.045 : 0.080);
      path();
      c2.clip();
      const sh = c2.createLinearGradient(-wid*0.95, tipY*0.05, wid*0.95, tipY*0.85);
      sh.addColorStop(0.00, 'rgba(0,0,0,0.18)');
      sh.addColorStop(0.35, 'rgba(0,0,0,0.06)');
      sh.addColorStop(0.55, 'rgba(0,0,0,0)');
      sh.addColorStop(1.00, 'rgba(0,0,0,0.12)');
      c2.fillStyle = sh;
      c2.fillRect(-wid*1.6, tipY-len*0.30, wid*3.2, len*1.75);
      c2.restore();

      // AO suave hacia el centro (profundidad)
      c2.save();
      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = alpha * 0.10;
      const ao = c2.createRadialGradient(0, -len*0.10, 0, 0, -len*0.10, Math.max(wid*0.95, len*0.55));
      ao.addColorStop(0, 'rgba(0,0,0,0.26)');
      ao.addColorStop(0.55, 'rgba(0,0,0,0.10)');
      ao.addColorStop(1, 'rgba(0,0,0,0)');
      c2.fillStyle = ao;
      path();
      c2.fill();
      c2.restore();

      // translucencia de bordes (subsurface) + brillo suave
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * (isBack ? 0.06 : 0.12);
      path();
      c2.clip();

      const e1 = c2.createRadialGradient(wid*0.62, tipY*0.52, 0, wid*0.62, tipY*0.52, len*0.86);
      e1.addColorStop(0, 'rgba(255,255,255,0.18)');
      e1.addColorStop(0.55,'rgba(255,255,255,0.07)');
      e1.addColorStop(1, 'rgba(255,255,255,0)');
      c2.fillStyle = e1;
      c2.fillRect(-wid*1.4, tipY-len*0.25, wid*2.8, len*1.6);

      const e2 = c2.createRadialGradient(-wid*0.62, tipY*0.52, 0, -wid*0.62, tipY*0.52, len*0.86);
      e2.addColorStop(0, 'rgba(255,255,255,0.16)');
      e2.addColorStop(0.55,'rgba(255,255,255,0.06)');
      e2.addColorStop(1, 'rgba(255,255,255,0)');
      c2.fillStyle = e2;
      c2.fillRect(-wid*1.4, tipY-len*0.25, wid*2.8, len*1.6);

      // centro ligeramente más claro
      c2.globalAlpha = alpha * (isBack ? 0.035 : 0.060);
      const cg = c2.createRadialGradient(0, tipY*0.35, 0, 0, tipY*0.35, len*0.92);
      cg.addColorStop(0, rgba(throat.r, throat.g, throat.b, 0.26));
      cg.addColorStop(0.45, rgba(255,255,255,0.10));
      cg.addColorStop(1, rgba(255,255,255,0));
      c2.fillStyle = cg;
      c2.beginPath();
      c2.ellipse(0, tipY*0.40, wid*0.82, len*0.62, 0, 0, TAU);
      c2.fill();

      c2.restore();


      // especular “ceroso” (realismo: brillo direccional suave)
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * (isBack ? 0.025 : 0.075);
      path();
      c2.clip();
      const sg = c2.createLinearGradient(-wid*0.65, -len*0.10, wid*0.85, -len*0.95);
      sg.addColorStop(0.00, 'rgba(255,255,255,0)');
      sg.addColorStop(0.38, 'rgba(255,255,255,0.08)');
      sg.addColorStop(0.55, 'rgba(255,255,255,0.20)');
      sg.addColorStop(0.70, 'rgba(255,255,255,0.06)');
      sg.addColorStop(1.00, 'rgba(255,255,255,0)');
      c2.fillStyle = sg;
      c2.fillRect(-wid*1.4, tipY-len*0.25, wid*2.8, len*1.6);
      c2.restore();

      // toques blancos: aclara bordes y tips (mezcla rojo↔blanco)
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * (isBack ? 0.030 : 0.085);
      path();
      c2.clip();

      const pg = c2.createRadialGradient(0, tipY*0.62, 0, 0, tipY*0.62, len*0.98);
      pg.addColorStop(0.00, 'rgba(255,255,255,0)');
      pg.addColorStop(0.48, rgba(frostB.r, frostB.g, frostB.b, 0.14));
      pg.addColorStop(1.00, rgba(frostA.r, frostA.g, frostA.b, 0.26));
      c2.fillStyle = pg;
      c2.fillRect(-wid*1.6, tipY-len*0.30, wid*3.2, len*1.75);

      // toque central muy leve (look “ceroso”)
      c2.globalAlpha = alpha * (isBack ? 0.014 : 0.040);
      const pg2 = c2.createRadialGradient(0, tipY*0.18, 0, 0, tipY*0.18, len*0.60);
      pg2.addColorStop(0.00, rgba(frostA.r, frostA.g, frostA.b, 0.12));
      pg2.addColorStop(0.55, 'rgba(255,255,255,0)');
      pg2.addColorStop(1.00, 'rgba(255,255,255,0)');
      c2.fillStyle = pg2;
      c2.beginPath();
      c2.ellipse(0, tipY*0.18, wid*0.62, len*0.40, 0, 0, TAU);
      c2.fill();

      c2.restore();

      // borde iluminado (más fino y “natural”)
      c2.save();
      c2.globalAlpha = alpha * 0.14;
      c2.strokeStyle = rgba(edge.r,edge.g,edge.b, 0.92);
      c2.lineWidth = Math.max(0.75, wid*0.085);
      c2.lineJoin = 'round';
      c2.lineCap  = 'round';
      path();
      c2.stroke();
      c2.restore();


      // micro “ruffle” en los bordes (más orgánico, sin sobrecargar)
      // Ahora usa el mismo contorno del pétalo para que no se vean trazos “fuera” del relleno.
      c2.save();
      c2.lineJoin = 'round';
      c2.lineCap  = 'round';

      const rg = c2.createLinearGradient(0, -len*0.10, 0, tipY);
      rg.addColorStop(0.00, 'rgba(255,255,255,0.08)');
      rg.addColorStop(0.55, 'rgba(255,255,255,0.24)');
      rg.addColorStop(1.00, 'rgba(255,255,255,0.06)');

      c2.globalAlpha = alpha * (kind==='petal' ? 0.16 : 0.12);
      c2.strokeStyle = rg;
      c2.lineWidth = Math.max(0.55, wid*0.030);
      path();
      c2.stroke();

      // Segundo pase mínimo, ligeramente desplazado (da sensación de borde “ondulado”)
      c2.globalAlpha = alpha * (kind==='petal' ? 0.055 : 0.040);
      c2.lineWidth = Math.max(0.35, wid*0.018);
      c2.translate((rndLocal(20)*2-1)*0.35, (rndLocal(21)*2-1)*0.35);
      path();
      c2.stroke();

      c2.restore();

      // micro-sombra del borde (da separación sutil)
      c2.save();
      c2.globalAlpha = alpha * 0.05;
      c2.strokeStyle = 'rgba(0,0,0,0.18)';
      c2.lineWidth = Math.max(0.45, wid*0.024);
      c2.translate(0.55, 0.85);
      path();
      c2.stroke();
      c2.restore();

      // venas: menos uniformes, más orgánicas
      c2.save();
      c2.lineJoin = 'round';
      c2.lineCap  = 'round';

      // venas claras
      c2.globalAlpha = alpha * (isBack ? 0.055 : 0.090);
      c2.strokeStyle = 'rgba(255,255,255,0.22)';
      c2.lineWidth = Math.max(0.55, wid*0.040);
      const veinCount = isBack ? 6 : 9;
      for(let k=0;k<veinCount;k++){
        const t = (k - (veinCount-1)/2) / ((veinCount-1)/2);
        const o = t * wid*(0.14 + 0.05*rnd());
        const bend = (0.24 + 0.18*Math.abs(t)) * (0.8 + 0.3*rnd());
        c2.beginPath();
        c2.moveTo(o*0.06, -len*0.06);
        c2.quadraticCurveTo(o*0.65, -len*(0.36+bend*0.10), o*0.08, -len*(0.94 + 0.02*rnd()));
        c2.stroke();
      }

      // nervio central un poco más marcado
      c2.globalAlpha = alpha * (isBack ? 0.065 : 0.105);
      c2.strokeStyle = 'rgba(255,255,255,0.30)';
      c2.lineWidth = Math.max(0.65, wid*0.050);
      c2.beginPath();
      c2.moveTo(0, -len*0.04);
      c2.quadraticCurveTo(wid*0.02, -len*(0.54 + 0.06*rnd()), 0, -len*(0.98));
      c2.stroke();

      // sombras de venas (micro profundidad)
      c2.globalAlpha = alpha * (isBack ? 0.020 : 0.040);
      c2.strokeStyle = 'rgba(0,0,0,0.22)';
      c2.lineWidth = Math.max(0.55, wid*0.045);
      for(let k=0;k<4;k++){
        const o = (k-1.5) * wid*(0.16 + 0.02*rnd());
        c2.beginPath();
        c2.moveTo(o*0.10, -len*0.02);
        c2.quadraticCurveTo(o*0.55, -len*(0.34 + 0.04*rnd()), o*0.04, -len*0.92);
        c2.stroke();
      }

      c2.restore();

      // micro-fibras (textura cerosa): muy sutiles, siguen el crecimiento del pétalo
      c2.save();
      path();
      c2.clip();

      const fibN = isBack ? 6 : 10;

      // sombra de fibras (profundidad)
      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = alpha * (isBack ? 0.010 : 0.020);
      c2.strokeStyle = 'rgba(0,0,0,0.22)';
      c2.lineWidth = Math.max(0.30, wid*0.012);
      c2.lineCap = 'round';
      c2.lineJoin = 'round';

      for(let i=0;i<fibN;i++){
        const tt = (i-(fibN-1)/2) / ((fibN-1)/2);
        const x = tt * wid*(0.22 + 0.05*rndLocal(40+i));
        const bend = wid*(0.06 + 0.03*rndLocal(60+i)) * (0.8 + 0.7*Math.abs(tt));
        const yMid = -len*(0.42 + 0.07*rndLocal(80+i));
        c2.beginPath();
        c2.moveTo(x*0.10, -len*0.06);
        c2.quadraticCurveTo(x + (tt>=0?1:-1)*bend, yMid, x*0.06, -len*(0.95 + 0.02*rndLocal(100+i)));
        c2.stroke();
      }

      // luz de fibras (brillo “ceroso”)
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * (isBack ? 0.012 : 0.026);
      c2.strokeStyle = 'rgba(255,255,255,0.20)';
      c2.lineWidth = Math.max(0.25, wid*0.010);

      for(let i=0;i<fibN;i++){
        const tt = (i-(fibN-1)/2) / ((fibN-1)/2);
        const x = tt * wid*(0.20 + 0.04*rndLocal(140+i));
        const bend = wid*(0.05 + 0.03*rndLocal(160+i)) * (0.7 + 0.6*Math.abs(tt));
        const yMid = -len*(0.40 + 0.06*rndLocal(180+i));
        c2.beginPath();
        c2.moveTo(x*0.10, -len*0.08);
        c2.quadraticCurveTo(x + (tt>=0?1:-1)*bend*0.85, yMid, x*0.04, -len*(0.96 + 0.02*rndLocal(200+i)));
        c2.stroke();
      }

      c2.restore();

      // moteado: controlado, concentrado hacia el centro (realista)
      if(!isBack && alpha > 0.03){
        c2.save();
        path();
        c2.clip();

        const n = 22 + Math.floor(rnd()*10);
        for(let i=0;i<n;i++){
          const u = rnd();
          const v = rnd();
          // sesgo hacia centro y mitad superior
          const px = (u*2-1) * wid*(0.22 + 0.42*Math.pow(1-v, 1.6));
          const py = -v * len*(0.86 + 0.10*rnd());
          const pr = wid*(0.010 + 0.020*rnd()) * (0.6 + 0.8*(1-v));
          c2.globalAlpha = alpha * (0.020 + 0.030*(1-v));
          c2.fillStyle = 'rgba(255,255,255,0.22)';
          c2.beginPath();
          c2.ellipse(px, py, pr*1.2, pr, (rnd()*2-1)*0.5, 0, TAU);
          c2.fill();
        }

        // micro sombras para que no sea “purpurina”
        const n2 = 10 + Math.floor(rnd()*6);
        for(let i=0;i<n2;i++){
          const u = rnd(), v = rnd();
          const px = (u*2-1) * wid*0.40;
          const py = -v * len*0.62;
          const pr = wid*(0.010 + 0.016*rnd());
          c2.globalAlpha = alpha * 0.018;
          c2.fillStyle = 'rgba(0,0,0,0.22)';
          c2.beginPath();
          c2.arc(px, py, pr, 0, TAU);
          c2.fill();
        }

        c2.restore();
      }


      // pliegues finos (más realista, especialmente en pétalos frontales)
      if(!isBack && kind==='petal' && alpha > 0.05){
        c2.save();
        path();
        c2.clip();

        // sombra suave de pliegues
        c2.globalCompositeOperation = 'multiply';
        c2.globalAlpha = alpha * 0.028;
        c2.strokeStyle = 'rgba(0,0,0,0.20)';
        c2.lineWidth = Math.max(0.35, wid*0.016);
        c2.lineCap='round';
        c2.lineJoin='round';

        const folds = 6;
        for(let f=0; f<folds; f++){
          const tt = (f+1)/(folds+1);
          const y = -len*(0.18 + tt*0.28) * (0.95 + 0.06*rnd());
          const span = wid*(0.14 + 0.08*rnd()) * (1.05 - tt*0.6);
          const lift = len*(0.012 + 0.010*rnd()) * (1.0 - tt*0.7);
          c2.beginPath();
          c2.moveTo(-span, y);
          c2.quadraticCurveTo(0, y - lift, span, y);
          c2.stroke();
        }

        // luz mínima en esos pliegues (sensación cerosa)
        c2.globalCompositeOperation = 'screen';
        c2.globalAlpha = alpha * 0.020;
        c2.strokeStyle = 'rgba(255,255,255,0.18)';
        c2.lineWidth = Math.max(0.30, wid*0.013);

        for(let f=0; f<4; f++){
          const tt = (f+1)/5;
          const y = -len*(0.24 + tt*0.22);
          const span = wid*(0.12 + 0.06*rnd());
          const lift = len*(0.010 + 0.008*rnd());
          c2.beginPath();
          c2.moveTo(-span, y);
          c2.quadraticCurveTo(0, y - lift, span, y);
          c2.stroke();
        }

        c2.restore();
      }


      c2.restore();
    };

    const drawLip = (alpha)=>{
      if(alpha <= 0) return;

      const len = h*(0.84 + 0.16*op);
      const wid = w*(0.62 + 0.14*rnd());
      const centerDrop = 1.08 + 0.04*Math.sin(rnd()*TAU);

      const lipPath = ()=>{
        // 3 lóbulos (central más largo)
        c2.beginPath();
        c2.moveTo(0, 0);
        // lóbulo derecho
        c2.bezierCurveTo( wid*0.72, len*0.10,  wid*0.92, len*0.50,  wid*0.18, len*0.92);
        // lóbulo central (cae un poco más)
        c2.quadraticCurveTo(0, len*centerDrop, -wid*0.18, len*0.92);
        // lóbulo izquierdo
        c2.bezierCurveTo(-wid*0.92, len*0.50, -wid*0.72, len*0.10, 0, 0);
        c2.closePath();
      };

      c2.save();
      c2.translate(0, centerY + h*0.13);
      c2.rotate(0.05*(rnd()*2-1));

      // sombra del labelo (profundidad)
      c2.save();
      c2.globalAlpha = alpha * 0.15;
      c2.fillStyle = rgba(0,0,0,0.24);
      c2.translate(0.8, 1.2);
      lipPath();
      c2.fill();
      c2.restore();

      // relleno (gradiente)
      const g = c2.createLinearGradient(0, 0, 0, len);
      g.addColorStop(0,   rgba(lipDeep.r,lipDeep.g,lipDeep.b, 0.70));
      g.addColorStop(0.32,rgba(throatDeep.r,throatDeep.g,throatDeep.b, 0.92));
      g.addColorStop(0.72,rgba(lipCol.r,lipCol.g,lipCol.b,  0.98));
      g.addColorStop(1,   rgba(255,255,255,               0.94));

      c2.globalAlpha = alpha;
      c2.fillStyle = g;
      lipPath();
      c2.fill();

      // garganta más definida (blanco rosado)
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * 0.16;
      const th = c2.createRadialGradient(0, len*0.18, 0, 0, len*0.22, Math.max(22, wid*0.50));
      th.addColorStop(0, rgba(throat.r, throat.g, throat.b, 0.38));
      th.addColorStop(0.55, 'rgba(255,255,255,0.10)');
      th.addColorStop(1, 'rgba(255,255,255,0)');
      c2.fillStyle = th;
      c2.beginPath();
      c2.ellipse(0, len*0.22, wid*0.24, len*0.22, 0, 0, TAU);
      c2.fill();
      c2.restore();

      // ruffles/borde ondulado (más natural)
      c2.save();
      c2.globalAlpha = alpha * 0.24;
      c2.strokeStyle = 'rgba(255,255,255,0.38)';
      c2.lineWidth = Math.max(0.9, wid*0.055);
      c2.lineJoin = 'round';
      c2.lineCap  = 'round';
      c2.beginPath();
      const steps = 12;
      for(let i=0;i<=steps;i++){
        const tt = i/steps;
        const xx = (tt*2-1) * wid*0.25;
        const wob = Math.sin(tt*TAU*1.25 + 1.2) * wid*0.020;
        const yy = len*(0.84 + 0.14*Math.sin(tt*TAU*1.02)) + wob;
        if(i===0) c2.moveTo(xx, yy);
        else c2.lineTo(xx, yy);
      }
      c2.stroke();
      c2.restore();

      // pliegues internos (ridges)
      c2.save();
      c2.globalAlpha = alpha * 0.10;
      c2.strokeStyle = 'rgba(255,255,255,0.22)';
      c2.lineWidth = Math.max(0.65, wid*0.028);
      c2.lineCap = 'round';
      for(let i=0;i<6;i++){
        const tt = (i-2.5)/2.5;
        const xx = tt * wid*0.10;
        c2.beginPath();
        c2.moveTo(xx, len*0.12);
        c2.quadraticCurveTo(xx*0.60, len*0.44, xx*0.10, len*0.92);
        c2.stroke();
      }
      c2.restore();

      // moteado del labelo (muy leve)
      c2.save();
      lipPath();
      c2.clip();
      const dots = 16 + Math.floor(rnd()*10);
      for(let i=0;i<dots;i++){
        const u = rnd(), v = rnd();
        const px = (u*2-1) * wid*(0.20 + 0.18*(1-v));
        const py = len*(0.16 + v*0.70);
        const pr = wid*(0.010 + 0.018*rnd());
        c2.globalAlpha = alpha * (0.018 + 0.028*(1-v));
        c2.fillStyle = 'rgba(255,255,255,0.22)';
        c2.beginPath();
        c2.arc(px, py, pr, 0, TAU);
        c2.fill();
      }
      c2.restore();

      c2.restore();
    };

    const drawColumn = (alpha)=>{
      if(alpha <= 0) return;

      c2.save();
      c2.translate(0, centerY + h*0.02);
      c2.rotate(0.06*(rnd()*2-1));

      // cuerpo (cilindro) con gradiente
      const cg = c2.createLinearGradient(-w*0.06, -h*0.10, w*0.06, h*0.08);
      cg.addColorStop(0, 'rgba(255,255,255,0.06)');
      cg.addColorStop(0.45,'rgba(255,255,255,0.16)');
      cg.addColorStop(1, 'rgba(0,0,0,0.10)');

      c2.globalAlpha = alpha * 0.72;
      c2.fillStyle = cg;
      c2.beginPath();
      c2.ellipse(0, -h*0.05, w*0.09, h*0.13, 0, 0, TAU);
      c2.fill();

      // contorno
      c2.globalAlpha = alpha * 0.22;
      c2.strokeStyle = 'rgba(255,255,255,0.26)';
      c2.lineWidth = Math.max(0.9, w*0.020);
      c2.beginPath();
      c2.ellipse(0, -h*0.05, w*0.09, h*0.13, 0, 0, TAU);
      c2.stroke();

      // “capucha” superior (antera)
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * 0.14;
      c2.fillStyle = rgba(throat.r, throat.g, throat.b, 0.22);
      c2.beginPath();
      c2.ellipse(0, -h*0.11, w*0.05, h*0.05, 0, 0, TAU);
      c2.fill();
      c2.restore();

      // sombra proyectada mínima sobre el labelo
      c2.save();
      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = alpha * 0.08;
      c2.fillStyle = 'rgba(0,0,0,0.22)';
      c2.beginPath();
      c2.ellipse(0, h*0.06, w*0.10, h*0.06, 0, 0, TAU);
      c2.fill();
      c2.restore();

      c2.restore();
    };

    // ===== Orden de capas (back -> front) =====
    // Sépalos (atrás)
    const a0 = stage(0);
    const a1 = stage(1);
    const a2 = stage(2);
    const sepalLen = h*(0.98 + 0.08*rnd());
    const sepalWid = w*(0.50 + 0.08*rnd());

    drawPetal( 0.00 + (rnd()*0.06-0.03), sepalLen*0.96, sepalWid*0.92, 0.70*a0, 0.14,  0.00, true, 'dorsal');
    drawPetal( 0.98 + (rnd()*0.08-0.04), sepalLen*0.92, sepalWid*0.94, 0.62*a1, 0.14,  0.02, true, 'sepal');
    drawPetal(-0.98 + (rnd()*0.08-0.04), sepalLen*0.92, sepalWid*0.94, 0.62*a2, 0.14, -0.02, true, 'sepal');

    // Pétalos (frente)
    const a3 = stage(3);
    const a4 = stage(4);
    const petLen = h*(0.96 + 0.12*rnd());
    const petWid = w*(0.56 + 0.12*rnd());
    drawPetal( 0.42 + (rnd()*0.08-0.04), petLen, petWid, 0.82*a3, 0.14,  0.03, false, 'petal');
    drawPetal(-0.42 + (rnd()*0.08-0.04), petLen, petWid, 0.82*a4, 0.14, -0.03, false, 'petal');

    // Labelo + columna
    const a5 = stage(5);
    drawLip(0.92*a5);
    drawColumn(0.90*a5);

    // Oclusión/centro (da “profundidad” de flor real)
    c2.save();
    c2.globalCompositeOperation = 'multiply';
    c2.globalAlpha = 0.07 * appear;
    const occ = c2.createRadialGradient(0, centerY + h*0.05, 0, 0, centerY + h*0.05, Math.max(18, w*0.62));
    occ.addColorStop(0, 'rgba(0,0,0,0.24)');
    occ.addColorStop(0.58,'rgba(0,0,0,0.10)');
    occ.addColorStop(1, 'rgba(0,0,0,0)');
    c2.fillStyle = occ;
    c2.beginPath();
    c2.ellipse(0, centerY + h*0.04, w*0.48, h*0.34, 0, 0, TAU);
    c2.fill();
    c2.restore();

    // brillo final (muy suave) para “volumen” general
    c2.save();
    c2.globalCompositeOperation = 'screen';
    c2.globalAlpha = 0.052 * appear;
    const gh = c2.createRadialGradient(0, centerY - h*0.22, 0, 0, centerY - h*0.22, Math.max(18, w*0.86));
    gh.addColorStop(0, 'rgba(255,255,255,0.16)');
    gh.addColorStop(0.55,'rgba(255,255,255,0.06)');
    gh.addColorStop(1, 'rgba(255,255,255,0)');
    c2.fillStyle = gh;
    c2.beginPath();
    c2.ellipse(0, centerY - h*0.18, w*0.62, h*0.60, 0, 0, TAU);
    c2.fill();
    c2.restore();
  }

function renderTulipBloomSprite(c2, w, h, col, seed, open, petalsVisible){
    // Gerbera mejorada (v3):
    // - Capa “back” para profundidad (pétalos detrás)
    // - Pétalos con ligera curvatura (shear), estrías y highlight de punta
    // - Centro con “florets” tubulares alrededor del disco + polen más denso
    // Renderizado a sprite (cache) para que el costo no se coma la animación.

    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const pv = clamp((petalsVisible==null?6:petalsVisible), 0, 6); // float
    const appear = pv / 6; // 0..1
    const op = clamp(open==null?1:open, 0, 1);

    const mix = (a,b,t)=>({
      r: Math.round(lerp(a.r,b.r,t)),
      g: Math.round(lerp(a.g,b.g,t)),
      b: Math.round(lerp(a.b,b.b,t))
    });

    // Paleta del pétalo (base -> cuerpo -> punta)
    const lite = mix(col, {r:255,g:255,b:255}, 0.50);
    const mid  = mix(col, {r:255,g:248,b:236}, 0.24);
    const deep = mix(col, {r:60,g:18,b:8},      0.62);
    const edge = mix(col, {r:255,g:252,b:245},  0.18);

    const centerY = -h*0.62;

    // Sombra global (da “cuerpo” a la cabeza)
    c2.save();
    c2.globalAlpha = 0.20;
    c2.fillStyle = rgba(0,0,0,0.18);
    c2.beginPath();
    c2.ellipse(0, centerY + h*0.34, w*1.05, h*0.52, 0, 0, TAU);
    c2.fill();
    c2.restore();

    // Halo suave
    c2.save();
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.11;
    const haloR = Math.max(w*1.45, h*1.10);
    const halo = c2.createRadialGradient(0, centerY, 8, 0, centerY, haloR);
    halo.addColorStop(0, rgba(col.r,col.g,col.b,0.22));
    halo.addColorStop(0.55, rgba(col.r,col.g,col.b,0.07));
    halo.addColorStop(1, rgba(col.r,col.g,col.b,0));
    c2.fillStyle = halo;
    c2.beginPath();
    c2.ellipse(0, centerY, w*1.18, h*1.08, 0, 0, TAU);
    c2.fill();
    c2.restore();

    // Aparición escalonada por pétalo
    const petalStage = (i, total) => {
      const j = (Math.sin((seed*0.0009 + i*12.345) * 1.73) * 0.5 + 0.5) * 0.92;
      const threshold = (i + j) / total;
      const x = (appear - threshold) * 3.1 + 0.25;
      return clamp(x, 0, 1);
    };

    const drawPetal = (ang, len, wid, alpha, shade, bend, tint, curl) => {
      c2.save();
      c2.translate(0, centerY);
      c2.rotate(ang);
      c2.rotate(bend);

      // Curvatura ligera (como “cucharita”)
      c2.transform(1, 0, curl, 1, 0, 0);

      const tipY = -len;

      // sombra suave detrás (profundidad)
      c2.save();
      c2.globalAlpha = alpha * 0.14;
      c2.fillStyle = rgba(0,0,0,0.26);
      c2.beginPath();
      c2.moveTo(0, 0);
      c2.quadraticCurveTo( wid*0.92, -len*0.62, 0, tipY);
      c2.quadraticCurveTo(-wid*0.92, -len*0.62, 0, 0);
      c2.closePath();
      c2.translate(0.7, 1.2);
      c2.fill();
      c2.restore();

      // degradado principal del pétalo
      const g = c2.createLinearGradient(0, 0, 0, tipY);
      const base = mix(deep, col, 0.22 + 0.22*tint);
      const body = mix(col,  mid, 0.18 + 0.18*tint);
      const tip  = mix(lite, {r:255,g:255,b:255}, 0.10 + 0.10*tint);

      g.addColorStop(0,    rgba(base.r,base.g,base.b, 0.52*shade));
      g.addColorStop(0.25, rgba(col.r,col.g,col.b,    0.98*shade));
      g.addColorStop(0.68, rgba(body.r,body.g,body.b, 0.98*shade));
      g.addColorStop(1,    rgba(tip.r,tip.g,tip.b,    0.98*shade));

      c2.globalAlpha = alpha;
      c2.fillStyle = g;

      // Forma: punta redondeada
      const ctrlY = -len*0.64;
      const ctrlX = wid*(0.96 + rnd()*0.14);
      const cap   = wid*(0.18 + 0.08*rnd());

      c2.beginPath();
      c2.moveTo(0, 0);
      c2.bezierCurveTo( ctrlX, ctrlY,  ctrlX*0.55, tipY*0.90,  cap, tipY);
      c2.quadraticCurveTo(0, tipY - wid*0.05, -cap, tipY);
      c2.bezierCurveTo(-ctrlX*0.55, tipY*0.90, -ctrlX, ctrlY, 0, 0);
      c2.closePath();
      c2.fill();

      // highlight de borde
      c2.globalAlpha = alpha * 0.18;
      c2.strokeStyle = rgba(edge.r,edge.g,edge.b, 0.95);
      c2.lineWidth = Math.max(0.8, wid*0.10);
      c2.lineJoin = 'round';
      c2.lineCap  = 'round';
      c2.beginPath();
      c2.moveTo(0, 0);
      c2.quadraticCurveTo(ctrlX*0.85, ctrlY*0.98, cap*0.35, tipY);
      c2.stroke();

      // Estrías (textura del pétalo)
      c2.save();
      c2.globalAlpha = alpha * 0.06;
      c2.strokeStyle = 'rgba(255,255,255,0.22)';
      c2.lineWidth = Math.max(0.7, wid*0.05);
      for(let k=0;k<3;k++){
        const o = (k-1) * wid*0.18;
        c2.beginPath();
        c2.moveTo(o*0.12, -len*0.06);
        c2.quadraticCurveTo(o*0.55, -len*0.44, o*0.06, tipY*0.92);
        c2.stroke();
      }
      c2.restore();

      // Vena central (detalle suave)
      c2.save();
      c2.globalAlpha = alpha * 0.06;
      c2.strokeStyle = 'rgba(255,255,255,0.28)';
      c2.lineWidth = Math.max(0.7, wid*0.05);
      c2.beginPath();
      c2.moveTo(0, -len*0.04);
      c2.quadraticCurveTo(wid*0.10, -len*0.46, 0, tipY*0.92);
      c2.stroke();
      c2.restore();

      // Sombra de vena (lado opuesto)
      c2.save();
      c2.globalAlpha = alpha * 0.04;
      c2.strokeStyle = 'rgba(0,0,0,0.20)';
      c2.lineWidth = Math.max(0.7, wid*0.05);
      c2.beginPath();
      c2.moveTo(-wid*0.06, -len*0.06);
      c2.quadraticCurveTo(-wid*0.12, -len*0.52, -wid*0.03, tipY*0.90);
      c2.stroke();
      c2.restore();

      // Highlight de punta
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * 0.09;
      c2.fillStyle = 'rgba(255,255,255,0.20)';
      c2.beginPath();
      c2.ellipse(0, tipY + wid*0.10, wid*0.40, wid*0.18, 0, 0, TAU);
      c2.fill();
      c2.restore();

      // sombra lateral (para “tubo”)
      c2.globalAlpha = alpha * 0.07;
      c2.strokeStyle = 'rgba(0,0,0,0.22)';
      c2.lineWidth = Math.max(0.7, wid*0.06);
      c2.beginPath();
      c2.moveTo(0, 0);
      c2.quadraticCurveTo(-ctrlX*0.75, ctrlY*0.95, -cap*0.35, tipY);
      c2.stroke();

      c2.restore();
    };

    // Capas
    const totalOuter = 42 + (rnd()*11|0); // 42..52
    const totalMid   = Math.round(totalOuter * 0.78);
    const totalInner = Math.round(totalOuter * 0.56);
    const totalBack  = Math.round(totalOuter * 0.62);
    const totalCrown = 20 + (rnd()*7|0); // 20..26

    const baseOuterLen = h*(0.86 + 0.06*rnd()) * (0.70 + 0.30*op);
    const baseOuterWid = w*(0.124 + 0.018*rnd());

    const baseMidLen   = h*(0.67 + 0.05*rnd()) * (0.70 + 0.30*op);
    const baseMidWid   = w*(0.104 + 0.016*rnd());

    const baseInLen    = h*(0.50 + 0.04*rnd()) * (0.70 + 0.30*op);
    const baseInWid    = w*(0.082 + 0.012*rnd());

    const baseCrLen    = h*(0.30 + 0.03*rnd()) * (0.75 + 0.25*op);
    const baseCrWid    = w*(0.072 + 0.011*rnd());

    // Back layer (pétalos detrás)
    for(let i=0;i<totalBack;i++){
      const st = petalStage(i, totalBack);
      if(st <= 0) continue;

      const ang  = (i/totalBack)*TAU + (rnd()*0.08 - 0.04) + 0.02;
      const bend = (rnd()*0.22 - 0.11);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.26 - 0.13) * (0.45 + 0.55*st);

      const len = baseOuterLen*(1.02 + 0.18*rnd()) * (0.35 + 0.65*st);
      const wid = baseOuterWid*(1.05 + 0.45*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.30*st, 0.82, bend, tint, curl);
    }

    // Outer
    for(let i=0;i<totalOuter;i++){
      const st = petalStage(i, totalOuter);
      if(st <= 0) continue;

      const ang  = (i/totalOuter)*TAU + (rnd()*0.08 - 0.04);
      const bend = (rnd()*0.18 - 0.09);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.22 - 0.11) * (0.45 + 0.55*st);

      const len = baseOuterLen*(0.86 + 0.24*rnd()) * (0.35 + 0.65*st);
      const wid = baseOuterWid*(0.78 + 0.36*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.95*st, 0.92, bend, tint, curl);
    }

    // Mid
    for(let i=0;i<totalMid;i++){
      const st = petalStage(i, totalMid);
      if(st <= 0) continue;

      const ang  = (i/totalMid)*TAU + (rnd()*0.08 - 0.04) + 0.05;
      const bend = (rnd()*0.14 - 0.07);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.18 - 0.09) * (0.45 + 0.55*st);

      const len = baseMidLen*(0.86 + 0.22*rnd()) * (0.35 + 0.65*st);
      const wid = baseMidWid*(0.78 + 0.34*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.80*st, 0.98, bend, tint, curl);
    }

    // Inner rays
    for(let i=0;i<totalInner;i++){
      const st = petalStage(i, totalInner);
      if(st <= 0) continue;

      const ang  = (i/totalInner)*TAU + (rnd()*0.08 - 0.04) - 0.03;
      const bend = (rnd()*0.12 - 0.06);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.16 - 0.08) * (0.45 + 0.55*st);

      const len = baseInLen*(0.88 + 0.18*rnd()) * (0.35 + 0.65*st);
      const wid = baseInWid*(0.82 + 0.30*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.64*st, 1.00, bend, tint, curl);
    }

    // Corona interna (pétalos cortos)
    const crownAppear = clamp((appear - 0.30) * 1.6, 0, 1);
    if(crownAppear > 0){
      const crownCol  = mix(col, {r:255,g:246,b:230}, 0.38);
      const crownLite = mix(crownCol, {r:255,g:255,b:255}, 0.58);
      const crownDeep = mix(crownCol, {r:40,g:20,b:30}, 0.46);

      for(let i=0;i<totalCrown;i++){
        const st = petalStage(i, totalCrown) * crownAppear;
        if(st <= 0) continue;

        const ang  = (i/totalCrown)*TAU + (rnd()*0.08 - 0.04);
        const bend = (rnd()*0.10 - 0.05);

        c2.save();
        c2.translate(0, centerY);
        c2.rotate(ang);
        c2.rotate(bend);

        const len = baseCrLen*(0.90 + 0.22*rnd()) * (0.45 + 0.55*st);
        const wid = baseCrWid*(0.85 + 0.32*rnd()) * (0.55 + 0.45*st);
        const tipY = -len;

        const gg = c2.createLinearGradient(0, 0, 0, tipY);
        gg.addColorStop(0, rgba(crownDeep.r,crownDeep.g,crownDeep.b, 0.42));
        gg.addColorStop(0.40, rgba(crownCol.r,crownCol.g,crownCol.b, 0.85));
        gg.addColorStop(1, rgba(crownLite.r,crownLite.g,crownLite.b, 0.95));

        c2.globalAlpha = 0.58 * st;
        c2.fillStyle = gg;

        const ctrlX = wid*(0.95 + rnd()*0.12);
        const ctrlY = -len*0.62;
        const cap = wid*(0.22 + 0.06*rnd());

        c2.beginPath();
        c2.moveTo(0, 0);
        c2.bezierCurveTo( ctrlX, ctrlY,  ctrlX*0.55, tipY*0.90,  cap, tipY);
        c2.quadraticCurveTo(0, tipY - wid*0.04, -cap, tipY);
        c2.bezierCurveTo(-ctrlX*0.55, tipY*0.90, -ctrlX, ctrlY, 0, 0);
        c2.closePath();
        c2.fill();

        c2.restore();
      }
    }

    // Centro (disco) + florets tubulares
    const discR = w*(0.235 + 0.02*rnd());
    const discGrow = (0.25 + 0.75*clamp(appear*1.25, 0, 1));

    // Oclusión donde nacen pétalos (profundidad alrededor del disco)
    c2.save();
    c2.globalCompositeOperation = 'multiply';
    c2.globalAlpha = 0.22 * discGrow;
    const occ = c2.createRadialGradient(0, centerY, discR*0.35, 0, centerY, discR*1.55);
    occ.addColorStop(0, 'rgba(0,0,0,0)');
    occ.addColorStop(0.55, 'rgba(0,0,0,0.32)');
    occ.addColorStop(1, 'rgba(0,0,0,0)');
    c2.fillStyle = occ;
    c2.beginPath();
    c2.arc(0, centerY, discR*1.65, 0, TAU);
    c2.fill();
    c2.restore();

    // Sombra de “cuenco”
    c2.save();
    c2.globalAlpha = 0.18 * discGrow;
    c2.fillStyle = 'rgba(0,0,0,0.28)';
    c2.beginPath();
    c2.ellipse(0, centerY + discR*0.10, discR*1.30*discGrow, discR*0.92*discGrow, 0, 0, TAU);
    c2.fill();
    c2.restore();

    const core = c2.createRadialGradient(0, centerY, discR*0.10, 0, centerY, discR*1.50);
    core.addColorStop(0,   rgba(255, 246, 190, 0.98));
    core.addColorStop(0.45,rgba(245, 205, 120, 0.98));
    core.addColorStop(0.78,rgba(195, 110,  55, 0.96));
    core.addColorStop(1,   rgba(105,  55,  32, 0.96));

    c2.save();
    c2.globalAlpha = 0.26 + 0.76*discGrow;
    c2.fillStyle = core;
    c2.beginPath();
    c2.ellipse(0, centerY, discR*1.10*discGrow, discR*1.00*discGrow, rnd()*0.8, 0, TAU);
    c2.fill();

    // anillo exterior
    c2.globalAlpha *= 0.70;
    c2.strokeStyle = rgba(255, 238, 175, 0.45);
    c2.lineWidth = Math.max(0.9, discR*0.11);
    c2.beginPath();
    c2.ellipse(0, centerY, discR*1.07*discGrow, discR*0.94*discGrow, 0, 0, TAU);
    c2.stroke();

    // Textura de celdas (súper sutil) dentro del disco
    c2.save();
    c2.beginPath();
    c2.ellipse(0, centerY, discR*1.12*discGrow, discR*1.02*discGrow, 0, 0, TAU);
    c2.clip();
    const cells = 56;
    for(let i=0;i<cells;i++){
      const a = rnd()*TAU;
      const rr = Math.sqrt(rnd())*discR*1.02*discGrow;
      const x = Math.cos(a)*rr*0.78;
      const y = centerY + Math.sin(a)*rr*0.58;
      const r1 = discR*(0.020 + 0.018*rnd())*discGrow;

      c2.globalAlpha = 0.06 + 0.05*rnd();
      c2.fillStyle = 'rgba(0,0,0,0.35)';
      c2.beginPath(); c2.arc(x, y, r1, 0, TAU); c2.fill();

      c2.globalAlpha *= 0.55;
      c2.fillStyle = 'rgba(255,255,255,0.22)';
      c2.beginPath(); c2.arc(x - r1*0.25, y - r1*0.25, r1*0.55, 0, TAU); c2.fill();
    }
    c2.restore();

    // Florets tubulares (transición pétalo-centro)
    const florets = 44;
    for(let i=0;i<florets;i++){
      const a = (i/florets)*TAU + rnd()*0.08;
      const rr = discR*(1.08 + 0.06*rnd())*discGrow;
      const x = Math.cos(a)*rr*0.80;
      const y = centerY + Math.sin(a)*rr*0.58;

      c2.save();
      c2.translate(x, y);
      c2.rotate(a + Math.PI*0.5);

      const L = discR*(0.20 + 0.10*rnd())*discGrow;
      const Wd = discR*(0.07 + 0.03*rnd())*discGrow;

      const gg = c2.createLinearGradient(0, 0, 0, -L);
      gg.addColorStop(0, 'rgba(85,45,26,0.75)');
      gg.addColorStop(0.55, 'rgba(210,125,70,0.80)');
      gg.addColorStop(1, 'rgba(255,230,150,0.78)');

      c2.globalAlpha = 0.26 + 0.34*rnd();
      c2.fillStyle = gg;
      // Cuerpo tipo “cápsula”
      c2.beginPath();
      c2.ellipse(0, -L*0.55, Wd*0.55, L*0.55, 0, 0, TAU);
      c2.fill();

      // puntito brillante
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha *= 0.30;
      c2.fillStyle = 'rgba(255,255,255,0.18)';
      c2.beginPath();
      c2.ellipse(0, -L*0.85, Wd*0.35, Wd*0.26, 0, 0, TAU);
      c2.fill();

      c2.restore();
    }

    // Florets internos (más pequeños) para densidad
    const florets2 = 28;
    for(let i=0;i<florets2;i++){
      const a = (i/florets2)*TAU + rnd()*0.10 + 0.02;
      const rr = discR*(0.70 + 0.08*rnd())*discGrow;
      const x = Math.cos(a)*rr*0.74;
      const y = centerY + Math.sin(a)*rr*0.52;

      c2.save();
      c2.translate(x, y);
      c2.rotate(a + Math.PI*0.5);

      const L = discR*(0.16 + 0.08*rnd())*discGrow;
      const Wd = discR*(0.055 + 0.025*rnd())*discGrow;

      const gg = c2.createLinearGradient(0, 0, 0, -L);
      gg.addColorStop(0, 'rgba(70,34,22,0.70)');
      gg.addColorStop(0.55, 'rgba(190,110,62,0.78)');
      gg.addColorStop(1, 'rgba(255,228,145,0.70)');

      c2.globalAlpha = 0.18 + 0.26*rnd();
      c2.fillStyle = gg;
      c2.beginPath();
      c2.ellipse(0, -L*0.55, Wd*0.55, L*0.55, 0, 0, TAU);
      c2.fill();

      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha *= 0.26;
      c2.fillStyle = 'rgba(255,255,255,0.16)';
      c2.beginPath();
      c2.ellipse(0, -L*0.85, Wd*0.33, Wd*0.24, 0, 0, TAU);
      c2.fill();

      c2.restore();
    }

    // Polen: espiral + granos
    c2.globalAlpha *= 0.78;
    const grains = 150;
    for(let k=0;k<grains;k++){
      const t = (k/(grains-1));
      const a = t*TAU*2.25 + rnd()*0.25;
      const rr = discR*(0.12 + 0.82*t)*discGrow;
      const x = Math.cos(a)*rr*0.78;
      const y = centerY + Math.sin(a)*rr*0.60;

      const r0 = discR*(0.010 + 0.020*rnd())*discGrow;
      const dark = 0.26 + 0.32*rnd();
      c2.fillStyle = rgba(70, 35, 22, dark);
      c2.beginPath();
      c2.ellipse(x, y, r0*1.25, r0, rnd()*TAU, 0, TAU);
      c2.fill();

      // chispas doradas ocasionales
      if(k%7===0){
        c2.save();
        c2.globalCompositeOperation = 'screen';
        c2.globalAlpha = 0.06 + 0.06*rnd();
        c2.fillStyle = 'rgba(255,220,140,0.22)';
        c2.beginPath();
        c2.arc(x + r0*0.15, y - r0*0.15, r0*(0.55 + 0.45*rnd()), 0, TAU);
        c2.fill();
        c2.restore();
      }

      if(k%4===0){
        c2.globalCompositeOperation = 'screen';
        c2.fillStyle = 'rgba(255,255,255,0.08)';
        c2.beginPath();
        c2.arc(x - r0*0.2, y - r0*0.2, r0*0.55, 0, TAU);
        c2.fill();
        c2.globalCompositeOperation = 'source-over';
      }
    }

    // brillo suave del centro
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.10;
    const shine = c2.createRadialGradient(0, centerY - discR*0.15, 0, 0, centerY - discR*0.15, discR*2.4);
    shine.addColorStop(0, 'rgba(255,255,255,0.18)');
    shine.addColorStop(1, 'rgba(255,255,255,0)');
    c2.fillStyle = shine;
    c2.beginPath();
    c2.arc(0, centerY - discR*0.15, discR*2.10, 0, TAU);
    c2.fill();

    c2.restore();

    // sombra mínima para “anclar” la cabeza al tallo
    c2.save();
    c2.globalAlpha = 0.18;
    c2.fillStyle = rgba(0,0,0,0.16);
    c2.beginPath();
    c2.ellipse(0, h*0.02, w*0.32, h*0.12, 0, 0, TAU);
    c2.fill();
    c2.restore();
  }





  function drawTulipBloom(w, h, col, seed, open, petalsVisible){
    const spr = getBloomSprite(w, h, col, seed, open, petalsVisible);
    ctx.drawImage(
      spr.canvas,
      -spr.ox,
      -spr.oy,
      spr.canvas.width / spr.ss,
      spr.canvas.height / spr.ss
    );
  }
  function drawBouquetWrap(cx, cy, s){
    // Opción 1: Cono de papel clásico (crema/blanco) con borde doblado y sombras suaves.
    // Se dibuja DESPUÉS de tallos y ANTES de flores para tapar tallos y dejar cabezas libres.
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(s, s);

    // Sombra base
    ctx.save();
    ctx.globalAlpha *= 0.55;
    const sh = ctx.createRadialGradient(0, 32, 12, 0, 32, 230);
    sh.addColorStop(0, 'rgba(0,0,0,0.20)');
    sh.addColorStop(0.55, 'rgba(0,0,0,0.09)');
    sh.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = sh;
    ctx.beginPath();
    ctx.ellipse(0, 36, 204, 62, 0, 0, TAU);
    ctx.fill();
    ctx.restore();

    // Paleta “papel”
    const C0 = {r:236, g:232, b:220}; // crema base
    const C1 = {r:250, g:248, b:242}; // highlight
    const C2 = {r:206, g:198, b:182}; // sombra suave
    const edge = {r:255, g:255, b:255};

    // PRNG fijo para textura
    let s0 = 0xC0FFEE;
    const rnd = () => (s0 = (s0 * 1664525 + 1013904223) >>> 0, s0 / 4294967296);

    // Geometría del envoltorio
    const TOP = -285;
    const BOT =  96;
    const WID =  182;

    const conePath = (W, topLift=0) => {
      // Forma tipo cono/papel doblado
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-0.98*W, -170, -0.92*W, -300, -0.28*W, TOP+topLift);
      ctx.bezierCurveTo( 0.10*W, TOP-22+topLift,  1.02*W, -260,  0.84*W, -70);
      ctx.bezierCurveTo( 0.66*W,  56,   0.24*W,  60,    0, 0);
      ctx.closePath();
    };

    const paperPanel = (rot, flip, alpha, widen, lift, warmTint) => {
      ctx.save();
      ctx.rotate(rot);
      ctx.scale(flip, 1);
      ctx.translate(0, lift);

      const W = WID*widen;

      // Gradiente del papel (más claro arriba)
      const g = ctx.createLinearGradient(-W*0.60, BOT*0.35, W*0.40, TOP*0.70);
      g.addColorStop(0, rgba(C2.r, C2.g, C2.b, 0.82));
      g.addColorStop(0.45, rgba(C0.r, C0.g, C0.b, 0.92));
      g.addColorStop(1, rgba(C1.r, C1.g, C1.b, 0.98));

      ctx.globalAlpha *= alpha;
      ctx.fillStyle = g;
      ctx.shadowColor = 'rgba(0,0,0,0.24)';
      ctx.shadowBlur = 18;

      conePath(W, 0);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Borde doblado (boca del papel): una banda superior con sombra interior
      ctx.save();
      // Trazo oscuro (sombra interior)
      ctx.globalAlpha *= 0.55;
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      ctx.moveTo(-0.24*W, TOP+2);
      ctx.quadraticCurveTo(0, TOP-18, 0.24*W, TOP+2);
      ctx.stroke();

      // Banda clara del doblez
      const lip = ctx.createLinearGradient(0, TOP-24, 0, TOP+26);
      lip.addColorStop(0, 'rgba(255,255,255,0.68)');
      lip.addColorStop(0.55, 'rgba(248,246,240,0.42)');
      lip.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.globalAlpha *= 0.75;
      ctx.fillStyle = lip;
      ctx.beginPath();
      ctx.moveTo(-0.26*W, TOP+4);
      ctx.quadraticCurveTo(0, TOP-20, 0.26*W, TOP+4);
      ctx.quadraticCurveTo(0, TOP+20, -0.26*W, TOP+4);
      ctx.closePath();
      ctx.fill();

      // Highlight del borde
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha *= 0.35;
      ctx.strokeStyle = rgba(edge.r, edge.g, edge.b, 0.30);
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.moveTo(-0.22*W, TOP+3);
      ctx.quadraticCurveTo(0, TOP-16, 0.22*W, TOP+3);
      ctx.stroke();
      ctx.restore();

      // Pliegues suaves (poco, para que no se vea “cartón”)
      ctx.save();
      ctx.globalAlpha *= 0.18;
      ctx.strokeStyle = 'rgba(255,255,255,0.20)';
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(-0.08*W, -40);
      ctx.quadraticCurveTo(0.20*W, -190, 0.02*W, TOP+14);
      ctx.stroke();

      ctx.globalAlpha *= 0.90;
      ctx.strokeStyle = 'rgba(0,0,0,0.10)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(0.14*W, -70);
      ctx.quadraticCurveTo(0.38*W, -210, 0.16*W, TOP+32);
      ctx.stroke();
      ctx.restore();

      // Textura “papel”: puntitos y fibras (muy sutil)
      ctx.save();
      ctx.globalAlpha *= 0.07;
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      for(let i=0;i<28;i++){
        const x = (rnd()*2-1) * W*0.62;
        const y = TOP + rnd()*(BOT-TOP)*0.92;
        const r = 0.7 + rnd()*1.4;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, TAU);
        ctx.fill();
      }
      // fibras: trazos muy cortos
      ctx.globalAlpha *= 0.65;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1.0;
      for(let i=0;i<16;i++){
        const x = (rnd()*2-1) * W*0.58;
        const y = TOP + rnd()*(BOT-TOP)*0.90;
        const a = rnd()*TAU;
        const L = 6 + rnd()*10;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(a)*L, y + Math.sin(a)*L*0.5);
        ctx.stroke();
      }
      ctx.restore();

      // Tint cálido leve si se pide (para paneles laterales)
      if(warmTint){
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha *= 0.10;
        ctx.fillStyle = 'rgba(255,235,210,0.7)';
        conePath(W, 0);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    };

    // Paneles del cono (back -> front)
    paperPanel( 0.00,  1, 0.94, 1.18, 0, false);   // trasero
    paperPanel(-0.30,  1, 0.96, 1.08, 8, true);    // izquierdo
    paperPanel( 0.32, -1, 0.96, 1.08, 8, true);    // derecho
    paperPanel( 0.08,  1, 0.90, 0.98, 12, false);  // frontal

    // Banda central muy sutil (para “unir”)
    ctx.save();
    ctx.globalAlpha *= 0.22;
    const band = ctx.createLinearGradient(0, TOP, 0, 40);
    band.addColorStop(0, 'rgba(255,255,255,0.22)');
    band.addColorStop(0.5, 'rgba(240,236,226,0.10)');
    band.addColorStop(1, 'rgba(0,0,0,0.00)');
    ctx.fillStyle = band;
    ctx.beginPath();
    ctx.moveTo(-164, 14);
    ctx.quadraticCurveTo(0, -12, 164, 14);
    ctx.lineTo(130, TOP+12);
    ctx.quadraticCurveTo(0, TOP-30, -130, TOP+12);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Listón (mantener el contraste con el papel claro)
    ctx.save();
    ctx.translate(0, 18);

    const rib = ctx.createLinearGradient(-112, 0, 112, 0);
    rib.addColorStop(0, 'rgba(22,7,14,0.62)');
    rib.addColorStop(0.5, 'rgba(118,34,58,0.56)');
    rib.addColorStop(1, 'rgba(14,6,12,0.62)');

    ctx.fillStyle = rib;
    ctx.shadowColor = 'rgba(0,0,0,0.34)';
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(-114, -12);
    ctx.quadraticCurveTo(0, 20, 114, -12);
    ctx.quadraticCurveTo(0, 42, -114, -12);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;

    // brillo banda
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha *= 0.18;
    ctx.strokeStyle = 'rgba(255,235,245,0.24)';
    ctx.lineWidth = 2.0;
    ctx.beginPath();
    ctx.moveTo(-102, -10);
    ctx.quadraticCurveTo(0, 10, 102, -10);
    ctx.stroke();
    ctx.restore();

    // nudo
    const knot = ctx.createRadialGradient(-6, -2, 2, 0, 2, 30);
    knot.addColorStop(0, 'rgba(150,62,90,0.66)');
    knot.addColorStop(0.55, 'rgba(66,18,36,0.62)');
    knot.addColorStop(1, 'rgba(14,6,12,0.60)');
    ctx.fillStyle = knot;
    ctx.beginPath();
    ctx.ellipse(0, 2, 24, 15, 0, 0, TAU);
    ctx.fill();

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = 'rgba(255,255,255,0.40)';
    ctx.beginPath();
    ctx.ellipse(-6, -1, 11, 5.4, -0.2, 0, TAU);
    ctx.fill();

    // colitas
    ctx.globalAlpha = 0.74;
    const tailGrad = ctx.createLinearGradient(0, 10, 0, 84);
    tailGrad.addColorStop(0, 'rgba(112,32,56,0.42)');
    tailGrad.addColorStop(1, 'rgba(14,5,10,0.42)');
    ctx.fillStyle = tailGrad;

    const tail = (x, flip) => {
      ctx.save();
      ctx.translate(x, 20);
      ctx.scale(flip, 1);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(18, 12, 26, 36);
      ctx.quadraticCurveTo(14, 70, -14, 74);
      ctx.quadraticCurveTo(-18, 44, 0, 0);
      ctx.closePath();
      ctx.fill();

      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.moveTo(6, 68);
      ctx.lineTo(26, 72);
      ctx.lineTo(10, 90);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    };
    tail(-32, 1);
    tail( 32,-1);

    ctx.restore(); // ribbon
    ctx.restore();
  }





// ===== Bouquet =====
  // Ramo más rico (8 orquídeas): más profundidad, mejor composición y sin amontonarse.
  const DESCS = [
    {dx:-0.66, hf:1.05, bs:0.82}, // lateral izq (atrás)
    {dx:-0.44, hf:1.16, bs:0.92},
    {dx:-0.18, hf:1.28, bs:1.02},
    {dx: 0.18, hf:1.28, bs:1.02},
    {dx: 0.44, hf:1.16, bs:0.92},
    {dx: 0.66, hf:1.05, bs:0.82}, // lateral der (atrás)
    {dx:-0.06, hf:0.98, bs:0.78}, // front pequeño
    {dx: 0.06, hf:0.98, bs:0.78}, // front pequeño
  ];

  let bouquet = [];

  function seedBouquet(){
    const cx = W*0.5;
    // Un pelín más abajo para que en móviles no “tope” arriba y se sienta centrado.
    const baseY = H*0.935;

    // Escala un poquito más generosa (sin pasarse) para que el ramo se vea “presente”.
    const scaleBase = lerp(0.74, 1.14, clamp(Math.min(W, H)/820, 0, 1));

    // Un poco más de apertura lateral para que respire.
    const spread = Math.min(W*0.56, 310 + W*0.07);

    bouquet = DESCS.map((p,i)=>{
      const seed = (1337 + i*101) >>> 0;
      let s = seed || 1;
      const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

      const scale = scaleBase * p.bs;

      // Variación real (pero estable) por flor
      const bw = (34 + rnd()*8) * scale;
      const bh = (78 + rnd()*14) * scale;

      // Inclinación: composición + micro azar (para que no parezcan clones)
      const twist = p.dx * 0.10 + (rnd()*2 - 1) * 0.06;

      // Apertura: 0.88..1.00 (con micro variación)
      const open = clamp(0.88 + rnd()*0.16 + (i%2)*0.02, 0, 1);

      return {
        i,
        x: cx + p.dx*spread,
        baseY,
        scale,
        height: (242 * scaleBase) * p.hf * (0.94 + rnd()*0.10),
        phase: i*0.83 + rnd()*0.35,
        bw, bh,
        twist,
        seed,
        col: colorFromSeed(seed),
        open,
        introStart: (i * 0.052) + rnd()*0.026,
        introSpan:  (0.70 + rnd()*0.12)
      };
    });
  }
function drawBouquet(t){
    // Suelo mínimo (sin césped): degradado oscuro suave para anclar el ramo
    {
      const gy = H * 0.74;
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      const g0 = ctx.createLinearGradient(0, gy - 70, 0, H);
      g0.addColorStop(0, 'rgba(0,0,0,0)');
      g0.addColorStop(0.35, 'rgba(0,0,0,0.16)');
      g0.addColorStop(1, 'rgba(0,0,0,0.62)');
      ctx.fillStyle = g0;
      ctx.fillRect(0, gy - 70, W, H - (gy - 70));
      ctx.restore();
    }

// sombra suave del primer plano (cacheado)
    rebuildBouquetShadeCache();
    if(bouquetShadeCache){
      ctx.drawImage(bouquetShadeCache, 0, 0, bouquetShadeCache.width / DPR, bouquetShadeCache.height / DPR);
    }else{
      const hx = W*0.5, hy = H*0.78;
      const hg = ctx.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
      hg.addColorStop(0, 'rgba(0,0,0,0)');
      hg.addColorStop(1, 'rgba(0,0,0,0.30)');
      ctx.fillStyle = hg;
      ctx.fillRect(0,0,W,H);
    }

// (césped/campo eliminado por completo)

    // Brillo animado leve
    // Brillo animado leve (como “respiración” del follaje)
    if(!(CONFIG.reduceMotion && !CONFIG.forceFlowerMotion)){
      const tt = t * 0.001;
      const pulse = 0.5 + 0.5*Math.sin(tt*0.9);
      const cx = W*(0.50 + 0.06*Math.sin(tt*0.25));
      const cy = H*0.80;
      const rr = Math.min(W,H) * (0.62 + 0.10*pulse);

      const glow = ctx.createRadialGradient(cx, cy, 10, cx, cy, rr);
      glow.addColorStop(0, `rgba(220,130,200,${0.06 + 0.04*pulse})`);
      glow.addColorStop(0.55, `rgba(190,95,170,${0.035 + 0.03*pulse})`);
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = glow;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }
const STEM = {r:55,g:155,b:92};
    const STEM2= {r:35,g:120,b:72};

    const gw = windField(t) * CONFIG.sway;

    const order = drawBouquet._order || (drawBouquet._order = []);
    order.length = bouquet.length;
    for(let i=0;i<bouquet.length;i++) order[i] = bouquet[i];
    order.sort((a,b)=> (b.height - a.height) || (a.x - b.x));

    const introActive = INTRO.active;
    const master = introActive ? clamp((t - INTRO.t0) / INTRO.dur, 0, 1) : 1;
    if(introActive && master >= 1) INTRO.active = false;

    for(const f of order){
      let uGen=1, stemU=1, leafU=1, bloomU=1, petals=6;
      if(introActive){
        const start = (f.introStart ?? (f.i * 0.055));
        const span  = (f.introSpan  ?? 0.72);
        uGen   = clamp((master - start) / span, 0, 1);
        stemU  = smoothstep(0.00, 0.56, uGen);
        leafU  = smoothstep(0.18, 0.78, uGen);
        bloomU = smoothstep(0.56, 1.00, uGen);
        const pU = smoothstep(0.58, 1.00, uGen);
        // Pétalos en continuo (0..6). getBloomSprite ya cuantiza a pasos finos.
        petals = clamp(easeOutCubic(pU) * 6, 0, 6);
      }

      const sway = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : (gw*0.22 + Math.sin(t*0.001 + f.phase) * 0.08 * CONFIG.sway);
      const angle = sway + (f.x - W*0.5) * 0.0006;

      const baseX = f.x;
      const baseY = f.baseY;
      const topY  = baseY - f.height;

      const bloomXFull = baseX + Math.sin(angle) * 12 * f.scale;
      const bloomYFull = topY + Math.cos(angle) * 5 * f.scale;

      const cp1x = baseX + Math.sin(f.phase)*10*f.scale;
      const cp1y = baseY - f.height*0.40;
      const cp2x = baseX + Math.cos(f.phase*1.7)*16*f.scale;
      const cp2y = baseY - f.height*0.76;

      const endP = {
        x: cubic(stemU, baseX, cp1x, cp2x, bloomXFull),
        y: cubic(stemU, baseY, cp1y, cp2y, bloomYFull)
      };

      // (hojas/ramas eliminadas)

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Variación sutil por tallo (evita que todos sean el mismo “tubo”)
      let ss = (f.seed * 1664525 + 1013904223) >>> 0;
      const jr = (ss / 4294967296) - 0.5; // -0.5..0.5

      const STEMa = {
        r: clamp(STEM.r  + jr*10, 20, 90),
        g: clamp(STEM.g  + jr*14, 70, 190),
        b: clamp(STEM.b  + jr*10, 40, 140)
      };
      const STEMb = {
        r: clamp(STEM2.r + jr*12, 10, 80),
        g: clamp(STEM2.g + jr*14, 50, 170),
        b: clamp(STEM2.b + jr*12, 25, 120)
      };

      const wBase = 7.2 * f.scale;
      const wTip  = 3.6 * f.scale;

      const sg = ctx.createLinearGradient(baseX, baseY, endP.x, endP.y);
      sg.addColorStop(0.00, rgba(STEMb.r, STEMb.g, STEMb.b, 0.10));
      sg.addColorStop(0.12, rgba(STEMb.r, STEMb.g, STEMb.b, 0.55));
      sg.addColorStop(0.34, rgba(STEMa.r, STEMa.g, STEMa.b, 0.95));
      sg.addColorStop(1.00, rgba(STEMa.r, STEMa.g, STEMa.b, 0.95));

      // Cuerpo con taper
      ctx.strokeStyle = sg;
      strokeCubicTaperPartial(baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, stemU, wBase, wTip, 34);

      // “Nervio” interno oscuro (da profundidad)
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.10;
      ctx.strokeStyle = 'rgba(0,0,0,0.30)';
      strokeCubicTaperPartial(baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, stemU, wBase*0.38, Math.max(1, wTip*0.42), 28);
      ctx.restore();

      // Volumen del tallo: sombra (lado opuesto a la luna) + brillo (lado de la luna)
      const offX = LIGHT_DIR.x * wBase * 0.22;
      const offY = LIGHT_DIR.y * wBase * 0.22;

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.16;
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      strokeCubicTaperPartial(baseX - offX, baseY - offY, cp1x - offX, cp1y - offY, cp2x - offX, cp2y - offY, bloomXFull - offX, bloomYFull - offY, stemU, wBase*0.55, wTip*0.55, 26);
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.14;
      ctx.strokeStyle = 'rgba(210,255,230,0.60)';
      strokeCubicTaperPartial(baseX + offX*0.70, baseY + offY*0.70, cp1x + offX*0.70, cp1y + offY*0.70, cp2x + offX*0.70, cp2y + offY*0.70, bloomXFull + offX*0.70, bloomYFull + offY*0.70, stemU, Math.max(1, wBase*0.22), Math.max(1, wTip*0.20), 24);
      ctx.restore();

      // Nodos sutiles (pequeñas “juntas” del tallo)
      if(stemU > 0.40){
        drawStemNode(Math.min(stemU, 0.42), baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, 4.4*f.scale, 0.11);
      }
      if(stemU > 0.68){
        drawStemNode(Math.min(stemU, 0.68), baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, 4.0*f.scale, 0.10);
      }

      // Brillo ascendente durante generación (tallo -> flor)
      if(introActive && !(CONFIG.reduceMotion && !CONFIG.forceFlowerMotion)){
        const glowU  = clamp(uGen * 1.02, 0, 1);
        const aGlow  = smoothstep(0.06, 0.78, uGen) * (1 - smoothstep(0.84, 1.00, uGen));
        if(glowU > 0.03 && aGlow > 0.001){
          drawStemGlowSegment(baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, glowU, 0.22, f.scale, aGlow);
        }
        if(bloomU > 0.02){
          drawBloomGlow(endP.x, endP.y, f.col, bloomU, f.scale);
        }
      }

      // Fade suave para integrarlo con el pasto (sin “corte” duro)
      const fadeH = 92 * f.scale;
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      const fg = ctx.createLinearGradient(0, baseY + 2, 0, baseY - fadeH);
      fg.addColorStop(0.00, 'rgba(0,0,0,0.85)');
      fg.addColorStop(0.55, 'rgba(0,0,0,0.22)');
      fg.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      ctx.strokeStyle = fg;
      strokeCubicTaperPartial(baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, stemU, wBase + 4.6*f.scale, wTip + 3.0*f.scale, 22);
      ctx.restore();

      ctx.restore();

      // sombra de contacto bajo la flor (le da "peso" y profundidad)
      if(bloomU > 0.02){
        ctx.save();
        ctx.globalAlpha = 0.11 * bloomU;
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        ctx.beginPath();
        ctx.ellipse(endP.x, endP.y + 6*f.scale, 10*f.scale, 4.2*f.scale, angle, 0, TAU);
        ctx.fill();
        ctx.restore();
      }


      f.bloomX = endP.x;
      f.bloomY = endP.y;
      f.angle = angle + f.twist;
      f._bloomU = bloomU;
      f._petals = petals;
      f._bloomScale = introActive ? lerp(0.10, 1.0, easeOutCubic(bloomU)) : 1;
      // Apertura por “etapas” (3 estados) para evitar re-generar sprites cada frame.
      if(introActive){
        const oU = smoothstep(0.52, 1.00, uGen);
        let o = (oU < 0.33) ? 0.78 : (oU < 0.66 ? 0.90 : f.open);
        if(o > f.open) o = f.open;
        f._openNow = o;
      }else{
        f._openNow = f.open;
      }
    }

    
    // Envoltura + bruma para que el ramo no flote como sticker
    const wrapS = lerp(0.82, 1.10, clamp(Math.min(W,H)/820, 0, 1));
    const wrapAlpha = introActive ? smoothstep(0.28, 0.78, master) : 1;
    ctx.save();
    ctx.globalAlpha *= wrapAlpha;
    // (envoltorio desactivado)
ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const fogTop = H*0.72;
    const fog = ctx.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(120,150,220,0)');
    fog.addColorStop(0.55, 'rgba(120,150,220,0.06)');
    fog.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = fog;
    ctx.fillRect(0, fogTop, W, H - fogTop);
    ctx.restore();
    // Fade inferior: esconde la unión de tallos sin usar césped
    {
      const fade = introActive ? (0.55 + 0.45*master) : 1;
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      const top = H*0.86;
      const g = ctx.createLinearGradient(0, top, 0, H);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(0.55, `rgba(0,0,0,${0.20*fade})`);
      g.addColorStop(1,    `rgba(0,0,0,${0.62*fade})`);
      ctx.fillStyle = g;
      ctx.fillRect(0, top, W, H - top);
      ctx.restore();

      // Neblina azul muy sutil (da profundidad sin “pasto”)
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      const fogTop2 = H*0.80;
      const fog2 = ctx.createLinearGradient(0, fogTop2, 0, H);
      fog2.addColorStop(0, 'rgba(120,150,220,0)');
      fog2.addColorStop(0.55, `rgba(120,150,220,${0.035*fade})`);
      fog2.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = fog2;
      ctx.fillRect(0, fogTop2, W, H - fogTop2);
      ctx.restore();
    }

    const bloomOrder = drawBouquet._bloom || (drawBouquet._bloom = []);

    bloomOrder.length = order.length;
    for(let i=0;i<order.length;i++) bloomOrder[i] = order[i];
    bloomOrder.sort((a,b)=>a.bloomY - b.bloomY);

for(const f of bloomOrder){
      const bu = (f._bloomU ?? 1);
      if(bu <= 0.001) continue;

      ctx.save();
      ctx.translate(f.bloomX, f.bloomY);
      ctx.globalAlpha *= bu;
      const bScale = (f._bloomScale ?? 1);
      ctx.scale(bScale, bScale);

      // Depth of field barato pero efectivo: las flores del fondo se suavizan un poco
      const ny = f.bloomY / H;
      const depth = clamp((ny - 0.34) / 0.34, 0, 1); // 0=lejos, 1=cerca
      const blur = (1 - depth) * (1 - depth) * 1.6;
      ctx.globalAlpha *= lerp(0.86, 1.0, depth);
      if(HAS_FILTER && blur > 0.02) ctx.filter = `blur(${blur.toFixed(2)}px)`;

      // Movimiento suave extra sólo para la cabeza de la orquídea (independiente del tallo)
      const tt = t * 0.001; // ms -> s
      const headWobble = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : (
        (Math.sin(tt*2.2 + f.phase*3.7) * 0.16) +
        (Math.sin(tt*3.4 + f.phase*1.9) * 0.07)
      ) * CONFIG.sway;

      const bobX = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : Math.sin(tt*1.6 + f.phase*4.1) * (5.0*f.scale) * CONFIG.sway;
      const bobY = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : Math.sin(tt*1.9 + f.phase*2.0) * (3.6*f.scale) * CONFIG.sway;

      const breathe = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 1 : (1 + Math.sin(tt*1.5 + f.phase*0.7) * 0.02 * CONFIG.sway);

      ctx.translate(bobX, bobY);
      ctx.scale(breathe, breathe);
      ctx.rotate(f.angle + headWobble);

      ctx.shadowColor = `rgba(${f.col.r},${f.col.g},${f.col.b},0.16)`;
      ctx.shadowBlur = (10 + 12*f.scale) * bScale;

      drawTulipBloom(f.bw, f.bh, f.col, f.seed, (f._openNow ?? f.open), (f._petals ?? 6));

      // Volumen extra: un toque de luz y sombra direccional (recorta mejor y se ve menos “plano”)
      {
        const cyHL = -f.bh*0.62;
        ctx.save();
        ctx.beginPath();
        ctx.ellipse(0, cyHL, f.bw*0.88, f.bh*0.70, 0, 0, TAU);
        ctx.clip();

        // brillo (lado de la luna)
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha *= (0.08 + 0.06*depth);

        let hg = ctx.createLinearGradient(f.bw*0.72, cyHL - f.bh*0.48, -f.bw*0.56, cyHL + f.bh*0.18);
        hg.addColorStop(0, 'rgba(255,255,255,0.36)');
        hg.addColorStop(0.35, 'rgba(255,255,255,0.14)');
        hg.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = hg;
        ctx.fillRect(-f.bw*1.25, cyHL - f.bh*1.12, f.bw*2.5, f.bh*2.3);

        // sombra suave (lado opuesto)
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha *= 0.55;
        let sg = ctx.createLinearGradient(-f.bw*0.76, cyHL - f.bh*0.44, f.bw*0.56, cyHL + f.bh*0.22);
        sg.addColorStop(0, 'rgba(0,0,0,0.22)');
        sg.addColorStop(0.55, 'rgba(0,0,0,0.10)');
        sg.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = sg;
        ctx.fillRect(-f.bw*1.25, cyHL - f.bh*1.12, f.bw*2.5, f.bh*2.3);

        ctx.restore();
      }

      // “Shimmer” ligero sobre el centro/pétalos para dar vida sin re-renderizar sprites cada frame
      if(!CONFIG.reduceMotion){
        const cy = -f.bh*0.52;
        const r0 = Math.min(f.bw, f.bh) * 0.16;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha *= 0.075 * (0.35 + 0.65*(0.5 + 0.5*Math.sin(tt*4.1 + f.phase*1.3)));
        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.lineWidth = Math.max(0.9, 1.15 * f.scale);
        for(let k=0;k<8;k++){
          const a = (k/8)*TAU + tt*0.7 + f.phase*0.15;
          const x1 = Math.cos(a)*r0*0.18;
          const y1 = cy + Math.sin(a)*r0*0.14;
          const x2 = Math.cos(a)*r0*0.95;
          const y2 = cy + Math.sin(a)*r0*0.72;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();
      }
      if(HAS_FILTER) ctx.filter = 'none';
      ctx.restore();
    }

    const knotX = W*0.5, knotY = H*0.935;
    ctx.save();
    ctx.globalAlpha *= (introActive ? wrapAlpha : 1);
    // Sombra más suave bajo el nudo/envoltura (evita la “línea negra”)
    const ks = ctx.createRadialGradient(knotX, knotY, 6, knotX, knotY, Math.min(140, W*0.26));
    ks.addColorStop(0, 'rgba(0,0,0,0.16)');
    ks.addColorStop(0.55, 'rgba(0,0,0,0.08)');
    ks.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = ks;
    ctx.beginPath();
    ctx.ellipse(knotX, knotY, Math.min(130, W*0.24), 34, 0, 0, TAU);
    ctx.fill();ctx.restore();

    // Luciérnagas/polvo brillante (sutil): le da vida al primer plano
    drawFireflies(t, introActive ? (0.35 + 0.65*master) : 1);
  }

  function addSparkle(x, y, t){
    tapSparkles.push({ x, y, t0: t, seed: Math.random()*9999 });
    if(tapSparkles.length > 28) tapSparkles.shift();
  }

  function drawTapSparkles(t){
    if(!tapSparkles.length) return;

    for(let i=tapSparkles.length-1;i>=0;i--){
      const s = tapSparkles[i];
      const age = (t - s.t0) / 1000;
      if(age > 0.95){ tapSparkles.splice(i,1); continue; }

      const k = 1 - age/0.95;
      const r = (14 + age*56);
      const pulse = 0.6 + 0.4*Math.sin((t*0.01) + s.seed);

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.46 * k;

      const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, r);
      g.addColorStop(0, `rgba(255,255,255,${0.32*k})`);
      g.addColorStop(0.28, `rgba(200,220,255,${0.20*k})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;

      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, TAU);
      ctx.fill();

      ctx.globalAlpha = 0.18 * k * pulse;
      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.moveTo(s.x - r*0.55, s.y);
      ctx.lineTo(s.x + r*0.55, s.y);
      ctx.moveTo(s.x, s.y - r*0.55);
      ctx.lineTo(s.x, s.y + r*0.55);
      ctx.stroke();

      ctx.restore();
    }
  }


  function resize(){
    const vv = window.visualViewport;
    W = Math.floor(vv ? vv.width  : window.innerWidth);
    H = Math.floor(vv ? vv.height : window.innerHeight);

    const isSmall = Math.min(W, H) < 420;

    // Auto-tune a couple settings for small screens
    if(CONFIG._baseStars == null) CONFIG._baseStars = CONFIG.stars;
    if(CONFIG._baseTwinkle == null) CONFIG._baseTwinkle = CONFIG.twinkle;

    const area = W * H;
    const desiredStars = Math.max(180, Math.min(360, Math.round(area / 3500)));
    CONFIG.stars = desiredStars;
    CONFIG.twinkle = isSmall ? Math.min(CONFIG._baseTwinkle, 0.75) : CONFIG._baseTwinkle;

    const cap = isSmall ? Math.min(CONFIG.dprCap || 1.8, 1.5) : (CONFIG.dprCap || 1.8);
    DPR = Math.min(cap, window.devicePixelRatio || 1);

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    bloomCache.clear();

    seedStars();
    buildStarText();
    rebuildSkyCache();
    rebuildMoonCache();
    rebuildStaticSkyOverlayCache();
    rebuildSkyDynCache();

    rebuildFieldCache();
    seedBouquet();
    // Césped eliminado por completo
    seedFireflies();
rebuildBouquetShadeCache();

    for(const f of bouquet){
      getBloomSprite(f.bw, f.bh, f.col, f.seed, f.open);
    }
    if(CONFIG.debug) selfTest();
  }
  var _resizeRaf = 0;
  function requestResize(){
    if(_resizeRaf) cancelAnimationFrame(_resizeRaf);
    _resizeRaf = requestAnimationFrame(()=>{ _resizeRaf = 0; resize(); });
  }
  window.addEventListener('resize', requestResize, {passive:true});

  if (window.visualViewport){
    window.visualViewport.addEventListener('resize', requestResize, {passive:true});
    window.visualViewport.addEventListener('scroll', requestResize, {passive:true});
  }

  canvas.addEventListener('pointerdown', (e) => {
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left);
    const y = (e.clientY - r.top);
    addSparkle(x, y, performance.now());

    // si le picas cerca del cielo, regalamos una estrella fugaz
    if(y < H*0.55 && !shooting.active) maybeStartShootingStar(performance.now());
  }, {passive:true});



  function selfTest(){
    console.assert(!!canvas && !!ctx, 'Canvas/ctx no disponibles');
    console.assert(Number.isFinite(W) && W>0 && Number.isFinite(H) && H>0, 'Canvas size inválido');
    console.assert(Array.isArray(stars) && stars.length>0, 'Stars no inicializadas');
    console.assert(Array.isArray(starLinks), 'starLinks no existe');
    console.assert(stars.length < 40 || starLinks.length > 0, 'Constelaciones no generadas');
    console.assert(Array.isArray(tapSparkles), 'tapSparkles no existe');
    console.assert(Array.isArray(textStars) && textStars.length>200, 'Texto en estrellas no generado');
    console.assert(!!skyCache && skyCache.width>0, 'Sky cache no generado');
    console.assert(Array.isArray(bouquet) && bouquet.length===DESCS.length, 'Bouquet no se generó correctamente');
    console.assert(CONFIG.crownStrength >= 0 && CONFIG.crownStrength <= 1, 'crownStrength fuera de rango');

    // Smoke test de dibujo: esto también calcula bloomX/bloomY
    try{ drawBouquet(0); }catch(e){ console.error('drawBouquet fallo', e); }
    console.assert(bouquet.every(f=>Number.isFinite(f.bloomX) && Number.isFinite(f.bloomY)), 'bloomX/bloomY no calculados');

    const spr = getBloomSprite(60, 100, {r:235,g:55,b:70}, 42, 0.95);
    console.assert(spr && spr.canvas && spr.ss === 2 && spr.canvas.width>0, 'Sprite inválido');
  }
  requestResize();

  let _rafId = 0;
  let _lastDraw = 0;

  // Auto-calidad (A): baja/sube preset según el rendimiento real
  let _emaDt = 16;
  let _goodFrames = 0;
  let _cooldownUntil = 0;

  function autoQualityTick(dt, t){
    if(!CONFIG.autoQuality) return;

    _emaDt = _emaDt*0.92 + dt*0.08;

    if(t < _cooldownUntil) return;

    const q = (CONFIG.quality ?? 2);

    // si va lento, baja calidad rápido
    if(_emaDt > 28 && q > 0){
      applyQuality(q - 1);
      _cooldownUntil = t + 2500;
      _goodFrames = 0;
      return;
    }

    // si va muy fluido sostenido, sube calidad con paciencia
    if(_emaDt < 17 && q < 2){
      _goodFrames++;
      if(_goodFrames > 160){
        applyQuality(q + 1);
        _cooldownUntil = t + 4500;
        _goodFrames = 0;
      }
    }else{
      _goodFrames = 0;
    }
  }

  function frame(t){
    _rafId = requestAnimationFrame(frame);

    const minStep = 1000 / (CONFIG.maxFPS || 60);
    if(_lastDraw && (t - _lastDraw) < minStep) return;

    const dt = _lastDraw ? (t - _lastDraw) : 0;
    _lastDraw = t;

    if(dt) autoQualityTick(dt, t);

    drawSky(t);
    drawBouquet(t);
    drawTapSparkles(t);

    updateHUD(false);
  }


function start(){
  if(_rafId) return;
  _lastDraw = 0;
  _rafId = requestAnimationFrame(frame);
}

function stop(){
  if(!_rafId) return;
  cancelAnimationFrame(_rafId);
  _rafId = 0;
}

document.addEventListener('visibilitychange', () => {
  if(!_started) return;
  if(document.hidden) stop();
  else start();
}, {passive:true});

resize();
// No arrancamos hasta que el usuario toque la carta.
})();
</script>
</body>
</html>
