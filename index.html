<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ramo de gerberas (noche)</title>
  <style>
    :root{
      --bg1:#070814;
      --bg2:#0b1030;
      --bg3:#151a40;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(900px 650px at 50% 10%, var(--bg3), var(--bg2), var(--bg1));
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}

    #hud{
      position:fixed;
      left:12px; top:12px;
      z-index:2;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.88);
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: 0.2px;
      user-select:none;
      -webkit-user-select:none;
      max-width: min(340px, calc(100vw - 24px));
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    #hud.hidden{ opacity:0; pointer-events:none; }
    #hud .title{ font-weight:600; margin-bottom:6px; }
    #hud .row{ margin:2px 0; opacity:0.92; }
    #hud kbd{
      display:inline-block;
      padding:1px 6px;
      margin:0 2px;
      border-radius:7px;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.10);
      font: 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
  
    #hud{display:none !important;}
  </style>
</head>
<body>
  <canvas id="c" role="img" aria-label="Animación de un ramo de gerberas violetas bajo un cielo estrellado con nubes, luna y la constelación de Capricornio"></canvas>
  <script>
(() => {
  'use strict';

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const hud = document.getElementById('hud');

  let HAS_FILTER = false; try{ ctx.filter = 'none'; HAS_FILTER = (typeof ctx.filter !== 'undefined'); }catch(_){ HAS_FILTER = false; }

  let W = 0, H = 0, DPR = 1;

  const TAU = Math.PI * 2;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rgba  = (r,g,b,a)=>`rgba(${r},${g},${b},${a})`;



  // HSL -> RGB (para dar colores aleatorios bonitos sin depender de una lista fija)
  function hslToRgb(h, s, l){
    h = ((h % 360) + 360) % 360;
    s = clamp(s/100, 0, 1);
    l = clamp(l/100, 0, 1);

    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = h / 60;
    const x = c * (1 - Math.abs((hp % 2) - 1));

    let r1=0, g1=0, b1=0;
    if(hp >= 0 && hp < 1){ r1=c; g1=x; b1=0; }
    else if(hp < 2){ r1=x; g1=c; b1=0; }
    else if(hp < 3){ r1=0; g1=c; b1=x; }
    else if(hp < 4){ r1=0; g1=x; b1=c; }
    else if(hp < 5){ r1=x; g1=0; b1=c; }
    else { r1=c; g1=0; b1=x; }

    const m = l - c/2;
    return {
      r: Math.round((r1+m)*255),
      g: Math.round((g1+m)*255),
      b: Math.round((b1+m)*255)
    };
  }

  // Color aleatorio pero estable por semilla (así cada gerbera "nace" con su propio tono)
  const colorFromSeed = (seed)=>{
    // Rosado (con variación sutil por flor para que se vea natural).
    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    // Hue rosado ~ 325-350, saturación media-alta, luz un poco más alta.
    const h   = 338 + (rnd()*24 - 12);  // 326..350
    const sat = 62 + rnd()*18;          // 62..80
    const lit = 58 + rnd()*14;          // 58..72
    return hslToRgb(h, sat, lit);
  };

// ===== Intro: generación del ramo al abrir =====
// master: 0..1 controla el “construir” tallo -> hojas -> pétalos.
const INTRO = { active: true, t0: performance.now(), dur: 5200 };

const smoothstep = (a,b,x) => {
  const t = clamp((x - a) / Math.max(1e-6, (b - a)), 0, 1);
  return t*t*(3 - 2*t);
};

const cubic = (t, a,b,c,d) => {
  const u = 1 - t;
  return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
};

function strokeCubicPartial(x0,y0,x1,y1,x2,y2,x3,y3,u, stepsMax=28){
  const uu = clamp(u, 0, 1);
  const steps = Math.max(2, Math.floor(stepsMax * uu));
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  for(let i=1;i<=steps;i++){
    const tt = uu * (i/steps);
    ctx.lineTo(
      cubic(tt, x0,x1,x2,x3),
      cubic(tt, y0,y1,y2,y3)
    );
  }
  ctx.stroke();
  return {
    x: cubic(uu, x0,x1,x2,x3),
    y: cubic(uu, y0,y1,y2,y3)
  };
}
// ---- Helpers: tallos con taper + detalle ----
function cubicD(t, a,b,c,d){
  const u = 1 - t;
  return 3*u*u*(b - a) + 6*u*t*(c - b) + 3*t*t*(d - c);
}
function pointOnCubic(t, x0,y0,x1,y1,x2,y2,x3,y3){
  return { x: cubic(t, x0,x1,x2,x3), y: cubic(t, y0,y1,y2,y3) };
}
function normalOnCubic(t, x0,y0,x1,y1,x2,y2,x3,y3){
  const dx = cubicD(t, x0,x1,x2,x3);
  const dy = cubicD(t, y0,y1,y2,y3);
  const len = Math.hypot(dx, dy) || 1;
  const tx = dx/len, ty = dy/len;
  return { tx, ty, nx: -ty, ny: tx, ang: Math.atan2(ty, tx) };
}
// Dibuja una cúbica hasta u con grosor variable (taper). Mantiene el mismo strokeStyle para ser rápido.
function strokeCubicTaperPartial(x0,y0,x1,y1,x2,y2,x3,y3,u,w0,w1, stepsMax=34){
  const uu = clamp(u, 0, 1);
  const steps = Math.max(3, Math.floor(stepsMax * uu));
  let px = x0, py = y0;
  for(let i=1;i<=steps;i++){
    const tt = uu * (i/steps);
    const x = cubic(tt, x0,x1,x2,x3);
    const y = cubic(tt, y0,y1,y2,y3);
    const k = (i/steps);
    // taper suave: más grueso abajo, más delgado arriba
    const w = lerp(w0, w1, smoothstep(0.0, 1.0, k));
    ctx.lineWidth = w;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(x, y);
    ctx.stroke();
    px = x; py = y;
  }
  return {x:px, y:py};
}
function drawStemNode(tt, x0,y0,x1,y1,x2,y2,x3,y3, r, alpha=0.10){
  const p = pointOnCubic(tt, x0,y0,x1,y1,x2,y2,x3,y3);
  const n = normalOnCubic(tt, x0,y0,x1,y1,x2,y2,x3,y3);

  ctx.save();
  // sombra del nodo
  ctx.globalCompositeOperation = 'multiply';
  ctx.globalAlpha = alpha;
  ctx.fillStyle = 'rgba(0,0,0,0.30)';
  ctx.beginPath();
  ctx.ellipse(p.x - n.nx*r*0.35, p.y - n.ny*r*0.35, r*1.10, r*0.55, n.ang, 0, TAU);
  ctx.fill();

  // brillo leve del nodo (lado luna)
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = alpha*0.75;
  ctx.fillStyle = 'rgba(210,255,230,0.35)';
  ctx.beginPath();
  ctx.ellipse(p.x + n.nx*r*0.28, p.y + n.ny*r*0.28, r*0.88, r*0.42, n.ang, 0, TAU);
  ctx.fill();
  ctx.restore();
}


function restartIntro(){
  INTRO.active = true;
  INTRO.t0 = performance.now();
}


  // Campo de viento global (compartido por pasto y gerberas)
  const windField = (t) => {
    if(CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) return 0;
    // combinación lenta (natural y suave)
    return (Math.sin(t*0.00055)*0.78 + Math.sin(t*0.00023 + 1.7)*0.34);
  };

  const shuffleInPlace = (arr) => {
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  };

  const makePRNG = (seed) => {
    let s = (seed >>> 0) || 1;
    return () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);
  };

  const CONFIG = {
    stars: 320,
    twinkle: 0.90,
    sway: 0.65,
    reduceMotion: false,
    forceFlowerMotion: true,
    shootingStars: 1,

    // 0..1: “corona/picos” (arriba del tulipán). 0 = casi lisa
    crownStrength: 0.008,

    // Texto “en estrellas”
    starText: 'every day, you look so beatiful <3',
    starTextStrength: 0.95    ,

    // Rendimiento / calidad
    maxFPS: 60,
    dprCap: 1.8,
    grassAnimFactor: 1.0,
    grassDetail: 1,
    debug: false,
    quality: 2,
    hud: false,
    autoQuality: false

  };

  try{
    const m = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
    if(m && m.matches) CONFIG.reduceMotion = true;
  }catch(_){}


  // ===== Persistencia + HUD =====
  const STORAGE_KEY = 'daily_flowers_settings_v1';

  function loadSettings(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);
      if(!s || typeof s !== 'object') return;

      if(typeof s.quality === 'number') CONFIG.quality = clamp(s.quality, 0, 2);
      if(typeof s.reduceMotion === 'boolean') CONFIG.reduceMotion = s.reduceMotion;
      if(typeof s.shootingStars === 'number') CONFIG.shootingStars = s.shootingStars ? 1 : 0;
      if(typeof s.hud === 'boolean') CONFIG.hud = s.hud;
      if(typeof s.autoQuality === 'boolean') CONFIG.autoQuality = s.autoQuality;
    }catch(_){}
  }

  function saveSettings(){
    try{
      const s = {
        quality: CONFIG.quality ?? 2,
        reduceMotion: !!CONFIG.reduceMotion,
        shootingStars: CONFIG.shootingStars ? 1 : 0,
        hud: !!CONFIG.hud,
        autoQuality: !!CONFIG.autoQuality
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
    }catch(_){}
  }

  function setHudVisible(v){
    CONFIG.hud = !!v;
    if(hud) hud.classList.toggle('hidden', !CONFIG.hud);
    saveSettings();
  }

  function updateHUD(force){
    if(!hud) return;
    const now = performance.now();
    if(!force && updateHUD._t && (now - updateHUD._t) < 250) return;
    updateHUD._t = now;

    hud.classList.toggle('hidden', !CONFIG.hud);

    const qName = QUALITY_PRESETS?.[CONFIG.quality ?? 2]?.name ?? 'alta';
    const rm = CONFIG.reduceMotion ? 'ON' : 'OFF';
    const ss = CONFIG.shootingStars ? 'ON' : 'OFF';
    const aq = CONFIG.autoQuality ? 'ON' : 'OFF';

    hud.innerHTML =
      '<div class="title">Daily flowers panel</div>' +
      '<div class="row"><kbd>Q</kbd> calidad: <b>' + qName + '</b> | <kbd>A</kbd> auto: <b>' + aq + '</b></div>' +
      '<div class="row"><kbd>M</kbd> motion: <b>' + rm + '</b> | <kbd>S</kbd> fugaces: <b>' + ss + '</b></div>' +
      '<div class="row"><kbd>E</kbd> export PNG | <kbd>P</kbd> foto | <kbd>R</kbd> re-generar | <kbd>H</kbd> ocultar panel</div>';
  }

  loadSettings();


// ===== Calidad rápida (Q) y atajos =====
const QUALITY_PRESETS = [
  { name: 'baja',  dpr: 1.15, stars: 140, twinkle: 0.65, sway: 0.16, shoot: 0, grass: 0.55, grassDetail: 0, fps: 40 },
  { name: 'media', dpr: 1.40, stars: 200, twinkle: 0.75, sway: 0.22, shoot: 1, grass: 0.80, grassDetail: 0, fps: 55 },
  { name: 'alta',  dpr: 1.80, stars: 240, twinkle: 0.80, sway: 0.28, shoot: 1, grass: 1.00, grassDetail: 1, fps: 60 }
];

function applyQuality(level, doResize=true){
  const q = QUALITY_PRESETS[clamp(level,0,2)];
  CONFIG.quality = clamp(level,0,2);
  CONFIG.dprCap = q.dpr;
  CONFIG.stars = q.stars;
  CONFIG.twinkle = q.twinkle;
  CONFIG.sway = q.sway;
  CONFIG.shootingStars = q.shoot;
  CONFIG.grassAnimFactor = q.grass;
  CONFIG.grassDetail = (typeof q.grassDetail === 'number') ? q.grassDetail : 1;
  CONFIG.maxFPS = q.fps;
  if(doResize) requestResize();
  saveSettings();
  updateHUD(true);
}

// aplica preset guardado sin forzar resize inmediato
applyQuality(CONFIG.quality ?? 2, false);
setHudVisible(CONFIG.hud);
updateHUD(true);

function cycleQuality(){
  applyQuality((CONFIG.quality ?? 2) === 2 ? 1 : ((CONFIG.quality ?? 2) === 1 ? 0 : 2));
}


function exportPNG(filename){
  const name = filename || 'daily_flowers.png';
  try{
    // Congela un frame limpio antes de exportar
    const t = performance.now();
    const prevRM = CONFIG.reduceMotion;
    CONFIG.reduceMotion = true;

    drawSky(t);
    rebuildFieldCache();
    if(fieldCache){ ctx.drawImage(fieldCache, 0, 0, fieldCache.width / DPR, fieldCache.height / DPR); }
    drawBouquet(t);
    drawTapSparkles(t);

    CONFIG.reduceMotion = prevRM;

    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }catch(_){
    try{
      const url = canvas.toDataURL('image/png');
      window.open(url, '_blank');
    }catch(__){}
  }
}

function photoExport(){
  // “Modo foto”: pausa movimiento, dibuja un frame y exporta.
  // (No hace upscale agresivo para no freír la memoria del navegador.)
  exportPNG('your_daily_flowers.png');
}

window.addEventListener('keydown', (e) => {
  const k = (e.key || '').toLowerCase();

  if(k === 'q'){ cycleQuality(); }

  if(k === 'a'){
    CONFIG.autoQuality = !CONFIG.autoQuality;
    saveSettings();
    updateHUD(true);
  }

  if(k === 'm'){
    CONFIG.reduceMotion = !CONFIG.reduceMotion;
    saveSettings();
    requestResize(); // reconstruye caches (incluye cielo estático)
    updateHUD(true);
  }

  if(k === 's'){
    CONFIG.shootingStars = CONFIG.shootingStars ? 0 : 1;
    saveSettings();
    updateHUD(true);
  }

  if(k === 'h'){
    setHudVisible(!CONFIG.hud);
    updateHUD(true);
  }

  if(k === 'e'){
    exportPNG();
  }

  if(k === 'p'){
    photoExport();
  }

  if(k === 'r'){
    restartIntro();
  }

}, {passive:true});

  // ===== Stars =====
  const stars = [];
  const starLinks = [];
  const textStars = [];
  const tapSparkles = [];

  // Luz “luna” coherente (arriba-derecha)
  const LIGHT = { x:0.18, y:0.14 };
  const LIGHT_DIR = (() => {
    const dx = 0.74, dy = -0.52;
    const inv = 1 / Math.max(1e-6, Math.hypot(dx,dy));
    return { x: dx*inv, y: dy*inv };
  })();

  const shooting = { active:false, t0:0, dur:0, x0:0,y0:0, x1:0,y1:0 };

  function seedStars(){
    stars.length = 0;
    starLinks.length = 0;

    const clusters = [
      {cx: 0.28, cy: 0.20, r: 0.18},
      {cx: 0.72, cy: 0.16, r: 0.20},
      {cx: 0.52, cy: 0.30, r: 0.16},
      {cx: 0.12, cy: 0.12, r: 0.14},   // micro-cúmulo (izq arriba)
      {cx: 0.88, cy: 0.22, r: 0.15},   // micro-cúmulo (der medio)
    ];

    const mwBand = () => {
      const t = Math.random();
      const x = lerp(0.14, 0.92, t);
      const y = lerp(0.48, 0.20, t);
      const off = (Math.random()-0.5) * 0.10;
      return { x: clamp(x + off*0.90, 0, 1), y: clamp(y + off*(-0.55), 0, 1) };
    };

    const pick = () => {
      const r = Math.random();
      if(r < 0.62){
        const x = Math.random();
        const y = Math.pow(Math.random(), 1.55);
        return {x, y};
      }
      if(r < 0.78) return mwBand();

      const c = clusters[(Math.random()*clusters.length)|0];
      const a = Math.random()*TAU;
      const rr = Math.sqrt(Math.random()) * c.r;
      return { x: clamp(c.cx + Math.cos(a)*rr, 0, 1), y: clamp(c.cy + Math.sin(a)*rr, 0, 1) };
    };

    for(let i=0;i<CONFIG.stars;i++){
      const p = pick();
      const yBias = Math.pow(1 - p.y, 1.8);

      const roll = Math.random();
      const big = roll < (0.045 + 0.025*yBias);
      const mid = !big && roll < (0.22 + 0.06*yBias);

      const rBase = big ? (2.2 + Math.random()*3.0)
                  : (mid ? (1.2 + Math.random()*1.4) : (0.55 + Math.random()*0.95));
      const aBase = big ? (0.18 + Math.random()*0.28)
                  : (mid ? (0.10 + Math.random()*0.16) : (0.05 + Math.random()*0.12));

      let hue = 0;
      const temp = Math.random();
      if(temp < 0.10) hue = 205 + Math.random()*35;
      else if(temp < 0.16) hue = 35 + Math.random()*18;
      else if(temp < 0.19) hue = 10 + Math.random()*20; // rojizo raro
      else if(big && temp < 0.45) hue = 200 + Math.random()*60;

      stars.push({
        x: p.x, y: p.y,
        z: big ? 0.92 : (mid ? 0.68 : (0.35 + Math.random()*0.35)),
        r: rBase, a: aBase,
        p: Math.random()*TAU,
        s: (0.25 + Math.random()*0.95),
        hue,
        flare: big ? (0.55 + Math.random()*0.45) : (mid ? (0.18 + Math.random()*0.35) : 0),
        tw: big ? (0.45 + Math.random()*0.40) : (mid ? (0.30 + Math.random()*0.30) : (0.18 + Math.random()*0.22))
      });
    }

    buildConstellations();

    shooting.active = false;
    shooting.t0 = 0;
    shooting.dur = 0;
  }

  function buildConstellations(){
    starLinks.length = 0;
    if(stars.length < 6) return;

    // Conectamos algunas estrellas brillantes en "constelaciones" sutiles (sin volverlo un mapa de metro)
    const ids = stars
      .map((s,i)=>({i, score: s.r * (0.85 + s.a)}))
      .sort((a,b)=>b.score-a.score)
      .slice(0, 18)
      .map(o=>o.i);

    const maxDist = 0.13;
    const used = new Set();

    for(const i of ids){
      let best1=-1,best2=-1;
      let d1=1e9,d2=1e9;

      for(const j of ids){
        if(j===i) continue;
        const dx = stars[i].x - stars[j].x;
        const dy = stars[i].y - stars[j].y;
        const d = Math.hypot(dx,dy);
        if(d > maxDist) continue;

        if(d < d1){ d2=d1; best2=best1; d1=d; best1=j; }
        else if(d < d2){ d2=d; best2=j; }
      }

      const add = (j, dist) => {
        if(j < 0 || !Number.isFinite(dist)) return;
        const a = Math.max(0.016, 0.055 - dist*0.22);
        const key = i<j ? `${i}-${j}` : `${j}-${i}`;
        if(used.has(key)) return;
        used.add(key);
        starLinks.push({i, j, a});
      };

      add(best1, d1);
      add(best2, d2);
    }
  }


  function maybeStartShootingStar(t){
    if(CONFIG.reduceMotion || !CONFIG.shootingStars) return;
    if(shooting.active) return;

    if(Math.random() < 0.0022){
      shooting.active = true;
      shooting.t0 = t;
      shooting.dur = 900 + Math.random()*900;

      const startX = Math.random()*W*0.90;
      const startY = Math.random()*H*0.35;
      const dx = (120 + Math.random()*220);
      const dy = (40 + Math.random()*120);

      shooting.x0 = startX; shooting.y0 = startY;
      shooting.x1 = startX + dx; shooting.y1 = startY + dy;
    }
  }

  function drawShootingStar(t){
    if(!shooting.active) return;

    const u = clamp((t - shooting.t0) / shooting.dur, 0, 1);
    const ease = u*u*(3-2*u);

    const x = lerp(shooting.x0, shooting.x1, ease);
    const y = lerp(shooting.y0, shooting.y1, ease);

    const tail = 120;
    const ang = Math.atan2(shooting.y1 - shooting.y0, shooting.x1 - shooting.x0);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = (1-u) * 0.85;

    const tx = x - Math.cos(ang)*tail;
    const ty = y - Math.sin(ang)*tail;

    const g = ctx.createLinearGradient(tx, ty, x, y);
    g.addColorStop(0, 'rgba(255,255,255,0)');
    g.addColorStop(0.55, 'rgba(255,255,255,0.14)');
    g.addColorStop(1, 'rgba(255,255,255,0.85)');

    ctx.strokeStyle = g;
    ctx.lineWidth = 2.0;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(x, y);
    ctx.stroke();

    ctx.globalAlpha = (1-u) * 0.95;
    ctx.shadowColor = 'rgba(255,255,255,0.8)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x,y, 1.8, 0, TAU);
    ctx.fill();

    ctx.restore();

    if(u >= 1) shooting.active = false;
  }

  // ===== Césped =====
  const grass = [];
  const soil = [];
  const grassAnim1 = [];
  const grassAnim2 = [];

  let groundCache = null;
  let skyCache = null;
  let staticSkyOverlayCache = null;
  let fieldCache = null;
  let fieldCacheKey = '';
  let fieldBandCache = null;
  let fieldBandCacheKey = '';


  let bouquetShadeCache = null;
  let bouquetShadeKey = '';

  function rebuildBouquetShadeCache(){
    const key = `${W}x${H}@d${DPR.toFixed(2)}`;
    if(bouquetShadeCache && bouquetShadeKey === key) return;
    bouquetShadeKey = key;

    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const hx = W*0.5, hy = H*0.78;
    const hg = g.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
    hg.addColorStop(0, 'rgba(0,0,0,0)');
    hg.addColorStop(1, 'rgba(0,0,0,0.30)');
    g.fillStyle = hg;
    g.fillRect(0,0,W,H);

    bouquetShadeCache = off;
  }

  let bushCache = null;
  let bushCacheKey = '';
  const bloomCache = new Map();

// ===== Sol (cache + generación) =====
let moonCache = null;
let moonCacheR = 0;
let moonCachePad = 0;

function rebuildMoonCache(){
  const r = Math.min(W,H) * 0.062;
  const pad = Math.ceil(r*0.25) + 3;

  const size = Math.ceil((r*2 + pad*2) * DPR);
  const off = document.createElement('canvas');
  off.width  = size;
  off.height = size;

  const g = off.getContext('2d', {alpha:true});
  g.setTransform(DPR,0,0,DPR,0,0);

  const cx = pad + r;
  const cy = pad + r;

  // disco con gradiente (sensación de esfera)
  g.save();
  g.globalCompositeOperation = 'screen';
  g.globalAlpha = 0.92;

  const disc = g.createRadialGradient(cx - r*0.25, cy - r*0.25, r*0.12, cx, cy, r);
  disc.addColorStop(0, 'rgba(255,255,255,0.95)');
  disc.addColorStop(0.42, 'rgba(238,245,255,0.90)');
  disc.addColorStop(0.78, 'rgba(210,225,245,0.86)');
  disc.addColorStop(1, 'rgba(190,205,230,0.82)');

  g.fillStyle = disc;
  g.beginPath();
  g.arc(cx, cy, r, 0, TAU);
  g.fill();

  // sombreado suave (terminador)
  g.globalCompositeOperation = 'multiply';
  g.globalAlpha = 0.22;
  const shade = g.createLinearGradient(cx - r, cy, cx + r, cy);
  shade.addColorStop(0, 'rgba(0,0,0,0.22)');
  shade.addColorStop(0.55, 'rgba(0,0,0,0.00)');
  shade.addColorStop(1, 'rgba(0,0,0,0.14)');
  g.fillStyle = shade;
  g.beginPath();
  g.arc(cx, cy, r, 0, TAU);
  g.fill();

  // textura/cráteres (determinística)
  let ms = (((W*73856093) ^ (H*19349663) ^ 0x9e3779b9) >>> 0) || 1;
  const mrnd = () => (ms = (ms * 1664525 + 1013904223) >>> 0, ms / 4294967296);

  g.save();
  g.beginPath();
  g.arc(cx, cy, r, 0, TAU);
  g.clip();

  // polvo fino
  g.globalCompositeOperation = 'overlay';
  g.globalAlpha = 0.10;
  for(let i=0;i<80;i++){
    const a = mrnd()*TAU;
    const rr = Math.sqrt(mrnd()) * r*0.92;
    const x = cx + Math.cos(a)*rr;
    const y = cy + Math.sin(a)*rr;
    g.fillStyle = 'rgba(255,255,255,0.08)';
    g.fillRect(x, y, 1, 1);
  }

  // cráteres con rim + sombra
  const craterN = 14;
  for(let i=0;i<craterN;i++){
    const a = mrnd()*TAU;
    const rr = Math.sqrt(mrnd()) * r*0.78;
    const px = cx + Math.cos(a)*rr;
    const py = cy + Math.sin(a)*rr;
    const cr = r*(0.06 + mrnd()*0.16);

    // sombra interna
    g.globalCompositeOperation = 'multiply';
    g.globalAlpha = 0.18;
    const cg = g.createRadialGradient(px + cr*0.18, py + cr*0.18, cr*0.15, px, py, cr);
    cg.addColorStop(0, 'rgba(0,0,0,0.00)');
    cg.addColorStop(1, 'rgba(0,0,0,0.38)');
    g.fillStyle = cg;
    g.beginPath();
    g.arc(px, py, cr, 0, TAU);
    g.fill();

    // rim iluminado
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.18;
    const rg = g.createRadialGradient(px - cr*0.25, py - cr*0.25, cr*0.05, px, py, cr);
    rg.addColorStop(0, 'rgba(255,255,255,0.22)');
    rg.addColorStop(1, 'rgba(255,255,255,0.00)');
    g.fillStyle = rg;
    g.beginPath();
    g.arc(px, py, cr, 0, TAU);
    g.fill();
  }

  g.restore();
  g.restore();

  moonCache = off;
  moonCacheR = r;
  moonCachePad = pad;
}

function moonIntroProgress(t){
  if(CONFIG.reduceMotion) return 1;
  if(!INTRO.active) return 1;

  // “se genera” primero, luego el ramo (para que se sienta como una escena construyéndose)
  const start = INTRO.t0 + 120;
  const dur   = 1650;

  const u = clamp((t - start) / dur, 0, 1);
  return smoothstep(0, 1, u);
}

function drawMoon(t){
  const r = Math.min(W,H) * 0.062;
  if(!moonCache || Math.abs(r - moonCacheR) > 0.02) rebuildMoonCache();

  const x = W * LIGHT.x;
  const y = H * LIGHT.y;

  const p = moonIntroProgress(t);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  // halo que “crece”
  const haloOuter = r * (2.0 + 9.5*p);
  const halo = ctx.createRadialGradient(x, y, r*0.22, x, y, haloOuter);
  halo.addColorStop(0, `rgba(255,255,255,${0.22*p})`);
  halo.addColorStop(0.18, `rgba(210,230,255,${0.10*p})`);
  halo.addColorStop(0.52, `rgba(140,190,255,${0.045*p})`);
  halo.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalAlpha = 1;
  ctx.fillStyle = halo;
  ctx.fillRect(0,0,W,H);

  // bloom suave cerca del borde
  const bloomR = r*(1.3 + 2.2*p);
  const bloom = ctx.createRadialGradient(x, y, r*0.6, x, y, bloomR);
  bloom.addColorStop(0, `rgba(255,255,255,${0.18*p})`);
  bloom.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = bloom;
  ctx.beginPath();
  ctx.arc(x, y, bloomR, 0, TAU);
  ctx.fill();

  // disco “aparece” desde el centro (con clip)
  const pad = moonCachePad;
  const drawW = moonCache.width / DPR;
  const drawH = moonCache.height / DPR;
  const dx = x - (r + pad);
  const dy = y - (r + pad);

  if(p < 1){
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, r * clamp(p*1.02, 0, 1), 0, TAU);
    ctx.clip();
    ctx.globalAlpha = 0.98;
    ctx.drawImage(moonCache, dx, dy, drawW, drawH);
    ctx.restore();

    // trazo de contorno “tipo generación”
    ctx.globalAlpha = 0.55 * (0.35 + 0.65*p);
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth = 1.8;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.arc(x, y, r*1.03, -Math.PI/2, -Math.PI/2 + TAU*p);
    ctx.stroke();
  }else{
    ctx.globalAlpha = 1;
    ctx.drawImage(moonCache, dx, dy, drawW, drawH);
  }

  ctx.restore();
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
}
function drawSun(t){
  const r = Math.min(W,H) * 0.064;
  const x = W * LIGHT.x;
  const y = H * LIGHT.y;

  // Aparición “generativa” (igual estilo que la luna)
  const p = moonIntroProgress(t);

  // Micro-ruido determinista rápido (sin Math.random en cada frame)
  let s = ((Math.floor(t/33) ^ 0x9e3779b9) + 12345) >>> 0;
  const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  // 1) Halo principal (cálido) con falloff suave
  const haloOuter = r * (2.6 + 10.5*p);
  const halo = ctx.createRadialGradient(x, y, r*0.18, x, y, haloOuter);
  halo.addColorStop(0.00, `rgba(255,250,230,${0.34*p})`);
  halo.addColorStop(0.10, `rgba(255,220,150,${0.18*p})`);
  halo.addColorStop(0.28, `rgba(255,175,90,${0.075*p})`);
  halo.addColorStop(0.60, `rgba(255,120,55,${0.028*p})`);
  halo.addColorStop(1.00, 'rgba(0,0,0,0)');
  ctx.fillStyle = halo;
  ctx.fillRect(0,0,W,H);

  // 2) “Corona” irregular: pequeñas lenguas de luz alrededor
  ctx.save();
  ctx.translate(x, y);
  ctx.globalAlpha = 0.18 * p;
  ctx.globalCompositeOperation = 'screen';
  const coronaN = 34;
  for(let i=0;i<coronaN;i++){
    const a = (i/coronaN)*TAU + t*0.00022;
    const len = r*(1.25 + 0.60*Math.sin(i*1.7 + t*0.0012));
    const w   = r*(0.20 + 0.12*Math.sin(i*2.3 - t*0.0015));
    const rr  = r*(1.02 + 0.10*Math.sin(i*3.1 + t*0.001));
    const gx  = Math.cos(a)*rr;
    const gy  = Math.sin(a)*rr;

    const g = ctx.createRadialGradient(gx, gy, r*0.03, gx, gy, len);
    g.addColorStop(0.0, 'rgba(255,235,175,0.40)');
    g.addColorStop(0.35,'rgba(255,190,115,0.18)');
    g.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.ellipse(gx, gy, len*0.55, w, a, 0, TAU);
    ctx.fill();
  }
  ctx.restore();

  // 3) Rayos suaves (tipo acuarela), animados muy lento
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(t*0.00010);
  ctx.globalAlpha = 0.11 * p;
  ctx.strokeStyle = 'rgba(255,210,140,0.55)';
  ctx.lineCap = 'round';
  const rayN = 20;
  for(let i=0;i<rayN;i++){
    const a = (i/rayN)*TAU;
    const base = r*(1.10 + 0.06*Math.sin(i*2.1));
    const tip  = r*(2.35 + 0.35*Math.sin(i*1.9 + t*0.001));
    const lw   = 1.2 + 1.0*(0.5 + 0.5*Math.sin(i*1.3));
    ctx.lineWidth = lw;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a)*base, Math.sin(a)*base);
    ctx.lineTo(Math.cos(a)*tip,  Math.sin(a)*tip);
    ctx.stroke();
  }
  ctx.restore();

  // 4) Disco del sol: gradiente con “hot core” y borde más naranja
  // Clip de aparición (para el efecto generativo)
  if(p < 1){
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, r * clamp(p*1.02, 0, 1), 0, TAU);
    ctx.clip();
  }

  const sun = ctx.createRadialGradient(x - r*0.22, y - r*0.18, r*0.08, x, y, r*1.10);
  sun.addColorStop(0.00, 'rgba(255,255,250,1.0)');
  sun.addColorStop(0.40, 'rgba(255,246,190,1.0)');
  sun.addColorStop(0.72, 'rgba(255,205,120,1.0)');
  sun.addColorStop(1.00, 'rgba(255,145,55,1.0)');
  ctx.fillStyle = sun;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, TAU);
  ctx.fill();

  // 5) Textura: granulación sutil + sunspots suaves
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  ctx.globalAlpha = 0.10 * p;
  ctx.fillStyle = 'rgba(120,70,30,0.35)';

  const spots = 7;
  for(let i=0;i<spots;i++){
    const a = rnd()*TAU;
    const rr = r*(0.10 + rnd()*0.65);
    const sx = x + Math.cos(a)*rr;
    const sy = y + Math.sin(a)*rr;
    const sr = r*(0.05 + rnd()*0.10);
    ctx.beginPath();
    ctx.ellipse(sx, sy, sr*(1.2+rnd()*0.6), sr*(0.8+rnd()*0.5), rnd()*0.8, 0, TAU);
    ctx.fill();
  }

  // grano muy fino
  ctx.globalAlpha = 0.06 * p;
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  const grains = 40;
  for(let i=0;i<grains;i++){
    const a = rnd()*TAU;
    const rr = r*(0.08 + rnd()*0.88);
    const gx = x + Math.cos(a)*rr;
    const gy = y + Math.sin(a)*rr;
    const gr = r*(0.008 + rnd()*0.016);
    ctx.beginPath();
    ctx.arc(gx, gy, gr, 0, TAU);
    ctx.fill();
  }
  ctx.restore();

  // 6) Rim light (borde brillante) para que “recorte” bien contra el cielo
  ctx.save();
  ctx.globalAlpha = 0.22 * p;
  ctx.strokeStyle = 'rgba(255,255,245,0.65)';
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.arc(x, y, r*1.01, 0, TAU);
  ctx.stroke();
  ctx.restore();

  if(p < 1){
    ctx.restore(); // clip
    // Trazo “tipo generación” (borde que se completa)
    ctx.globalAlpha = 0.55 * (0.35 + 0.65*p);
    ctx.strokeStyle = 'rgba(255,245,215,0.75)';
    ctx.lineWidth = 1.9;
    ctx.beginPath();
    ctx.arc(x, y, r*1.04, -Math.PI/2, -Math.PI/2 + TAU*p);
    ctx.stroke();
  }

  ctx.restore();
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
}



  function seedSoil(){
    soil.length = 0;
    const gy = H * 0.74;
    const groundH = H - gy;

    const blobs = clamp(Math.floor(W / 160), 6, 12);
    for(let i=0;i<blobs;i++){
      soil.push({
        x: W*(0.05 + Math.random()*0.90),
        y: gy + groundH*(0.25 + Math.random()*0.75),
        r: (90 + Math.random()*220),
        a: (0.08 + Math.random()*0.12)
      });
    }
  }

  function seedGrass(){
    grass.length = 0;

    const gy = H * 0.74;
    const groundH = H - gy;

    // Más pasto “arriba” para que no se vea una banda plana y el ramo no parezca flotando.
    // También damos un poquito más de densidad cerca del centro (donde está el ramo).
    const tufts = clamp(Math.floor(W / 14), 46, 120);
    const bladesBase = 11;
    const bladesExtra = 11;

    const center = W * 0.5;

    for(let t=0;t<tufts;t++){
      const tx = (t + Math.random()*0.85) * (W / tufts);
      const cx = Math.abs(tx - center) / Math.max(1, W*0.5);
      const bonus = (cx < 0.35) ? 3 : 0; // densidad sutil extra al centro

      const tuftSeed = Math.random()*TAU;
      const count = bladesBase + Math.floor(Math.random()*bladesExtra) + bonus;

      for(let i=0;i<count;i++){
        const r = Math.random();
        const layer = (r < 0.50) ? 0 : (r < 0.84 ? 1 : 2);

        // Antes el pasto “nacía” muy abajo. Ahora nace cerca del borde superior del suelo (gy)
        // y se vuelve más alto/denso hacia abajo.
        const baseBand = layer===2 ? 0.22 : (layer===1 ? 0.08 : 0.04);

        // Distribución: capas 0/1 más cerca del horizonte, capa 2 más hacia abajo.
        const u = (layer===2 ? Math.sqrt(Math.random()) : Math.pow(Math.random(), 1.55));
        const ty = gy + groundH*(baseBand + u*(1-baseBand));

        const jitterX = (Math.random()-0.5) * (12 + layer*22);
        const jitterY = (Math.random()-0.5) * (6 + layer*10);

        const depth = clamp((ty - gy) / Math.max(1e-6, groundH), 0, 1);

        const hBase = layer===2 ? 78 : (layer===1 ? 54 : 38);
        const hVar  = layer===2 ? 96 : (layer===1 ? 70 : 50);

        // Más corto cerca del horizonte (depth~0), más largo hacia abajo (depth~1)
        const hScale = (layer===2 ? (0.70 + 0.60*depth) : (0.52 + 0.90*depth));
        const h = (hBase + Math.random()*hVar) * hScale;

        const curlAmp = layer===2 ? 0.65 : (layer===1 ? 0.55 : 0.45);

        const aBase = (layer===2 ? 0.18 : (layer===1 ? 0.14 : 0.11)) + Math.random()*(layer===2 ? 0.22 : (layer===1 ? 0.18 : 0.14));
        // Más transparente arriba, más presente abajo
        const a = aBase * (0.60 + 0.55*depth);

        grass.push({
          layer,
          x: tx + jitterX,
          y: ty + jitterY,
          h,
          w: (layer===2 ? 1.55 : (layer===1 ? 1.05 : 0.78)) + Math.random()*(layer===2 ? 1.55 : (layer===1 ? 1.10 : 0.90)),
          p: tuftSeed + i*0.52 + Math.random()*0.85,
          s: (layer===2 ? 0.72 : (layer===1 ? 0.90 : 0.66)) + Math.random()*(layer===2 ? 1.05 : (layer===1 ? 1.05 : 1.00)),
          a,
          bend: (layer===2 ? 1.35 : (layer===1 ? 1.10 : 0.95)) + Math.random()*0.35,
          curl: (Math.random()-0.5) * curlAmp,
          thick: layer===2 ? (0.55 + Math.random()*0.85) : 0,
          tip: 0.75 + Math.random()*0.9
        });
      }
    }

    grassAnim1.length = 0;
    grassAnim2.length = 0;

    const g1 = [];
    const g2 = [];
    for(const b of grass){
      if(b.layer === 1) g1.push(b);
      else if(b.layer === 2) g2.push(b);
    }

    shuffleInPlace(g1);
    shuffleInPlace(g2);

    const gf = (CONFIG.grassAnimFactor ?? 1.0);

    const max1 = clamp(Math.floor(W * 0.55 * gf), 220, 720);
    const max2 = clamp(Math.floor(W * 0.40 * gf), 180, 600);

    grassAnim1.push(...g1.slice(0, max1));
    grassAnim2.push(...g2.slice(0, max2));
  }

  function rebuildGroundCache(){
    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const gy = H * 0.74;
    const groundH = H - gy;

    const gy0 = gy - 44; // entra suave arriba del suelo (evita “corte”)
    const gg = g.createLinearGradient(0, gy0, 0, H);
    gg.addColorStop(0, 'rgba(8,14,10,0.0)');
    gg.addColorStop(0.10, 'rgba(8,14,10,0.04)');
    gg.addColorStop(0.22, 'rgba(16,44,28,0.28)');
    gg.addColorStop(0.66, 'rgba(8,22,16,0.60)');
    gg.addColorStop(1, 'rgba(0,0,0,0.78)');
    g.fillStyle = gg;
    g.fillRect(0, gy0, W, H - gy0);

    // variación de tono (parches) para evitar banda plana
    for(let i=0;i<8;i++){
      const x = Math.random()*W;
      const y = gy + Math.random()*groundH;
      const r = 120 + Math.random()*260;
      const pg = g.createRadialGradient(x,y, 10, x,y, r);
      pg.addColorStop(0, `rgba(${18+Math.random()*10|0},${70+Math.random()*50|0},${40+Math.random()*30|0},0.10)`);
      pg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = pg;
      g.fillRect(0, gy-20, W, groundH+40);
    }


    for(const b of soil){
      const rg = g.createRadialGradient(b.x, b.y, 8, b.x, b.y, b.r);
      rg.addColorStop(0, `rgba(25,85,48,${b.a})`);
      rg.addColorStop(0.55, `rgba(12,40,24,${b.a*0.55})`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.fillRect(0,0,W,H);
    }

    g.save();
    g.globalAlpha = 0.10;
    g.fillStyle = 'rgba(255,255,255,0.08)';
    const dots = clamp(Math.floor(W * groundH / 1800), 180, 420);
    for(let i=0;i<dots;i++){
      const x = Math.random()*W;
      const y = gy + Math.random()*groundH;
      const r = 0.6 + Math.random()*1.4;
      g.beginPath();
      g.arc(x,y,r,0,TAU);
      g.fill();
    }
    g.restore();

    const drawStaticBlade = (b, front) => {
      const x0 = b.x, y0 = b.y;
      const len = b.h;
      const tilt = b.curl*0.18;

      const x1 = x0 + tilt * (10 + b.bend*5);
      const y1 = y0 - len;

      const cx = x0 + tilt * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      g.strokeStyle = front ? 'rgba(24,105,62,1)' : 'rgba(16,75,44,1)';
      g.lineWidth = b.w * (front ? 1.10 : 1.0);
      g.beginPath();
      g.moveTo(x0, y0);
      g.quadraticCurveTo(cx, cy, x1, y1);
      g.stroke();

      const old = g.globalAlpha;
      g.globalAlpha = old * (front ? 0.22 : 0.16);
      g.strokeStyle = 'rgba(190,255,220,1)';
      g.lineWidth = Math.max(0.7, b.w*0.30);
      g.beginPath();
      g.moveTo(x0 + 0.7, y0);
      g.quadraticCurveTo(cx + 0.5, cy, x1 + 0.3, y1);
      g.stroke();
      g.globalAlpha = old;
    };

    g.save();
    for(const b of grass){
      if(b.layer !== 0) continue;
      g.globalAlpha = 0.18 + b.a*0.90;
      drawStaticBlade(b, false);
    }
    g.restore();

    g.save();
    for(const b of grass){
      if(b.layer !== 1) continue;
      if(b.h > 90) continue;
      g.globalAlpha = 0.16 + b.a*0.80;
      drawStaticBlade(b, true);
    }
    g.restore();

    const fogTop = gy + groundH*0.18;
    const fog = g.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(1, 'rgba(0,0,0,0.34)');
    g.fillStyle = fog;
    g.fillRect(0, fogTop, W, H - fogTop);

    groundCache = off;
  }
  function rebuildFieldCache(){
    // Campo/montañas de fondo (v3):
    // - Montañas lejanas con picos (ridged noise)
    // - Niebla/atmosfera por capas
    // - Colinas medias con rim light + sombras + textura
    // - Pasto y mini-flores como antes
    // Cacheado para rendimiento.
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@d${DPR.toFixed(2)}@q${q}`;
    if(fieldCache && fieldCacheKey === key) return;
    fieldCacheKey = key;

    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    // PRNG estable
    let s = ((W*912367) ^ (H*12347) ^ ((q+1)*918273)) >>> 0;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const topBand = H*0.56;   // inicio del campo (deja cielo arriba)
    const midBand = H*0.70;

    // Base del campo (gradiente)
    const base = g.createLinearGradient(0, topBand, 0, H);
    base.addColorStop(0, 'rgba(7,18,14,0.18)');
    base.addColorStop(0.30, 'rgba(16,56,34,0.44)');
    base.addColorStop(0.70, 'rgba(12,46,30,0.66)');
    base.addColorStop(1, 'rgba(6,22,14,0.86)');
    g.fillStyle = base;
    g.fillRect(0, topBand, W, H-topBand);

    // Helper: contorno con “bulto” central (zona del ramo)
    const ridgeY = H*0.62;

    // Ridged noise: crea picos más “montaña” (no solo ondas suaves)
    const ridged = (x, freq, phase, power=0.35) => {
      const v = Math.abs(Math.sin(x*freq + phase));
      return Math.pow(v, power);
    };

    // Perfil base (con peak central) + ondas + ridged peaks
    const profile = (x, yEdge, yPeak, wav, bump, seedShift, jag=0.0) => {
      const xn = (x / W) - 0.5;
      const peak = yPeak - Math.exp(-(xn*xn)/(bump*bump)) * (yEdge - yPeak);

      const w1 = Math.sin(xn*(6.0+seedShift) + 0.8) * wav;
      const w2 = Math.sin(xn*(13.5+seedShift*1.1) - 0.4) * (wav*0.46);
      const w3 = Math.sin(xn*(22.0+seedShift*1.7) + 1.1) * (wav*0.22);

      // Ridged term for jagged peaks (mountains)
      const r1 = (ridged(xn, 10.0+seedShift*1.2, 0.7+seedShift*0.9) - 0.55) * (wav*2.4) * jag;
      const r2 = (ridged(xn, 19.0+seedShift*1.6, 1.2-seedShift*0.4) - 0.55) * (wav*1.4) * jag;

      return peak + w1 + w2 + w3 + r1 + r2;
    };

    // Montañas lejanas (mejoradas):
    // - Más capas (profundidad real)
    // - Silueta más fina (más puntos)
    // - Nieve sutil en cumbres + textura ligera
    // - Rim light más creíble (más fuerte hacia el lado de la luna)
    const mountains = [
      {yEdge: H*0.590, yPeak: H*0.515, wav: H*0.018, bump:0.70, a:0.16, seed:0.7, jag:0.76, tint:[34,60,82], snow:0.34},
      {yEdge: H*0.612, yPeak: H*0.538, wav: H*0.022, bump:0.62, a:0.20, seed:1.4, jag:0.86, tint:[26,48,66], snow:0.26},
      {yEdge: H*0.642, yPeak: H*0.558, wav: H*0.028, bump:0.56, a:0.24, seed:2.2, jag:0.96, tint:[18,38,52], snow:0.18},
      {yEdge: H*0.673, yPeak: H*0.584, wav: H*0.033, bump:0.50, a:0.28, seed:3.0, jag:1.06, tint:[10,26,36], snow:0.12},
    ];

    for(let k=0;k<mountains.length;k++){
      const M = mountains[k];
      const steps = 140;           // silueta más suave
      const pts = [];

      // Gradient for mountain body (más “atmosfera” arriba)
      const grad = g.createLinearGradient(0, M.yPeak-60, 0, M.yEdge+170);
      grad.addColorStop(0, `rgba(${M.tint[0]},${M.tint[1]},${M.tint[2]},0.78)`);
      grad.addColorStop(0.55, `rgba(${Math.max(0,M.tint[0]-10)},${Math.max(0,M.tint[1]-14)},${Math.max(0,M.tint[2]-18)},0.62)`);
      grad.addColorStop(1, `rgba(0,0,0,0.66)`);

      // Build profile points once (para todo)
      for(let i=0;i<=steps;i++){
        const x = (i/steps)*W;
        const y = profile(x, M.yEdge, M.yPeak, M.wav, M.bump, M.seed, M.jag);
        pts.push({x,y});
      }

      // Mountain body
      g.save();
      g.globalAlpha = M.a;
      g.fillStyle = grad;
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Haze per-layer (profundidad): cuanto más lejos, más neblina azul
      g.save();
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = 0.08 * (1 - k/(mountains.length-1));
      const hz = g.createLinearGradient(0, M.yPeak-40, 0, M.yEdge+160);
      hz.addColorStop(0, 'rgba(140,190,235,0.22)');
      hz.addColorStop(1, 'rgba(0,0,0,0.0)');
      g.fillStyle = hz;
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Crevices: pliegues oscuros (mejor direccionados)
      if(q >= 2){
        g.save();
        g.globalAlpha = 0.075 + 0.02*k;
        g.strokeStyle = 'rgba(0,0,0,0.58)';
        g.lineWidth = 1.0;
        g.lineCap = 'round';

        // Clip dentro de la montaña
        g.beginPath();
        g.moveTo(0, H);
        for(const p of pts) g.lineTo(p.x, p.y);
        g.lineTo(W, H);
        g.closePath();
        g.clip();

        const lines = 22 + k*10;
        for(let n=0;n<lines;n++){
          const x0 = rnd()*W;
          const yTop = profile(x0, M.yEdge, M.yPeak, M.wav, M.bump, M.seed, M.jag);
          const y0 = yTop + rnd()*((M.yEdge+170)-yTop);

          const tilt = (LIGHT.x - 0.5); // hacia la luna (derecha)
          const dx = (0.6 + rnd()*1.0) * W*0.02 * (tilt>=0 ? 1 : -1);
          const dy = (0.12 + rnd()*0.60) * H*0.095;

          g.beginPath();
          g.moveTo(x0, y0);
          g.quadraticCurveTo(x0 + dx*0.5, y0 + dy*0.45, x0 + dx, y0 + dy);
          g.stroke();
        }
        g.restore();
      }

      // Nieve sutil en cumbres (solo arriba) + algo de “grano”
      if(q >= 2 && M.snow > 0){
        g.save();
        // clip montaña
        g.beginPath();
        g.moveTo(0, H);
        for(const p of pts) g.lineTo(p.x, p.y);
        g.lineTo(W, H);
        g.closePath();
        g.clip();

        // region alta (cerca del peak)
        const ySnow = M.yPeak + (M.yEdge - M.yPeak)*0.34;
        g.globalCompositeOperation = 'screen';
        g.globalAlpha = 0.10 + M.snow*0.28;

        const snowGrad = g.createLinearGradient(0, M.yPeak-50, 0, ySnow+130);
        snowGrad.addColorStop(0, 'rgba(255,255,255,0.70)');
        snowGrad.addColorStop(0.35, 'rgba(220,240,255,0.46)');
        snowGrad.addColorStop(1, 'rgba(200,230,255,0.00)');
        g.fillStyle = snowGrad;

        const patches = 16 + Math.floor(10*(1 - k/(mountains.length-1)));
        for(let p=0;p<patches;p++){
          const x = rnd()*W;
          const yR = profile(x, M.yEdge, M.yPeak, M.wav, M.bump, M.seed, M.jag);
          if(yR > ySnow) continue;
          const r = (W*0.008 + rnd()*W*0.020) * (1.10 - 0.18*k);
          const ang = rnd()*0.9;
          g.beginPath();
          g.ellipse(x, yR + rnd()*18, r*1.35, r*0.85, ang, 0, TAU);
          g.fill();
        }

        // grano leve (textura)
        g.globalAlpha = 0.035 + 0.01*(1 - k/(mountains.length-1));
        g.fillStyle = 'rgba(255,255,255,0.55)';
        const grains = 260 + k*120;
        for(let t=0;t<grains;t++){
          const x = rnd()*W;
          const y = M.yPeak + rnd()*((M.yEdge+160)-M.yPeak);
          if(y < ySnow + 70) continue;
          g.beginPath();
          g.arc(x, y, 0.4 + rnd()*0.9, 0, TAU);
          g.fill();
        }

        g.restore();
      }

      // Rim light (luna): más fuerte hacia la derecha
      g.save();
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = 0.10 + 0.05*k;
      const rim = g.createLinearGradient(W*0.10, 0, W, 0);
      rim.addColorStop(0.00, 'rgba(210,240,255,0.00)');
      rim.addColorStop(0.58, 'rgba(210,240,255,0.18)');
      rim.addColorStop(1.00, 'rgba(210,240,255,0.34)');
      g.strokeStyle = rim;
      g.lineWidth = 1.2 + 0.7*(k/(mountains.length-1));
      g.lineJoin = 'round';
      g.lineCap = 'round';
      g.beginPath();
      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        if(i===0) g.moveTo(p.x, p.y);
        else g.lineTo(p.x, p.y);
      }
      g.stroke();
      g.restore();
    }

    // Niebla atmosférica: separa montañas del campo
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.22;
    const fog = g.createLinearGradient(0, topBand-30, 0, topBand+160);
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(0.35, 'rgba(30,60,70,0.18)');
    fog.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = fog;
    g.fillRect(0, topBand-40, W, 220);
    g.restore();

    // Colinas medias (más verdes, detrás del arbusto)
    const layers = [
      {yEdge: H*0.66, yPeak: ridgeY-20, wav: H*0.016, bump:0.52, a:0.20, sat:0.62, seed:0.8},
      {yEdge: H*0.69, yPeak: ridgeY-16, wav: H*0.020, bump:0.50, a:0.25, sat:0.70, seed:1.4},
      {yEdge: H*0.72, yPeak: ridgeY-12, wav: H*0.026, bump:0.46, a:0.31, sat:0.82, seed:2.0},
      {yEdge: H*0.75, yPeak: ridgeY- 6, wav: H*0.034, bump:0.42, a:0.37, sat:0.94, seed:2.7},
      {yEdge: H*0.79, yPeak: ridgeY+ 4, wav: H*0.046, bump:0.38, a:0.43, sat:1.06, seed:3.3},
    ];

    for(let k=0;k<layers.length;k++){
      const L = layers[k];
      const col = g.createLinearGradient(0, topBand, 0, H);
      col.addColorStop(0, `rgba(30,110,70,${0.07*L.sat})`);
      col.addColorStop(0.55, `rgba(16,70,44,${0.24*L.sat})`);
      col.addColorStop(1, `rgba(4,18,12,${0.46*L.sat})`);

      g.save();
      g.globalAlpha = L.a;
      g.fillStyle = col;

      g.beginPath();
      g.moveTo(0, H);
      const steps = 72;
      const pts = [];
      for(let i=0;i<=steps;i++){
        const x = (i/steps)*W;
        const y = profile(x, L.yEdge, L.yPeak, L.wav, L.bump, L.seed, 0.0);
        pts.push({x,y});
        g.lineTo(x, y);
      }
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Sombras internas
      g.save();
      g.globalCompositeOperation = 'multiply';
      g.globalAlpha = 0.12 + 0.06*(k/layers.length);
      const shade = g.createLinearGradient(0, L.yPeak-20, 0, L.yEdge+90);
      shade.addColorStop(0, 'rgba(0,0,0,0)');
      shade.addColorStop(1, 'rgba(0,0,0,0.45)');
      g.fillStyle = shade;
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.fill();
      g.restore();

      // Rim light
      g.save();
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = 0.07 + 0.05*(k/layers.length);
      g.strokeStyle = 'rgba(230,255,245,0.22)';
      g.lineWidth = 1.1 + 0.6*(k/layers.length);
      g.lineJoin = 'round';
      g.lineCap = 'round';
      g.beginPath();
      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        if(i===0) g.moveTo(p.x, p.y);
        else g.lineTo(p.x, p.y);
      }
      g.stroke();
      g.restore();

      // Textura: motas + micro “contours”
      const specks = (q>=3?260: q>=2?180:120) * (0.55 + 0.55*(k/layers.length));
      g.save();
      g.globalAlpha = 0.05 + 0.04*(k/layers.length);
      g.fillStyle = 'rgba(255,255,255,0.30)';
      g.beginPath();
      g.moveTo(0, H);
      for(const p of pts) g.lineTo(p.x, p.y);
      g.lineTo(W, H);
      g.closePath();
      g.clip();
      for(let n=0;n<specks;n++){
        const x = rnd()*W;
        const yTop = profile(x, L.yEdge, L.yPeak, L.wav, L.bump, L.seed, 0.0);
        const y = yTop + rnd()*(H - yTop);
        const r = 0.6 + rnd()*1.6;
        g.beginPath();
        g.arc(x, y, r, 0, TAU);
        g.fill();
      }
      if(q>=3){
        g.globalAlpha *= 0.80;
        g.strokeStyle = 'rgba(0,0,0,0.12)';
        g.lineWidth = 1.0;
        for(let n=0;n<22;n++){
          const yOff = (8 + rnd()*38) * (0.55 + 0.55*(k/layers.length));
          g.beginPath();
          for(let i=0;i<pts.length;i++){
            const p = pts[i];
            const yy = p.y + yOff + Math.sin(i*0.35 + n*0.7)*2.0;
            if(i===0) g.moveTo(p.x, yy);
            else g.lineTo(p.x, yy);
          }
          g.stroke();
        }
      }
      g.restore();

      if(k <= 1){
        g.save();
        g.globalAlpha = 0.10;
        const fog2 = g.createLinearGradient(0, topBand, 0, midBand);
        fog2.addColorStop(0, 'rgba(0,0,0,0)');
        fog2.addColorStop(1, 'rgba(0,0,0,0.16)');
        g.fillStyle = fog2;
        g.fillRect(0, topBand, W, midBand-topBand);
        g.restore();
      }
    }

    // Pasto “en perspectiva”
    const grassCount = q>=3 ? 1300 : q>=2 ? 950 : 700;
    g.save();
    g.globalCompositeOperation = 'screen';
    for(let i=0;i<grassCount;i++){
      const t = rnd();
      const y = topBand + (H-topBand)*(t*t);
      const x = rnd()*W;

      const depth = clamp((y-topBand)/(H-topBand), 0, 1);
      const len = (2.0 + rnd()*7.8) * (0.18 + 1.35*depth);
      const tilt = (rnd()*0.8 - 0.4) + (depth-0.5)*0.22;

      const a = 0.014 + 0.050*depth;
      const shade = 0.55 + 0.45*rnd();
      const rr = Math.round(18 + 36*shade);
      const gg2= Math.round(72 + 120*shade);
      const bb = Math.round(38 + 64*shade);

      g.globalAlpha = a;
      g.strokeStyle = `rgba(${rr},${gg2},${bb},0.9)`;
      g.lineWidth = 0.9 + 1.1*depth;
      g.lineCap = 'round';

      g.beginPath();
      g.moveTo(x, y);
      g.lineTo(x + Math.sin(tilt)*len, y - Math.cos(tilt)*len);
      g.stroke();
    }
    g.restore();

    // Florecitas pequeñas
    const flowers = q>=3 ? 440 : q>=2 ? 320 : 240;
    g.save();
    for(let i=0;i<flowers;i++){
      const t = rnd();
      const y = topBand + (H-topBand)*(t*t);
      const x = rnd()*W;

      const depth = clamp((y-topBand)/(H-topBand), 0, 1);
      const size = (0.6 + rnd()*1.7) * (0.22 + 1.05*depth);
      const alpha = (0.06 + 0.10*(1-depth)) * (0.65 + 0.55*rnd());

      const pick = rnd();
      let c = 'rgba(255,220,235,';        // rosa suave
      if(pick < 0.33) c = 'rgba(230,235,255,';      // lavanda frío
      else if(pick < 0.66) c = 'rgba(255,240,215,'; // crema

      g.globalAlpha = alpha;
      g.fillStyle = c + (0.42 + 0.28*rnd()) + ')';
      const r = 1.8*size;
      for(let p=0;p<4;p++){
        const ang = p*(TAU/4) + rnd()*0.22;
        g.beginPath();
        g.ellipse(x + Math.cos(ang)*r, y + Math.sin(ang)*r*0.72, 1.05*size, 0.78*size, ang, 0, TAU);
        g.fill();
      }
      g.globalAlpha = alpha*0.9;
      g.fillStyle = 'rgba(255,215,140,0.40)';
      g.beginPath();
      g.arc(x, y, 0.90*size, 0, TAU);
      g.fill();
    }
    g.restore();

    // Viñeta para integrar con el cielo
    const blend = g.createLinearGradient(0, topBand-40, 0, topBand+120);
    blend.addColorStop(0, 'rgba(0,0,0,0)');
    blend.addColorStop(1, 'rgba(0,0,0,0.18)');
    g.fillStyle = blend;
    g.fillRect(0, topBand-40, W, 160);

    fieldCache = off;
  }

  function rebuildFieldBandCache(){
    // Campo/montañas dibujados SIN cortes: aplicamos una máscara vertical suave en un canvas auxiliar
    rebuildFieldCache();
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@d${DPR.toFixed(2)}@q${q}`;
    if(fieldBandCache && fieldBandCacheKey === key) return;
    fieldBandCacheKey = key;

    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);
    g.clearRect(0,0,W,H);

    if(fieldCache){
      g.drawImage(fieldCache, 0, 0, fieldCache.width / DPR, fieldCache.height / DPR);
    }

    // Máscara: entra suave, se mantiene, sale suave (elimina el “corte”)
    const top = H*0.46;
    const inY = H*0.52;
    const outY= H*0.74;  // cerca del inicio del pasto
    const bot = H*0.82;

    g.globalCompositeOperation = 'destination-in';
    const mask = g.createLinearGradient(0, top, 0, bot);
    const aIn  = (inY - top) / (bot - top);
    const aOut = (outY - top) / (bot - top);
    mask.addColorStop(0.0, 'rgba(0,0,0,0)');
    mask.addColorStop(Math.max(0.01, Math.min(0.35, aIn)),  'rgba(0,0,0,1)');
    mask.addColorStop(Math.max(0.55, Math.min(0.90, aOut)), 'rgba(0,0,0,1)');
    mask.addColorStop(1.0, 'rgba(0,0,0,0)');

    g.fillStyle = mask;
    g.fillRect(0, top-80, W, (bot-top)+160);

    fieldBandCache = off;
  }





  function drawGrass(t){
    if(groundCache){
      ctx.drawImage(groundCache, 0, 0, groundCache.width / DPR, groundCache.height / DPR);
    }
    const gy = H * 0.74;
    const groundH = H - gy;

    const wind = windField(t) * 0.75;

    const detail = (CONFIG.grassDetail ?? 1);
    const step = detail ? 1 : 2;

    const drawBlade = (b, front) => {
      const xN = (b.x / W) - 0.5;
      const gWind = CONFIG.reduceMotion ? 0 : (Math.sin(t*0.00062)*0.92 + Math.sin(t*0.00114)*0.32);
      const gust  = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00035 + xN*2.8) * 0.22;
      const micro = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00120*b.s + b.p) * 0.08;
      const sway  = (gWind*0.55 + gust + micro) * 0.22 * CONFIG.sway;
      const sway2 = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00135*b.s + b.p*0.7) * 0.08;

      const x0 = b.x;
      const y0 = b.y;
      const len = b.h;

      const tilt = (sway + wind + b.curl*0.22);
      const x1 = x0 + tilt * (9 + b.bend*6);
      const y1 = y0 - len;

      const cx = x0 + (tilt + sway2) * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      if(front){
        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.18;
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        ctx.beginPath();
        ctx.ellipse(x0, y0+1.2, 3.2 + b.w, 1.2 + b.w*0.34, 0, 0, TAU);
        ctx.fill();
        ctx.globalAlpha = old;
      }

      if(detail && b.layer === 2){
        const w0 = b.w * (1.00 + b.thick);
        const w1 = Math.max(0.8, w0 * 0.16);

        const t0x = x0, t0y = y0;
        const t1x = cx, t1y = cy;
        const t2x = x1, t2y = y1;

        const dx = t2x - t0x;
        const dy = t2y - t0y;
        const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
        const px = -dy * inv;
        const py =  dx * inv;

        ctx.save();
        ctx.fillStyle = front ? 'rgba(35,125,75,0.72)' : 'rgba(18,88,52,0.72)';

        ctx.beginPath();
        ctx.moveTo(t0x + px*w0, t0y + py*w0);
        ctx.quadraticCurveTo(t1x + px*(w0*0.60), t1y + py*(w0*0.60), t2x + px*w1, t2y + py*w1);
        ctx.lineTo(t2x - px*w1, t2y - py*w1);
        ctx.quadraticCurveTo(t1x - px*(w0*0.52), t1y - py*(w0*0.52), t0x - px*w0, t0y - py*w0);
        ctx.closePath();
        ctx.fill();

        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.24;
        ctx.strokeStyle = 'rgba(215,255,235,0.32)';
        ctx.lineWidth = Math.max(0.8, b.w*0.34);
        ctx.beginPath();
        ctx.moveTo(x0 + px*0.4, y0 + py*0.4);
        ctx.quadraticCurveTo(cx + px*0.2, cy + py*0.2, x1 + px*0.10, y1 + py*0.10);
        ctx.stroke();
        ctx.globalAlpha = old;

        ctx.restore();
      }

      ctx.strokeStyle = front ? 'rgba(22,98,58,1)' : 'rgba(18,72,42,1)';
      ctx.lineWidth = b.w * (front ? 1.12 : 1.0);
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();

      const old = ctx.globalAlpha;
      ctx.globalAlpha = old * (front ? 0.22 : 0.16);
      ctx.strokeStyle = 'rgba(190,255,220,1)';
      ctx.lineWidth = Math.max(0.7, b.w*0.30);
      ctx.beginPath();
      ctx.moveTo(x0 + 0.8, y0);
      ctx.quadraticCurveTo(cx + 0.55, cy, x1 + 0.35, y1);
      ctx.stroke();
      ctx.globalAlpha = old;
    };

    ctx.save();
    for(let i=0;i<grassAnim1.length;i+=step){
      const b = grassAnim1[i];
      ctx.globalAlpha = 0.16 + b.a*0.92;
      drawBlade(b, false);
    }
    ctx.restore();

    ctx.save();
    for(let i=0;i<grassAnim2.length;i+=step){
      const b = grassAnim2[i];
      ctx.globalAlpha = 0.22 + b.a*0.98;
      drawBlade(b, true);
    }
    ctx.restore();


    // Bruma del horizonte: ayuda a que el césped no se vea "pegado" y disimula el corte con los tallos
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const hzTop = gy - 90;
    const hzBot = gy + 40;
    const hz = ctx.createLinearGradient(0, hzTop, 0, hzBot);
    hz.addColorStop(0, 'rgba(120,150,220,0)');
    hz.addColorStop(0.35, 'rgba(120,150,220,0.07)');
    hz.addColorStop(0.70, 'rgba(90,120,200,0.04)');
    hz.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = hz;
    ctx.fillRect(0, hzTop, W, hzBot - hzTop);
    ctx.restore();

    // Sombra suave en la unión: elimina el “corte” y pega el ramo al suelo
    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    const seamTop = gy - 18;
    const seamBot = gy + 110;
    const seam = ctx.createLinearGradient(0, seamTop, 0, seamBot);
    seam.addColorStop(0, 'rgba(0,0,0,0)');
    seam.addColorStop(0.45, 'rgba(0,0,0,0.16)');
    seam.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = seam;
    ctx.fillRect(0, seamTop, W, seamBot - seamTop);
    ctx.restore();

    ctx.save();
    const thatchTop = gy + groundH*0.74;
    const tg = ctx.createLinearGradient(0, thatchTop, 0, H);
    tg.addColorStop(0, 'rgba(0,0,0,0)');
    tg.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = tg;
    ctx.fillRect(0, thatchTop, W, H - thatchTop);
    ctx.restore();
    if(detail && !(CONFIG.reduceMotion && !CONFIG.forceFlowerMotion)){
      ctx.save();
      ctx.globalAlpha = 0.05;
      ctx.fillStyle = 'rgba(220,255,240,0.18)';
      const drops = 16;
      for(let i=0;i<drops;i++){
        const x = W*(0.18 + Math.random()*0.64);
        const y = (gy + groundH*0.25) + Math.random()*(groundH*0.70);
        ctx.beginPath();
        ctx.arc(x,y, 0.9 + Math.random()*1.2, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  // ===== Texto hecho con estrellas =====
  function buildStarText(){
    textStars.length = 0;

    const sMin = Math.min(W, H);
    let fontSize = clamp(sMin * 0.09, 26, 58);

    const tc = document.createElement('canvas');
    tc.width = Math.floor(W);
    tc.height = Math.floor(H);
    const g = tc.getContext('2d', {alpha:true});

    const x = tc.width * 0.5;
    const y = tc.height * 0.28;

    g.clearRect(0,0,tc.width,tc.height);
    g.textAlign = 'center';
    g.textBaseline = 'middle';
    g.font = `700 ${Math.round(fontSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;

    const maxW = tc.width * 0.92;
    const mt = g.measureText(CONFIG.starText);
    if(mt.width > maxW){
      fontSize = clamp(fontSize * (maxW / mt.width), 18, fontSize);
      g.font = `700 ${Math.round(fontSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    }

    g.fillStyle = 'rgba(255,255,255,1)';
    g.fillText(CONFIG.starText, x, y);

    const img = g.getImageData(0,0,tc.width,tc.height).data;

    const step = clamp(Math.round(fontSize / 7.2), 3, 7);
    const maxPts = clamp(Math.floor((W*H)/1300), 700, 1700);

    const pr = makePRNG((W*73856093) ^ (H*19349663) ^ 0xC0FFEE);

    const minX = Math.max(0, Math.floor(x - tc.width*0.45));
    const maxX = Math.min(tc.width-1, Math.floor(x + tc.width*0.45));
    const minY = Math.max(0, Math.floor(y - fontSize*1.2));
    const maxY = Math.min(tc.height-1, Math.floor(y + fontSize*1.0));

    const candidates = [];
    for(let yy=minY; yy<=maxY; yy+=step){
      for(let xx=minX; xx<=maxX; xx+=step){
        const idx = (yy*tc.width + xx)*4 + 3;
        const a = img[idx];
        if(a > 20){
          candidates.push({x: xx/tc.width, y: yy/tc.height, a: a/255});
        }
      }
    }

    shuffleInPlace(candidates);
    const chosen = candidates.slice(0, maxPts);

    for(const p of chosen){
      const sizeJ = pr();
      const r = (0.65 + sizeJ*1.25) * (fontSize/46);
      const alpha = (0.10 + p.a*0.35) * CONFIG.starTextStrength;

      const temp = pr();
      let hue = 0;
      if(temp < 0.20) hue = 205 + pr()*30;
      else if(temp < 0.28) hue = 35 + pr()*16;

      textStars.push({
        x: p.x, y: p.y,
        r,
        a: alpha,
        p: pr()*TAU,
        s: 0.55 + pr()*1.05,
        hue,
        flare: (pr() < 0.12) ? (0.15 + pr()*0.35) : 0
      });
    }

    // halo disperso alrededor del texto: suaviza bordes y lo integra al cielo
    const haloBudget = Math.min(28, Math.max(10, Math.floor(textStars.length * 0.20)));
    for(let i=0;i<haloBudget;i++){
      const b = textStars[(Math.random()*textStars.length)|0];
      const hx = clamp(b.x + (Math.random()*2-1)*0.032, 0.02, 0.98);
      const hy = clamp(b.y + (Math.random()*2-1)*0.020, 0.02, 0.60);

      textStars.push({
        x: hx, y: hy,
        r: b.r * (0.55 + Math.random()*0.25),
        a: b.a * (0.22 + Math.random()*0.18),
        tw: b.tw * (0.65 + Math.random()*0.25),
        p: Math.random()*TAU*3
      });
    }

  }

  function drawStarText(t){
    if(!textStars.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    const gx = W*0.5, gy = H*0.28;
    const fontHint = clamp(Math.min(W,H)*0.09, 26, 58);

    // Backdrop oscuro suave para que el mensaje se lea sobre nubes/estrellas
    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    ctx.globalAlpha = 0.28;
    const bg = ctx.createRadialGradient(gx, gy, 0, gx, gy, fontHint*3.2);
    bg.addColorStop(0.0, 'rgba(0,0,0,0.70)');
    bg.addColorStop(0.55,'rgba(0,0,0,0.20)');
    bg.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
    const glow = ctx.createRadialGradient(gx, gy, 10, gx, gy, fontHint*7.5);
    glow.addColorStop(0, 'rgba(210,230,255,0.16)');
    glow.addColorStop(1, 'rgba(210,230,255,0)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = glow;
    ctx.fillRect(0,0,W,H);

    for(const st of textStars){
      const tw = CONFIG.reduceMotion ? 1 : (0.78 + 0.22*Math.sin(t*0.0012*st.s + st.p));
      const alpha = clamp(st.a * (0.95 + 0.85*tw), 0, 1);

      const x = st.x*W;
      const y = st.y*H;

      ctx.globalAlpha = alpha;
      ctx.shadowColor = 'rgba(255,255,255,0.55)';
      ctx.shadowBlur = 9 + st.r*6;

      // Sombra/contorno sutil para contraste (sobre nubes claras)
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = alpha * 0.18;
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.beginPath();
      ctx.arc(x, y, st.r*1.55, 0, TAU);
      ctx.fill();
      ctx.restore();



      ctx.fillStyle = st.hue ? `hsla(${st.hue}, 75%, 92%, 1)` : 'rgba(255,255,255,1)';
      ctx.beginPath();
      ctx.arc(x, y, st.r, 0, TAU);
      ctx.fill();

      if(st.flare){
        ctx.save();
        ctx.shadowBlur = 0;
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = alpha * 0.55 * st.flare;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        const k = 3.0 + st.r*2.0;
        ctx.beginPath();
        ctx.moveTo(x-k, y); ctx.lineTo(x+k, y);
        ctx.moveTo(x, y-k); ctx.lineTo(x, y+k);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }

  // ===== Cielo (cache) =====


  // --- Rendimiento: sprites y layer cacheado (evita sombras/gradientes por estrella cada frame) ---
  let starSprite = null;
  let starSpriteKey = '';
  function rebuildStarSprite(){
    const key = `d${Math.round(DPR*100)}`;
    if(starSprite && starSpriteKey === key) return;
    starSpriteKey = key;

    const size = 40; // px “lógicos”
    const off = document.createElement('canvas');
    off.width = Math.floor(size * DPR);
    off.height = Math.floor(size * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const cx = size/2, cy = size/2;
    const R = size*0.44;

    const rg = g.createRadialGradient(cx, cy, 0, cx, cy, R);
    rg.addColorStop(0.0, 'rgba(255,255,255,0.95)');
    rg.addColorStop(0.18,'rgba(255,255,255,0.38)');
    rg.addColorStop(1.0, 'rgba(255,255,255,0.00)');
    g.fillStyle = rg;
    g.fillRect(0,0,size,size);

    g.fillStyle = 'rgba(255,255,255,1)';
    g.beginPath();
    g.arc(cx, cy, size*0.075, 0, TAU);
    g.fill();

    g.globalAlpha = 0.40;
    g.strokeStyle = 'rgba(255,255,255,0.90)';
    g.lineWidth = 1;
    const k = size*0.18;
    g.beginPath();
    g.moveTo(cx-k, cy); g.lineTo(cx+k, cy);
    g.moveTo(cx, cy-k); g.lineTo(cx, cy+k);
    g.stroke();
    g.globalAlpha = 1;

    starSprite = off;
  }

  function drawStarSprite(g, x, y, r, hue, flare, alpha){
    if(!starSprite) rebuildStarSprite();
    const base = 7.5;
    const fMul = flare ? (1.12 + flare*0.35) : 1.0;
    const sz = Math.max(2, r * base * fMul);

    g.globalAlpha = alpha;
    g.drawImage(starSprite, x - sz/2, y - sz/2, sz, sz);

    if(hue){
      g.save();
      g.globalAlpha = alpha * 0.65;
      g.fillStyle = `hsla(${hue}, 78%, 92%, 1)`;
      g.beginPath();
      g.arc(x, y, Math.max(0.9, r*0.55), 0, TAU);
      g.fill();
      g.restore();
    }
  }

  // Caches: texto del cielo + estrellas (actualizados a 30fps máximo)
  let skyDynCache = null, skyDynCtx = null, skyDynKey = '';
  let skyDynLast = 0;
  let textBackdropCache = null, textBackdropKey = '';

  function rebuildTextBackdropCache(){
    const key = `${W}x${H}@d${DPR.toFixed(2)}@t${CONFIG.starText}`;
    if(textBackdropCache && textBackdropKey === key) return;
    textBackdropKey = key;

    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const gx = W*0.5, gy = H*0.28;
    const fontHint = clamp(Math.min(W,H)*0.09, 26, 58);

    const bg = g.createRadialGradient(gx, gy, 0, gx, gy, fontHint*3.2);
    bg.addColorStop(0.0, 'rgba(0,0,0,0.34)');
    bg.addColorStop(0.55,'rgba(0,0,0,0.12)');
    bg.addColorStop(1.0, 'rgba(0,0,0,0)');
    g.fillStyle = bg;
    g.fillRect(0,0,W,H);

    const glow = g.createRadialGradient(gx, gy, 10, gx, gy, fontHint*7.5);
    glow.addColorStop(0, 'rgba(210,230,255,0.16)');
    glow.addColorStop(1, 'rgba(210,230,255,0)');
    g.fillStyle = glow;
    g.fillRect(0,0,W,H);

    textBackdropCache = off;
  }

  function rebuildSkyDynCache(){
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@d${DPR.toFixed(2)}@q${q}`;
    if(skyDynCache && skyDynKey === key) return;
    skyDynKey = key;

    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);
    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    skyDynCache = off;
    skyDynCtx = g;
    skyDynLast = 0;

    rebuildStarSprite();
    rebuildTextBackdropCache();
  }

  function renderSkyDynamic(t){
    if(!skyDynCtx || !skyDynCache) return;

    const fps = clamp(CONFIG.maxFPS || 60, 24, 60);
    const minStep = 1000 / fps;
    if(skyDynLast && (t - skyDynLast) < minStep) return;
    skyDynLast = t;

    const g = skyDynCtx;
    g.setTransform(DPR,0,0,DPR,0,0);
    g.clearRect(0,0,W,H);

    // wisps dinámicos, pero en cache (30fps)
    g.save();
    g.globalCompositeOperation = 'screen';
    const tt = t*0.000016;
    g.globalAlpha = 0.032;
    const baseAlphaWisp = g.globalAlpha;
    for(let i=0;i<3;i++){
      const x = (W*(0.18 + i*0.32) + (Math.sin(tt*2.6 + i)*W*0.08)) % (W+160) - 80;
      const y = H*(0.05 + 0.10*Math.abs(Math.sin(tt*1.9 + i*1.4)));
      const w = Math.min(W,H)*(0.12 + 0.03*Math.sin(tt*2.0 + i));
      const h = w*0.42;
      const fade = clamp(1 - (y - H*0.16)/(H*0.10), 0, 1);
      if(fade <= 0.01) continue;
      g.globalAlpha = baseAlphaWisp * fade;
      const grd = g.createRadialGradient(x, y, w*0.08, x, y, w*0.72);
      grd.addColorStop(0.0, 'rgba(230,245,255,0.14)');
      grd.addColorStop(0.6, 'rgba(150,205,255,0.06)');
      grd.addColorStop(1.0, 'rgba(60,95,150,0.00)');
      g.fillStyle = grd;
      g.beginPath();
      g.ellipse(x, y, w, h, 0, 0, TAU);
      g.fill();
    }
    g.restore();

    rebuildTextBackdropCache();

    if(textBackdropCache){
      g.drawImage(textBackdropCache, 0, 0, textBackdropCache.width / DPR, textBackdropCache.height / DPR);
    }

    // Texto hecho con estrellas (sprite, sin shadowBlur por partícula)
    if(textStars.length){
      g.save();
      g.globalCompositeOperation = 'screen';

      for(const st of textStars){
        const tw = CONFIG.reduceMotion ? 1 : (0.78 + 0.22*Math.sin(t*0.0012*st.s + st.p));
        const alpha = clamp(st.a * (0.95 + 0.85*tw), 0, 1);

        const x = st.x*W;
        const y = st.y*H;

        drawStarSprite(g, x, y, st.r, st.hue, st.flare, alpha);
      }

      g.restore();
    }

    // Estrellas + constelaciones
    g.save();
    g.globalCompositeOperation = 'screen';
    g.lineCap = 'round';
    g.lineJoin = 'round';
    g.strokeStyle = 'rgba(200,220,255,1)';

    for(const L of starLinks){
      const a = stars[L.i];
      const b = stars[L.j];
      starPos(a, t, _spA);
      starPos(b, t, _spB);
      if(_spA.y > H*0.62 || _spB.y > H*0.62) continue;
      g.globalAlpha = L.a;
      g.lineWidth = 1;
      g.beginPath();
      g.moveTo(_spA.x, _spA.y);
      g.lineTo(_spB.x, _spB.y);
      g.stroke();
    }

    for(const st of stars){
      const tw = CONFIG.reduceMotion ? 1 : (0.72 + 0.28*Math.sin(t*0.0011*st.s + st.p)) * (0.85 + st.tw*0.30);
      const alpha = st.a * (0.72 + 0.58*tw) * CONFIG.twinkle;

      starPos(st, t, _spA);
      const x = _spA.x;
      const y = _spA.y;

      drawStarSprite(g, x, y, st.r, st.hue, st.flare, alpha);
    }

    g.restore();

    g.globalCompositeOperation = 'source-over';
    g.globalAlpha = 1;
  }


  const _spA = {x:0,y:0};
  const _spB = {x:0,y:0};

  function starPos(st, t, out){
    const z = (st.z ?? 0.55);
    if(CONFIG.reduceMotion){
      out.x = st.x * W;
      out.y = st.y * H;
      return out;
    }
    const px = (Math.sin(t*0.00009 + st.p) * 5 + Math.sin(t*0.00023 + st.p*0.7) * 2) * z;
    const py = (Math.cos(t*0.00008 + st.p*1.1) * 4 + Math.sin(t*0.00019 + st.p*0.5) * 1.5) * z;
    out.x = st.x * W + px;
    out.y = st.y * H + py;
    return out;
  }

  function drawConstellations(t){
    if(!starLinks.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = 'rgba(200,220,255,1)';

    for(const L of starLinks){
      const a = stars[L.i];
      const b = stars[L.j];
      starPos(a, t, _spA);
      starPos(b, t, _spB);

      // Mantén las líneas en la parte alta del cielo (para no ensuciar el ramo)
      if(_spA.y > H*0.62 || _spB.y > H*0.62) continue;

      ctx.globalAlpha = L.a;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(_spA.x, _spA.y);
      ctx.lineTo(_spB.x, _spB.y);
      ctx.stroke();
    }

    ctx.restore();
  }



  // ===== Constelación específica: Capricornio (estilizada, en el fondo) =====
  function drawCapricornConstellationToCache(g){
    // Coordenadas normalizadas (0..1) para que escale con el canvas.
    // No es un atlas astronómico: es una silueta bonita y reconocible.
    const P = [
      {x:0.12, y:0.23, m:1.25},
      {x:0.21, y:0.17, m:1.10},
      {x:0.31, y:0.20, m:1.20},
      {x:0.39, y:0.26, m:1.05},
      {x:0.31, y:0.31, m:1.00},
      {x:0.23, y:0.30, m:0.95},
      {x:0.15, y:0.31, m:0.90},
      {x:0.18, y:0.37, m:0.85}
    ];

    const E = [
      [0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0],
      [5,7],[7,4]
    ];

    const XOFF = -0.08; // desplaza a la izquierda (evita chocar con la luna)
    const YOFF = -0.12; // sube la constelación (por encima del mensaje)

    const toX = (p)=>clamp((1 - p.x) + XOFF, 0.02, 0.98)*W;
    const toY = (p)=>clamp(p.y + YOFF, 0.02, 0.60)*H;

    g.save();
    g.globalCompositeOperation = 'screen';
    g.lineCap = 'round';
    g.lineJoin = 'round';

    // Bruma suave detrás para integrarlo (muy sutil)
    const cx = W*0.66, cy = H*0.14;
    const haze = g.createRadialGradient(cx, cy, 10, cx, cy, Math.min(W,H)*0.18);
    haze.addColorStop(0, 'rgba(200,220,255,0.06)');
    haze.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = haze;
    g.fillRect(0,0,W,H);

    // Líneas
    g.strokeStyle = 'rgba(200,220,255,1)';
    g.lineWidth = 1.15;
    g.globalAlpha = 0.14;

    for(const [a,b] of E){
      const A = P[a], B = P[b];
      const ax = toX(A), ay = toY(A);
      const bx = toX(B), by = toY(B);

      // evita ensuciar zona baja
      if(ay > H*0.62 || by > H*0.62) continue;

      g.beginPath();
      g.moveTo(ax, ay);
      g.lineTo(bx, by);
      g.stroke();
    }

    // Estrellas (puntos + glow)
    for(const p of P){
      const x = toX(p), y = toY(p);
      if(y > H*0.62) continue;

      const r = 1.15 + p.m*0.95;
      const glowR = 14 + p.m*12;

      g.globalAlpha = 0.20 + p.m*0.06;
      const rg = g.createRadialGradient(x,y, 0, x,y, glowR);
      rg.addColorStop(0, 'rgba(255,255,255,0.24)');
      rg.addColorStop(0.35, 'rgba(210,230,255,0.10)');
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.beginPath();
      g.arc(x,y, glowR, 0, TAU);
      g.fill();

      g.globalAlpha = 0.55;
      g.shadowColor = 'rgba(255,255,255,0.35)';
      g.shadowBlur = 10 + p.m*6;
      g.fillStyle = 'rgba(255,255,255,1)';
      g.beginPath();
      g.arc(x,y, r, 0, TAU);
      g.fill();
      g.shadowBlur = 0;
    }

    g.restore();
  }

  function rebuildSkyCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const sky = g.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, 'rgba(12,14,46,1)');
    sky.addColorStop(0.40, 'rgba(7,9,24,1)');
    sky.addColorStop(1, 'rgba(3,3,10,1)');
    g.fillStyle = sky;
    g.fillRect(0,0,W,H);


    // Sol: ahora se dibuja dinámicamente (con “generación”) en drawSky()
// para que aparezca como el ramo cuando inicia / se re-genera.
const neb = (x,y,r, a, cr,cg,cb) => {
      const gg = g.createRadialGradient(x,y, 10, x,y, r);
      gg.addColorStop(0, rgba(cr,cg,cb,a));
      gg.addColorStop(0.55, rgba(cr,cg,cb,a*0.26));
      gg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = gg;
      g.fillRect(0,0,W,H);
    };
    neb(W*0.16, H*0.15, Math.max(W,H)*0.66, 0.09, 120,150,255);
    neb(W*0.82, H*0.20, Math.max(W,H)*0.60, 0.08, 160,120,255);
    neb(W*0.55, H*0.10, Math.max(W,H)*0.52, 0.06, 90,170,255);

    g.save();
    g.translate(W*0.56, H*0.34);
    g.rotate(-0.36);
    const mw = Math.max(W,H)*1.25;
    const mh = Math.max(W,H)*0.24;

    const mg = g.createRadialGradient(0,0, mh*0.03, 0,0, mh);
    mg.addColorStop(0, 'rgba(255,255,255,0.095)');
    mg.addColorStop(0.55, 'rgba(190,210,255,0.040)');
    mg.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = mg;
    g.beginPath();
    g.ellipse(0,0, mw*0.56, mh, 0, 0, TAU);
    g.fill();

    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.38;
    const dust = clamp(Math.floor((W*H)/8500), 160, 460);
    const prDust = makePRNG((W*2654435761) ^ (H*2246822519));
    for(let i=0;i<dust;i++){
      const dx = (prDust()-0.5) * mw*0.85;
      const dy = (prDust()-0.5) * mh*0.55;
      const rr = 0.6 + prDust()*1.9;
      g.fillStyle = 'rgba(255,255,255,0.11)';
      g.beginPath();
      g.arc(dx, dy, rr, 0, TAU);
      g.fill();
    }
    g.restore();

    g.save();
    g.globalCompositeOperation = 'screen';
    const pr = makePRNG((W*73856093) ^ (H*19349663) ^ 0xA53);
    const count = clamp(Math.floor((W*H)/2050), 900, 2400);
    for(let i=0;i<count;i++){
      const x = pr()*W;
      const y = Math.pow(pr(), 1.62) * (H*0.74);
      const a = 0.025 + pr()*0.085;
      const r = (pr()<0.90) ? (0.55 + pr()*0.85) : (0.95 + pr()*1.25);
      const warm = pr() < 0.18;
      g.fillStyle = warm ? `rgba(255,245,230,${a})` : `rgba(210,230,255,${a})`;
      g.beginPath();
      g.arc(x, y, r, 0, TAU);
      g.fill();
    }

    // Cúmulos extra (estático): densidad bonita sin depender solo del render dinámico
    const clusters2 = [
      {cx: W*0.18, cy: H*0.18, r: Math.min(W,H)*0.12, n: 180},
      {cx: W*0.84, cy: H*0.14, r: Math.min(W,H)*0.13, n: 210},
      {cx: W*0.55, cy: H*0.26, r: Math.min(W,H)*0.11, n: 160},
    ];
    for(const c of clusters2){
      for(let k=0;k<c.n;k++){
        const ang = pr()*TAU;
        const rr  = Math.sqrt(pr()) * c.r;
        const x = c.cx + Math.cos(ang)*rr;
        const y = c.cy + Math.sin(ang)*rr;
        if(y > H*0.74) continue;
        const a = 0.018 + pr()*0.045;
        const r = 0.35 + pr()*0.90;
        const warm = pr() < 0.20;
        g.fillStyle = warm ? `rgba(255,245,235,${a})` : `rgba(200,225,255,${a})`;
        g.beginPath();
        g.arc(x, y, r, 0, TAU);
        g.fill();
      }
    }

    g.restore();

    


    // Capa de nubes (estática en cache): suave, semitransparente, deja ver estrellas
    
    // Nubes (mejoradas): 4 capas, densidad con ruido suave, bordes difuminados y variación de grosor
    // Objetivo: que se vean orgánicas sin tapar estrellas, y sin matar FPS.
    
    // Nubes (pocas y dispersas): pequeñas, separadas y con mucha transparencia (no tapan estrellas)
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.13;

    const cloudCount = 5;                 // pocas
    for(let ci=0; ci<cloudCount; ci++){
      const cx = W*(0.06 + pr()*0.88);
      const cy = H*(0.04 + pr()*0.12);    // dispersas en el cielo (parte superior)
      const w = Math.min(W,H) * (0.10 + pr()*0.08); // tamaño moderado
      const h  = w * (0.45 + pr()*0.22);
      const puff = 8 + Math.floor(pr()*6);

      // gradiente suave (muy transparente)
      const a = 0.07 + pr()*0.08;
      const grd = g.createRadialGradient(cx, cy, w*0.05, cx, cy, w*0.55);
      grd.addColorStop(0.0, `rgba(235,245,255,${a*1.05})`);
      grd.addColorStop(0.55,`rgba(160,205,255,${a*0.55})`);
      grd.addColorStop(1.0, `rgba(70,105,155,0.00)`);
      g.fillStyle = grd;

      // puffs para forma orgánica
      for(let p=0;p<puff;p++){
        const t = p/(puff-1);
        const x = cx + (t-0.5)*w*(0.85 + pr()*0.20);
        const y = cy + (pr()*2-1)*h*0.28 + Math.sin((t*TAU)+(pr()*0.8))*h*0.10;
        const r = (w*0.05 + pr()*w*0.07) * (0.85 + 0.50*(1-Math.abs(t-0.5)*1.6));
        g.beginPath();
        g.ellipse(x, y, r, r*(0.70 + pr()*0.30), 0, 0, TAU);
        g.fill();
      }

      // velo muy tenue (cuerpo)
      g.save();
      g.globalAlpha = 0.05;
      g.fillStyle = `rgba(210,235,255,${a*0.75})`;
      g.beginPath();
      g.ellipse(cx, cy, w*0.48, h*0.90, 0, 0, TAU);
      g.fill();
      g.restore();

      // sombra inferior mínima (profundidad)
      g.save();
      g.globalCompositeOperation = 'multiply';
      g.globalAlpha = 0.06;
      g.fillStyle = 'rgba(15,25,45,0.60)';
      g.beginPath();
      g.ellipse(cx, cy + h*0.16, w*0.36, h*0.62, 0, 0, TAU);
      g.fill();
      g.restore();
    }

    g.restore();

    // Luna (vuelve): disco frío + brillo + cráteres sutiles
    const mx = W*LIGHT.x, my = H*LIGHT.y;
    const R  = Math.min(W,H)*0.070;

    // Glow lunar
    g.save();
    g.globalCompositeOperation = 'screen';
    const mglow = g.createRadialGradient(mx, my, R*0.30, mx, my, R*3.0);
    mglow.addColorStop(0.0, 'rgba(210,235,255,0.65)');
    mglow.addColorStop(0.35,'rgba(140,190,235,0.22)');
    mglow.addColorStop(1.0, 'rgba(80,120,170,0.00)');
    g.fillStyle = mglow;
    g.beginPath(); g.arc(mx,my,R*3.0,0,TAU); g.fill();
    g.restore();

    // Disco lunar
    g.save();
    const moon = g.createRadialGradient(mx-R*0.25, my-R*0.18, R*0.20, mx, my, R*1.05);
    moon.addColorStop(0.0, 'rgba(250,252,255,1.0)');
    moon.addColorStop(0.55,'rgba(225,235,245,1.0)');
    moon.addColorStop(1.0, 'rgba(185,205,225,1.0)');
    g.fillStyle = moon;
    g.beginPath(); g.arc(mx,my,R,0,TAU); g.fill();

    // Cráteres (clip dentro del disco)
    g.save();
    g.beginPath(); g.arc(mx,my,R,0,TAU); g.clip();
    const cr = 16;
    for(let k=0;k<cr;k++){
      const a = pr()*TAU;
      const rr = Math.sqrt(pr())*R*0.82;
      const x = mx + Math.cos(a)*rr;
      const y = my + Math.sin(a)*rr;
      const r = R*(0.05 + pr()*0.12);

      g.globalAlpha = 0.10 + pr()*0.10;
      g.fillStyle = 'rgba(110,140,165,0.55)';
      g.beginPath();
      g.ellipse(x+r*0.18, y+r*0.14, r*1.02, r*0.82, a, 0, TAU);
      g.fill();

      g.globalAlpha = 0.10 + pr()*0.14;
      g.fillStyle = 'rgba(255,255,255,0.60)';
      g.beginPath();
      g.ellipse(x-r*0.12, y-r*0.10, r*0.92, r*0.72, a, 0, TAU);
      g.fill();
    }
    g.restore();

    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.22;
    g.strokeStyle = 'rgba(255,255,255,0.55)';
    g.lineWidth = 1.1;
    g.beginPath(); g.arc(mx,my,R*0.98,0,TAU); g.stroke();

    g.restore();

    const vg = g.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.98);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.62)');
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);


    // Constelación Capricornio (derecha)
    drawCapricornConstellationToCache(g);
    skyCache = off;
  }

  function rebuildBushCache(){
    // Arbusto envolvente: sube y abraza el ramo completo (detrás de flores/tallos).
    // Se cachea para que se vea orgánico sin quemar FPS.
    const q = CONFIG.quality || 2;
    const key = `${W}x${H}@q${q}`;
    if(bushCache && bushCacheKey === key) return;

    bushCacheKey = key;

    const off = document.createElement('canvas');
    off.width = W;
    off.height = H;
    const g = off.getContext('2d');

    const R = Math.min(W,H);

    // --- Base: gradiente de profundidad (desde media pantalla hacia abajo) ---
    const v = g.createLinearGradient(0, H*0.52, 0, H);
    v.addColorStop(0, 'rgba(0,0,0,0)');
    v.addColorStop(0.55, 'rgba(0,0,0,0.10)');
    v.addColorStop(1, 'rgba(0,0,0,0.26)');
    g.fillStyle = v;
    g.fillRect(0, H*0.50, W, H*0.50);

    // --- Masas grandes: crean “volumen” alrededor del ramo, no solo abajo ---
    // Centro + laterales + “cúpula” detrás de las flores
    const lumps = [
      // Cúpula principal (detrás del ramo)
      {x:0.50, y:0.76, s:0.92, a:0.24},
      // Soporte inferior
      {x:0.50, y:0.96, s:0.58, a:0.22},
      {x:0.35, y:0.97, s:0.52, a:0.20},
      {x:0.65, y:0.97, s:0.54, a:0.20},
      // Laterales para “abrazar”
      {x:0.18, y:0.86, s:0.60, a:0.16},
      {x:0.82, y:0.86, s:0.60, a:0.16},
      // Sub-masas para romper simetría
      {x:0.28, y:0.72, s:0.55, a:0.13},
      {x:0.72, y:0.72, s:0.55, a:0.13},
      {x:0.50, y:0.62, s:0.48, a:0.10},
    ];

    for(const L of lumps){
      const cx = W*L.x;
      const cy = H*L.y;
      const rad = R*L.s;

      const rg = g.createRadialGradient(cx, cy, 10, cx, cy, rad);
      rg.addColorStop(0, `rgba(85,190,125,${0.18*L.a/0.24})`);
      rg.addColorStop(0.25, `rgba(65,165,110,${0.24*L.a/0.24})`);
      rg.addColorStop(0.62, `rgba(32,95,65,${0.18*L.a/0.24})`);
      rg.addColorStop(0.88, `rgba(10,40,25,${0.12*L.a/0.24})`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.fillRect(0,0,W,H);
    }

    // --- Textura: hojitas sugeridas (desde mitad hacia abajo y alrededor del ramo) ---
    const count = q>=3 ? 980 : q>=2 ? 720 : 520;

    // PRNG estable por tamaño/calidad
    let s = ((W*73856093) ^ (H*19349663) ^ (q*83492791)) >>> 0;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    g.save();
    g.globalCompositeOperation = 'screen';

    for(let i=0;i<count;i++){
      // sesgo hacia el centro del ramo, con laterales también
      const t = rnd();
      const cx = 0.50 + (rnd()*0.70 - 0.35) * (0.55 + 0.45*t);  // 0.15..0.85
      const px = W*clamp(cx, 0.05, 0.95);

      // sube bastante: 0.50..1.00 con densidad mayor abajo
      const py = H*(0.50 + 0.50*t*t);

      const scale = 0.55 + rnd()*1.85;

      const a = 0.035 + rnd()*0.085;
      const shade = 0.48 + rnd()*0.52;

      // verdes nocturnos
      const rr = Math.round(20 + 55*shade);
      const gg2 = Math.round(80 + 135*shade);
      const bb = Math.round(40 + 85*shade);

      g.globalAlpha = a;

      // trazos cortos tipo hojita
      g.strokeStyle = `rgba(${rr},${gg2},${bb},0.95)`;
      g.lineWidth = 1.10*scale;
      g.lineCap = 'round';

      const ang = rnd()*TAU;
      const len = (2.6 + rnd()*8.4) * scale;

      g.beginPath();
      g.moveTo(px, py);
      g.lineTo(px + Math.cos(ang)*len, py + Math.sin(ang)*len*0.55);
      g.stroke();

      // puntito brillante (rocío/hoja)
      if(i % 3 === 0){
        g.fillStyle = `rgba(${170 + (rnd()*80|0)},${220 + (rnd()*35|0)},${185 + (rnd()*55|0)},0.50)`;
        g.beginPath();
        g.arc(px + Math.cos(ang)*len*0.55, py + Math.sin(ang)*len*0.30, 0.85*scale, 0, TAU);
        g.fill();
      }
    }
    g.restore();

    // Suavizado leve para integrar
    try{
      if(HAS_FILTER){
        g.save();
        g.globalAlpha = 0.26;
        g.filter = 'blur(1.05px)';
        g.drawImage(off, 0, 0);
        g.restore();
      }
    }catch(_){}

    // Viñeta suave para cerrar los bordes
    const vig = g.createRadialGradient(W*0.5, H*0.72, R*0.15, W*0.5, H*0.78, R*1.25);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.16)');
    g.fillStyle = vig;
    g.fillRect(0,0,W,H);

    bushCache = off;
  }




  function rebuildStaticSkyOverlayCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    // === Texto en estrellas (sin animación) ===
    if(textStars.length){
      g.save();
      g.globalCompositeOperation = 'screen';

      const gx = W*0.5, gy = H*0.28;
      const fontHint = clamp(Math.min(W,H)*0.09, 26, 58);
      const glow = g.createRadialGradient(gx, gy, 10, gx, gy, fontHint*7.5);
      glow.addColorStop(0, 'rgba(210,230,255,0.09)');
      glow.addColorStop(1, 'rgba(210,230,255,0)');
      g.globalAlpha = 1;
      g.fillStyle = glow;
      g.fillRect(0,0,W,H);

      for(const st of textStars){
        const alpha = st.a * 1.30; // (0.75 + 0.55*1)
        const x = st.x*W;
        const y = st.y*H;

        g.globalAlpha = alpha;
        g.shadowColor = 'rgba(255,255,255,0.55)';
        g.shadowBlur = 9 + st.r*6;

        g.fillStyle = st.hue ? `hsla(${st.hue}, 75%, 92%, 1)` : 'rgba(255,255,255,1)';
        g.beginPath();
        g.arc(x, y, st.r, 0, TAU);
        g.fill();

        if(st.flare){
          g.save();
          g.shadowBlur = 0;
          g.globalCompositeOperation = 'lighter';
          g.globalAlpha = alpha * 0.40 * st.flare;
          g.strokeStyle = 'rgba(255,255,255,0.55)';
          g.lineWidth = 1;
          const k = 3.0 + st.r*2.0;
          g.beginPath();
          g.moveTo(x-k, y); g.lineTo(x+k, y);
          g.moveTo(x, y-k); g.lineTo(x, y+k);
          g.stroke();
          g.restore();
        }
      }

      g.restore();
      g.globalCompositeOperation = 'source-over';
      g.shadowBlur = 0;
      g.globalAlpha = 1;
    }

    // === Líneas de constelaciones generadas ===
    if(starLinks.length){
      g.save();
      g.globalCompositeOperation = 'screen';
      g.lineCap = 'round';
      g.lineJoin = 'round';
      g.strokeStyle = 'rgba(200,220,255,1)';
      g.lineWidth = 1;

      for(const L of starLinks){
        const a = stars[L.i];
        const b = stars[L.j];
        const ax = a.x * W, ay = a.y * H;
        const bx = b.x * W, by = b.y * H;
        if(ay > H*0.62 || by > H*0.62) continue;

        g.globalAlpha = L.a;
        g.beginPath();
        g.moveTo(ax, ay);
        g.lineTo(bx, by);
        g.stroke();
      }
      g.restore();
    }

    // === Estrellas (sin parallax ni twinkle) ===
    if(stars.length){
      g.save();
      g.globalCompositeOperation = 'screen';

      for(const st of stars){
        const alpha = st.a * 1.30 * CONFIG.twinkle;
        const x = st.x * W;
        const y = st.y * H;

        g.globalAlpha = alpha;

        if(st.r < 1.15){
          g.shadowBlur = 0;
        }else{
          g.shadowColor = 'rgba(255,255,255,0.55)';
          g.shadowBlur = 8 + st.r*3.2;
        }

        g.fillStyle = st.hue ? `hsla(${st.hue}, 80%, 90%, 1)` : 'rgba(255,255,255,1)';
        g.beginPath();
        g.arc(x, y, st.r, 0, TAU);
        g.fill();

        if(st.flare){
          g.save();
          g.globalCompositeOperation = 'lighter';
          g.shadowBlur = 0;

          g.globalAlpha = alpha * 0.42 * st.flare;
          const rg = g.createRadialGradient(x,y, 0, x,y, 18 + st.r*11);
          rg.addColorStop(0, 'rgba(255,255,255,0.20)');
          rg.addColorStop(0.45, 'rgba(255,255,255,0.07)');
          rg.addColorStop(1, 'rgba(255,255,255,0)');
          g.fillStyle = rg;
          g.beginPath();
          g.arc(x,y, 18 + st.r*11, 0, TAU);
          g.fill();

          g.globalAlpha = alpha * 0.28 * st.flare;
          g.strokeStyle = 'rgba(255,255,255,0.55)';
          g.lineWidth = 1;
          const k = 3.6 + st.r*1.6;
          g.beginPath();
          g.moveTo(x-k, y); g.lineTo(x+k, y);
          g.moveTo(x, y-k); g.lineTo(x, y+k);
          g.stroke();
          g.restore();
        }
      }

      g.restore();
      g.shadowBlur = 0;
      g.globalAlpha = 1;
      g.globalCompositeOperation = 'source-over';
    }

    staticSkyOverlayCache = off;
  }


  function drawSky(t){
    if(skyCache){
      ctx.drawImage(skyCache, 0, 0, skyCache.width / DPR, skyCache.height / DPR);
    }else{
      const sky = ctx.createLinearGradient(0, 0, 0, H);
      sky.addColorStop(0, 'rgba(12,14,46,1)');
      sky.addColorStop(0.40, 'rgba(7,9,24,1)');
      sky.addColorStop(1, 'rgba(3,3,10,1)');
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);
    }

    // Reduce-motion: usa overlay estático (muy barato)
    if(CONFIG.reduceMotion && staticSkyOverlayCache){
      ctx.drawImage(staticSkyOverlayCache, 0, 0, staticSkyOverlayCache.width / DPR, staticSkyOverlayCache.height / DPR);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';

      drawMoon(t);
      if(shooting.active) drawShootingStar(t);
      return;
    }

    // Layer dinámico cacheado (30fps): estrellas + constelaciones + texto + wisps
    rebuildSkyDynCache();
    renderSkyDynamic(t);
    if(skyDynCache){
      ctx.drawImage(skyDynCache, 0, 0, skyDynCache.width / DPR, skyDynCache.height / DPR);
    }

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';

    // Luna y fugaces por encima
    drawMoon(t);
    maybeStartShootingStar(t);
    drawShootingStar(t);
  }

  // ===== Hojas =====
  function drawTulipLeaf(attachX, attachY, angle, scale, side){
    const id = ((attachX * 97) ^ (attachY * 193) ^ (side * 911)) | 0;
    const j = (Math.sin(id) * 0.5 + 0.5);

    const len = (95 + j*10) * scale;
    const baseWid = (7.5 + j*1.2) * scale;

    const baseDir = Math.PI/2 + angle;
    const leafAngle = baseDir + side * (0.16 + j*0.03);

    const p0x = attachX, p0y = attachY;
    const p3x = attachX + Math.cos(leafAngle) * len;
    const p3y = attachY - Math.sin(leafAngle) * len;

    const p1x = attachX + side * baseWid * (0.34 + j*0.08);
    const p1y = attachY - len * (0.35 + j*0.05);

    const p2x = attachX + side * baseWid * (0.14 + j*0.06);
    const p2y = attachY - len * (0.82 + j*0.06);

    const bez = (t, a,b,c,d) => {
      const u = 1 - t;
      return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
    };

    const G0 = {r:28,g:88,b:56};
    const G1 = {r:52,g:140,b:88};
    const G2 = {r:96,g:190,b:130};

    const grad = ctx.createLinearGradient(p0x, p0y, p3x, p3y);
    grad.addColorStop(0, rgba(G0.r,G0.g,G0.b, 0.92));
    grad.addColorStop(0.55, rgba(G1.r,G1.g,G1.b, 0.84));
    grad.addColorStop(1, rgba(G2.r,G2.g,G2.b, 0.70));

    const steps = 14;
    const L = [], R = [], C = [];

    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const x = bez(t, p0x,p1x,p2x,p3x);
      const y = bez(t, p0y,p1y,p2y,p3y);
      C.push({x,y});

      const t2 = Math.min(1, t + 0.015);
      const x2 = bez(t2, p0x,p1x,p2x,p3x);
      const y2 = bez(t2, p0y,p1y,p2y,p3y);
      const dx = x2-x, dy=y2-y;
      const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
      const nx = -dy*inv, ny = dx*inv;

      const taper = Math.pow(1 - t, 1.55);
      const w = baseWid * (0.04 + 0.50*taper);

      L.push({x: x + nx*w, y: y + ny*w});
      R.push({x: x - nx*w, y: y - ny*w});
    }

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.14)';
    ctx.shadowBlur = 4 * scale;

    ctx.fillStyle = grad;
    ctx.strokeStyle = 'rgba(255,255,255,0.012)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(L[0].x, L[0].y);
    for(const p of L) ctx.lineTo(p.x, p.y);
    for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i].x, R[i].y);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.stroke();

    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = Math.max(1, 1.15*scale);
    ctx.beginPath();
    for(let i=0;i<C.length;i++){
      const p = C[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.10;
    const edge = side < 0 ? L : R;
    ctx.strokeStyle = 'rgba(180,255,210,0.14)';
    ctx.lineWidth = Math.max(1, 0.9*scale);
    ctx.beginPath();
    for(let i=0;i<edge.length;i++){
      const p = edge[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawLeafSprig(x, y, angle, scale, side){
    const baseDir = Math.PI/2 + angle;
    const a = baseDir + side*(0.30);

    const len = 72 * scale;
    const spread = 14 * scale;

    const tipX = x + Math.cos(a) * len;
    const tipY = y - Math.sin(a) * len;

    const cX = x + side * spread;
    const cY = y - len * 0.55;

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const lg = ctx.createLinearGradient(x, y, tipX, tipY);
    lg.addColorStop(0, 'rgba(8,20,12,0.10)');
    lg.addColorStop(0.55, 'rgba(70,200,130,0.08)');
    lg.addColorStop(1, 'rgba(90,240,160,0.12)');

    ctx.strokeStyle = lg;
    ctx.lineWidth = Math.max(1, 0.9 * scale);

    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(cX, cY, tipX, tipY);
    ctx.stroke();

    ctx.globalAlpha = 0.45;
    ctx.beginPath();
    ctx.moveTo(x + side*2.0*scale, y + 1.3*scale);
    ctx.quadraticCurveTo(cX - side*spread*0.55, cY + len*0.12, tipX - side*3.0*scale, tipY + 1.2*scale);
    ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(120,255,180,0.08)';
    ctx.lineWidth = Math.max(1, 0.8 * scale);
    ctx.beginPath();
    ctx.moveTo(x + side*0.8*scale, y);
    ctx.quadraticCurveTo((x+tipX)*0.5, (y+tipY)*0.5, tipX, tipY);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Pétalos =====
  function getBloomSprite(w, h, col, seed, open, petalsVisible){
    const oQ = Math.round(((open||1) * 20));
    // Suaviza la “generación”: en lugar de 7 pasos (0..6), usamos 25 pasos (0..24) = incrementos de 0.25
    const pvRaw = (petalsVisible==null ? 6 : petalsVisible);
    const pvQ = clamp(Math.round(pvRaw * 4), 0, 24); // 0..24
    const pv = pvQ / 4; // 0..6 (float)
    const key = `${Math.round(w)}x${Math.round(h)}_${col.r},${col.g},${col.b}_${seed}_o${oQ}_p${pvQ}`;
    const cached = bloomCache.get(key);
    if(cached) return cached;
    const ss = (CONFIG.quality>=3 ? 3 : 2);

    // ===== FIX “pétalos cortados” =====
    // El sprite anterior era un poco pequeño en la parte superior: algunos pétalos (len ~ h*1.0
    // + centerY ~ -h*0.62) alcanzaban ~ -1.6h, y ay=1.55h los recortaba.
    // Solución: añadir padding real y subir ay + alto del sprite.
    const pad = Math.ceil(Math.max(w, h) * 0.55);
    const cw  = Math.ceil(w * 3.25 + pad);
    const ch  = Math.ceil(h * 3.00 + w * 0.45 + pad);

    const ax = Math.ceil(cw * 0.50);
    const ay = Math.ceil(h * 1.95 + pad * 0.15);

    const off = document.createElement('canvas');
    off.width  = cw * ss;
    off.height = ch * ss;

    const c2 = off.getContext('2d', { alpha:true });
    c2.setTransform(ss,0,0,ss,0,0);
    c2.translate(ax, ay);

    renderTulipBloomSprite(c2, w, h, col, seed, oQ/20, pv);

    const obj = { canvas: off, ox: ax, oy: ay, ss };
    bloomCache.set(key, obj);
    return obj;
  }
  function renderTulipBloomSprite(c2, w, h, col, seed, open, petalsVisible){
    // Gerbera mejorada (v3):
    // - Capa “back” para profundidad (pétalos detrás)
    // - Pétalos con ligera curvatura (shear), estrías y highlight de punta
    // - Centro con “florets” tubulares alrededor del disco + polen más denso
    // Renderizado a sprite (cache) para que el costo no se coma la animación.

    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const pv = clamp((petalsVisible==null?6:petalsVisible), 0, 6); // float
    const appear = pv / 6; // 0..1
    const op = clamp(open==null?1:open, 0, 1);

    const mix = (a,b,t)=>({
      r: Math.round(lerp(a.r,b.r,t)),
      g: Math.round(lerp(a.g,b.g,t)),
      b: Math.round(lerp(a.b,b.b,t))
    });

    // Paleta del pétalo (base -> cuerpo -> punta)
    const lite = mix(col, {r:255,g:255,b:255}, 0.50);
    const mid  = mix(col, {r:255,g:230,b:245}, 0.24);
    const deep = mix(col, {r:18,g:6,b:24},      0.58);
    const edge = mix(col, {r:255,g:245,b:250},  0.18);

    const centerY = -h*0.62;

    // Sombra global (da “cuerpo” a la cabeza)
    c2.save();
    c2.globalAlpha = 0.20;
    c2.fillStyle = rgba(0,0,0,0.18);
    c2.beginPath();
    c2.ellipse(0, centerY + h*0.34, w*1.05, h*0.52, 0, 0, TAU);
    c2.fill();
    c2.restore();

    // Halo suave
    c2.save();
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.11;
    const haloR = Math.max(w*1.45, h*1.10);
    const halo = c2.createRadialGradient(0, centerY, 8, 0, centerY, haloR);
    halo.addColorStop(0, rgba(col.r,col.g,col.b,0.22));
    halo.addColorStop(0.55, rgba(col.r,col.g,col.b,0.07));
    halo.addColorStop(1, rgba(col.r,col.g,col.b,0));
    c2.fillStyle = halo;
    c2.beginPath();
    c2.ellipse(0, centerY, w*1.18, h*1.08, 0, 0, TAU);
    c2.fill();
    c2.restore();

    // Aparición escalonada por pétalo
    const petalStage = (i, total) => {
      const j = (Math.sin((seed*0.0009 + i*12.345) * 1.73) * 0.5 + 0.5) * 0.92;
      const threshold = (i + j) / total;
      const x = (appear - threshold) * 3.1 + 0.25;
      return clamp(x, 0, 1);
    };

    const drawPetal = (ang, len, wid, alpha, shade, bend, tint, curl) => {
      c2.save();
      c2.translate(0, centerY);
      c2.rotate(ang);
      c2.rotate(bend);

      // Curvatura ligera (como “cucharita”)
      c2.transform(1, 0, curl, 1, 0, 0);

      const tipY = -len;

      // sombra suave detrás (profundidad)
      c2.save();
      c2.globalAlpha = alpha * 0.14;
      c2.fillStyle = rgba(0,0,0,0.26);
      c2.beginPath();
      c2.moveTo(0, 0);
      c2.quadraticCurveTo( wid*0.92, -len*0.62, 0, tipY);
      c2.quadraticCurveTo(-wid*0.92, -len*0.62, 0, 0);
      c2.closePath();
      c2.translate(0.7, 1.2);
      c2.fill();
      c2.restore();

      // degradado principal del pétalo
      const g = c2.createLinearGradient(0, 0, 0, tipY);
      const base = mix(deep, col, 0.22 + 0.22*tint);
      const body = mix(col,  mid, 0.18 + 0.18*tint);
      const tip  = mix(lite, {r:255,g:255,b:255}, 0.10 + 0.10*tint);

      g.addColorStop(0,    rgba(base.r,base.g,base.b, 0.52*shade));
      g.addColorStop(0.25, rgba(col.r,col.g,col.b,    0.98*shade));
      g.addColorStop(0.68, rgba(body.r,body.g,body.b, 0.98*shade));
      g.addColorStop(1,    rgba(tip.r,tip.g,tip.b,    0.98*shade));

      c2.globalAlpha = alpha;
      c2.fillStyle = g;

      // Forma: punta redondeada
      const ctrlY = -len*0.64;
      const ctrlX = wid*(0.96 + rnd()*0.14);
      const cap   = wid*(0.18 + 0.08*rnd());

      c2.beginPath();
      c2.moveTo(0, 0);
      c2.bezierCurveTo( ctrlX, ctrlY,  ctrlX*0.55, tipY*0.90,  cap, tipY);
      c2.quadraticCurveTo(0, tipY - wid*0.05, -cap, tipY);
      c2.bezierCurveTo(-ctrlX*0.55, tipY*0.90, -ctrlX, ctrlY, 0, 0);
      c2.closePath();
      c2.fill();

      // highlight de borde
      c2.globalAlpha = alpha * 0.18;
      c2.strokeStyle = rgba(edge.r,edge.g,edge.b, 0.95);
      c2.lineWidth = Math.max(0.8, wid*0.10);
      c2.lineJoin = 'round';
      c2.lineCap  = 'round';
      c2.beginPath();
      c2.moveTo(0, 0);
      c2.quadraticCurveTo(ctrlX*0.85, ctrlY*0.98, cap*0.35, tipY);
      c2.stroke();

      // Estrías (textura del pétalo)
      c2.save();
      c2.globalAlpha = alpha * 0.06;
      c2.strokeStyle = 'rgba(255,255,255,0.22)';
      c2.lineWidth = Math.max(0.7, wid*0.05);
      for(let k=0;k<3;k++){
        const o = (k-1) * wid*0.18;
        c2.beginPath();
        c2.moveTo(o*0.12, -len*0.06);
        c2.quadraticCurveTo(o*0.55, -len*0.44, o*0.06, tipY*0.92);
        c2.stroke();
      }
      c2.restore();

      // Vena central (detalle suave)
      c2.save();
      c2.globalAlpha = alpha * 0.06;
      c2.strokeStyle = 'rgba(255,255,255,0.28)';
      c2.lineWidth = Math.max(0.7, wid*0.05);
      c2.beginPath();
      c2.moveTo(0, -len*0.04);
      c2.quadraticCurveTo(wid*0.10, -len*0.46, 0, tipY*0.92);
      c2.stroke();
      c2.restore();

      // Sombra de vena (lado opuesto)
      c2.save();
      c2.globalAlpha = alpha * 0.04;
      c2.strokeStyle = 'rgba(0,0,0,0.20)';
      c2.lineWidth = Math.max(0.7, wid*0.05);
      c2.beginPath();
      c2.moveTo(-wid*0.06, -len*0.06);
      c2.quadraticCurveTo(-wid*0.12, -len*0.52, -wid*0.03, tipY*0.90);
      c2.stroke();
      c2.restore();

      // Highlight de punta
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = alpha * 0.09;
      c2.fillStyle = 'rgba(255,255,255,0.20)';
      c2.beginPath();
      c2.ellipse(0, tipY + wid*0.10, wid*0.40, wid*0.18, 0, 0, TAU);
      c2.fill();
      c2.restore();

      // sombra lateral (para “tubo”)
      c2.globalAlpha = alpha * 0.07;
      c2.strokeStyle = 'rgba(0,0,0,0.22)';
      c2.lineWidth = Math.max(0.7, wid*0.06);
      c2.beginPath();
      c2.moveTo(0, 0);
      c2.quadraticCurveTo(-ctrlX*0.75, ctrlY*0.95, -cap*0.35, tipY);
      c2.stroke();

      c2.restore();
    };

    // Capas
    const totalOuter = 42 + (rnd()*11|0); // 42..52
    const totalMid   = Math.round(totalOuter * 0.78);
    const totalInner = Math.round(totalOuter * 0.56);
    const totalBack  = Math.round(totalOuter * 0.62);
    const totalCrown = 20 + (rnd()*7|0); // 20..26

    const baseOuterLen = h*(0.86 + 0.06*rnd()) * (0.70 + 0.30*op);
    const baseOuterWid = w*(0.124 + 0.018*rnd());

    const baseMidLen   = h*(0.67 + 0.05*rnd()) * (0.70 + 0.30*op);
    const baseMidWid   = w*(0.104 + 0.016*rnd());

    const baseInLen    = h*(0.50 + 0.04*rnd()) * (0.70 + 0.30*op);
    const baseInWid    = w*(0.082 + 0.012*rnd());

    const baseCrLen    = h*(0.30 + 0.03*rnd()) * (0.75 + 0.25*op);
    const baseCrWid    = w*(0.072 + 0.011*rnd());

    // Back layer (pétalos detrás)
    for(let i=0;i<totalBack;i++){
      const st = petalStage(i, totalBack);
      if(st <= 0) continue;

      const ang  = (i/totalBack)*TAU + (rnd()*0.08 - 0.04) + 0.02;
      const bend = (rnd()*0.22 - 0.11);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.26 - 0.13) * (0.45 + 0.55*st);

      const len = baseOuterLen*(1.02 + 0.18*rnd()) * (0.35 + 0.65*st);
      const wid = baseOuterWid*(1.05 + 0.45*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.30*st, 0.82, bend, tint, curl);
    }

    // Outer
    for(let i=0;i<totalOuter;i++){
      const st = petalStage(i, totalOuter);
      if(st <= 0) continue;

      const ang  = (i/totalOuter)*TAU + (rnd()*0.08 - 0.04);
      const bend = (rnd()*0.18 - 0.09);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.22 - 0.11) * (0.45 + 0.55*st);

      const len = baseOuterLen*(0.86 + 0.24*rnd()) * (0.35 + 0.65*st);
      const wid = baseOuterWid*(0.78 + 0.36*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.95*st, 0.92, bend, tint, curl);
    }

    // Mid
    for(let i=0;i<totalMid;i++){
      const st = petalStage(i, totalMid);
      if(st <= 0) continue;

      const ang  = (i/totalMid)*TAU + (rnd()*0.08 - 0.04) + 0.05;
      const bend = (rnd()*0.14 - 0.07);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.18 - 0.09) * (0.45 + 0.55*st);

      const len = baseMidLen*(0.86 + 0.22*rnd()) * (0.35 + 0.65*st);
      const wid = baseMidWid*(0.78 + 0.34*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.80*st, 0.98, bend, tint, curl);
    }

    // Inner rays
    for(let i=0;i<totalInner;i++){
      const st = petalStage(i, totalInner);
      if(st <= 0) continue;

      const ang  = (i/totalInner)*TAU + (rnd()*0.08 - 0.04) - 0.03;
      const bend = (rnd()*0.12 - 0.06);
      const tint = rnd()*1.0;
      const curl = (rnd()*0.16 - 0.08) * (0.45 + 0.55*st);

      const len = baseInLen*(0.88 + 0.18*rnd()) * (0.35 + 0.65*st);
      const wid = baseInWid*(0.82 + 0.30*rnd()) * (0.55 + 0.45*st);
      drawPetal(ang, len, wid, 0.64*st, 1.00, bend, tint, curl);
    }

    // Corona interna (pétalos cortos)
    const crownAppear = clamp((appear - 0.30) * 1.6, 0, 1);
    if(crownAppear > 0){
      const crownCol  = mix(col, {r:255,g:245,b:235}, 0.38);
      const crownLite = mix(crownCol, {r:255,g:255,b:255}, 0.58);
      const crownDeep = mix(crownCol, {r:40,g:20,b:30}, 0.46);

      for(let i=0;i<totalCrown;i++){
        const st = petalStage(i, totalCrown) * crownAppear;
        if(st <= 0) continue;

        const ang  = (i/totalCrown)*TAU + (rnd()*0.08 - 0.04);
        const bend = (rnd()*0.10 - 0.05);

        c2.save();
        c2.translate(0, centerY);
        c2.rotate(ang);
        c2.rotate(bend);

        const len = baseCrLen*(0.90 + 0.22*rnd()) * (0.45 + 0.55*st);
        const wid = baseCrWid*(0.85 + 0.32*rnd()) * (0.55 + 0.45*st);
        const tipY = -len;

        const gg = c2.createLinearGradient(0, 0, 0, tipY);
        gg.addColorStop(0, rgba(crownDeep.r,crownDeep.g,crownDeep.b, 0.42));
        gg.addColorStop(0.40, rgba(crownCol.r,crownCol.g,crownCol.b, 0.85));
        gg.addColorStop(1, rgba(crownLite.r,crownLite.g,crownLite.b, 0.95));

        c2.globalAlpha = 0.58 * st;
        c2.fillStyle = gg;

        const ctrlX = wid*(0.95 + rnd()*0.12);
        const ctrlY = -len*0.62;
        const cap = wid*(0.22 + 0.06*rnd());

        c2.beginPath();
        c2.moveTo(0, 0);
        c2.bezierCurveTo( ctrlX, ctrlY,  ctrlX*0.55, tipY*0.90,  cap, tipY);
        c2.quadraticCurveTo(0, tipY - wid*0.04, -cap, tipY);
        c2.bezierCurveTo(-ctrlX*0.55, tipY*0.90, -ctrlX, ctrlY, 0, 0);
        c2.closePath();
        c2.fill();

        c2.restore();
      }
    }

    // Centro (disco) + florets tubulares
    const discR = w*(0.235 + 0.02*rnd());
    const discGrow = (0.25 + 0.75*clamp(appear*1.25, 0, 1));

    // Oclusión donde nacen pétalos (profundidad alrededor del disco)
    c2.save();
    c2.globalCompositeOperation = 'multiply';
    c2.globalAlpha = 0.22 * discGrow;
    const occ = c2.createRadialGradient(0, centerY, discR*0.35, 0, centerY, discR*1.55);
    occ.addColorStop(0, 'rgba(0,0,0,0)');
    occ.addColorStop(0.55, 'rgba(0,0,0,0.32)');
    occ.addColorStop(1, 'rgba(0,0,0,0)');
    c2.fillStyle = occ;
    c2.beginPath();
    c2.arc(0, centerY, discR*1.65, 0, TAU);
    c2.fill();
    c2.restore();

    // Sombra de “cuenco”
    c2.save();
    c2.globalAlpha = 0.18 * discGrow;
    c2.fillStyle = 'rgba(0,0,0,0.28)';
    c2.beginPath();
    c2.ellipse(0, centerY + discR*0.10, discR*1.30*discGrow, discR*0.92*discGrow, 0, 0, TAU);
    c2.fill();
    c2.restore();

    const core = c2.createRadialGradient(0, centerY, discR*0.10, 0, centerY, discR*1.50);
    core.addColorStop(0,   rgba(255, 246, 190, 0.98));
    core.addColorStop(0.45,rgba(245, 205, 120, 0.98));
    core.addColorStop(0.78,rgba(195, 110,  55, 0.96));
    core.addColorStop(1,   rgba(105,  55,  32, 0.96));

    c2.save();
    c2.globalAlpha = 0.26 + 0.76*discGrow;
    c2.fillStyle = core;
    c2.beginPath();
    c2.ellipse(0, centerY, discR*1.10*discGrow, discR*1.00*discGrow, rnd()*0.8, 0, TAU);
    c2.fill();

    // anillo exterior
    c2.globalAlpha *= 0.70;
    c2.strokeStyle = rgba(255, 238, 175, 0.45);
    c2.lineWidth = Math.max(0.9, discR*0.11);
    c2.beginPath();
    c2.ellipse(0, centerY, discR*1.07*discGrow, discR*0.94*discGrow, 0, 0, TAU);
    c2.stroke();

    // Textura de celdas (súper sutil) dentro del disco
    c2.save();
    c2.beginPath();
    c2.ellipse(0, centerY, discR*1.12*discGrow, discR*1.02*discGrow, 0, 0, TAU);
    c2.clip();
    const cells = 56;
    for(let i=0;i<cells;i++){
      const a = rnd()*TAU;
      const rr = Math.sqrt(rnd())*discR*1.02*discGrow;
      const x = Math.cos(a)*rr*0.78;
      const y = centerY + Math.sin(a)*rr*0.58;
      const r1 = discR*(0.020 + 0.018*rnd())*discGrow;

      c2.globalAlpha = 0.06 + 0.05*rnd();
      c2.fillStyle = 'rgba(0,0,0,0.35)';
      c2.beginPath(); c2.arc(x, y, r1, 0, TAU); c2.fill();

      c2.globalAlpha *= 0.55;
      c2.fillStyle = 'rgba(255,255,255,0.22)';
      c2.beginPath(); c2.arc(x - r1*0.25, y - r1*0.25, r1*0.55, 0, TAU); c2.fill();
    }
    c2.restore();

    // Florets tubulares (transición pétalo-centro)
    const florets = 44;
    for(let i=0;i<florets;i++){
      const a = (i/florets)*TAU + rnd()*0.08;
      const rr = discR*(1.08 + 0.06*rnd())*discGrow;
      const x = Math.cos(a)*rr*0.80;
      const y = centerY + Math.sin(a)*rr*0.58;

      c2.save();
      c2.translate(x, y);
      c2.rotate(a + Math.PI*0.5);

      const L = discR*(0.20 + 0.10*rnd())*discGrow;
      const Wd = discR*(0.07 + 0.03*rnd())*discGrow;

      const gg = c2.createLinearGradient(0, 0, 0, -L);
      gg.addColorStop(0, 'rgba(85,45,26,0.75)');
      gg.addColorStop(0.55, 'rgba(210,125,70,0.80)');
      gg.addColorStop(1, 'rgba(255,230,150,0.78)');

      c2.globalAlpha = 0.26 + 0.34*rnd();
      c2.fillStyle = gg;
      // Cuerpo tipo “cápsula”
      c2.beginPath();
      c2.ellipse(0, -L*0.55, Wd*0.55, L*0.55, 0, 0, TAU);
      c2.fill();

      // puntito brillante
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha *= 0.30;
      c2.fillStyle = 'rgba(255,255,255,0.18)';
      c2.beginPath();
      c2.ellipse(0, -L*0.85, Wd*0.35, Wd*0.26, 0, 0, TAU);
      c2.fill();

      c2.restore();
    }

    // Florets internos (más pequeños) para densidad
    const florets2 = 28;
    for(let i=0;i<florets2;i++){
      const a = (i/florets2)*TAU + rnd()*0.10 + 0.02;
      const rr = discR*(0.70 + 0.08*rnd())*discGrow;
      const x = Math.cos(a)*rr*0.74;
      const y = centerY + Math.sin(a)*rr*0.52;

      c2.save();
      c2.translate(x, y);
      c2.rotate(a + Math.PI*0.5);

      const L = discR*(0.16 + 0.08*rnd())*discGrow;
      const Wd = discR*(0.055 + 0.025*rnd())*discGrow;

      const gg = c2.createLinearGradient(0, 0, 0, -L);
      gg.addColorStop(0, 'rgba(70,34,22,0.70)');
      gg.addColorStop(0.55, 'rgba(190,110,62,0.78)');
      gg.addColorStop(1, 'rgba(255,228,145,0.70)');

      c2.globalAlpha = 0.18 + 0.26*rnd();
      c2.fillStyle = gg;
      c2.beginPath();
      c2.ellipse(0, -L*0.55, Wd*0.55, L*0.55, 0, 0, TAU);
      c2.fill();

      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha *= 0.26;
      c2.fillStyle = 'rgba(255,255,255,0.16)';
      c2.beginPath();
      c2.ellipse(0, -L*0.85, Wd*0.33, Wd*0.24, 0, 0, TAU);
      c2.fill();

      c2.restore();
    }

    // Polen: espiral + granos
    c2.globalAlpha *= 0.78;
    const grains = 150;
    for(let k=0;k<grains;k++){
      const t = (k/(grains-1));
      const a = t*TAU*2.25 + rnd()*0.25;
      const rr = discR*(0.12 + 0.82*t)*discGrow;
      const x = Math.cos(a)*rr*0.78;
      const y = centerY + Math.sin(a)*rr*0.60;

      const r0 = discR*(0.010 + 0.020*rnd())*discGrow;
      const dark = 0.26 + 0.32*rnd();
      c2.fillStyle = rgba(70, 35, 22, dark);
      c2.beginPath();
      c2.ellipse(x, y, r0*1.25, r0, rnd()*TAU, 0, TAU);
      c2.fill();

      // chispas doradas ocasionales
      if(k%7===0){
        c2.save();
        c2.globalCompositeOperation = 'screen';
        c2.globalAlpha = 0.06 + 0.06*rnd();
        c2.fillStyle = 'rgba(255,220,140,0.22)';
        c2.beginPath();
        c2.arc(x + r0*0.15, y - r0*0.15, r0*(0.55 + 0.45*rnd()), 0, TAU);
        c2.fill();
        c2.restore();
      }

      if(k%4===0){
        c2.globalCompositeOperation = 'screen';
        c2.fillStyle = 'rgba(255,255,255,0.08)';
        c2.beginPath();
        c2.arc(x - r0*0.2, y - r0*0.2, r0*0.55, 0, TAU);
        c2.fill();
        c2.globalCompositeOperation = 'source-over';
      }
    }

    // brillo suave del centro
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.10;
    const shine = c2.createRadialGradient(0, centerY - discR*0.15, 0, 0, centerY - discR*0.15, discR*2.4);
    shine.addColorStop(0, 'rgba(255,255,255,0.18)');
    shine.addColorStop(1, 'rgba(255,255,255,0)');
    c2.fillStyle = shine;
    c2.beginPath();
    c2.arc(0, centerY - discR*0.15, discR*2.10, 0, TAU);
    c2.fill();

    c2.restore();

    // sombra mínima para “anclar” la cabeza al tallo
    c2.save();
    c2.globalAlpha = 0.18;
    c2.fillStyle = rgba(0,0,0,0.16);
    c2.beginPath();
    c2.ellipse(0, h*0.02, w*0.32, h*0.12, 0, 0, TAU);
    c2.fill();
    c2.restore();
  }





  function drawTulipBloom(w, h, col, seed, open, petalsVisible){
    const spr = getBloomSprite(w, h, col, seed, open, petalsVisible);
    ctx.drawImage(
      spr.canvas,
      -spr.ox,
      -spr.oy,
      spr.canvas.width / spr.ss,
      spr.canvas.height / spr.ss
    );
  }
  function drawBouquetWrap(cx, cy, s){
    // Opción 1: Cono de papel clásico (crema/blanco) con borde doblado y sombras suaves.
    // Se dibuja DESPUÉS de tallos y ANTES de flores para tapar tallos y dejar cabezas libres.
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(s, s);

    // Sombra base
    ctx.save();
    ctx.globalAlpha *= 0.55;
    const sh = ctx.createRadialGradient(0, 32, 12, 0, 32, 230);
    sh.addColorStop(0, 'rgba(0,0,0,0.20)');
    sh.addColorStop(0.55, 'rgba(0,0,0,0.09)');
    sh.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = sh;
    ctx.beginPath();
    ctx.ellipse(0, 36, 204, 62, 0, 0, TAU);
    ctx.fill();
    ctx.restore();

    // Paleta “papel”
    const C0 = {r:236, g:232, b:220}; // crema base
    const C1 = {r:250, g:248, b:242}; // highlight
    const C2 = {r:206, g:198, b:182}; // sombra suave
    const edge = {r:255, g:255, b:255};

    // PRNG fijo para textura
    let s0 = 0xC0FFEE;
    const rnd = () => (s0 = (s0 * 1664525 + 1013904223) >>> 0, s0 / 4294967296);

    // Geometría del envoltorio
    const TOP = -285;
    const BOT =  96;
    const WID =  182;

    const conePath = (W, topLift=0) => {
      // Forma tipo cono/papel doblado
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-0.98*W, -170, -0.92*W, -300, -0.28*W, TOP+topLift);
      ctx.bezierCurveTo( 0.10*W, TOP-22+topLift,  1.02*W, -260,  0.84*W, -70);
      ctx.bezierCurveTo( 0.66*W,  56,   0.24*W,  60,    0, 0);
      ctx.closePath();
    };

    const paperPanel = (rot, flip, alpha, widen, lift, warmTint) => {
      ctx.save();
      ctx.rotate(rot);
      ctx.scale(flip, 1);
      ctx.translate(0, lift);

      const W = WID*widen;

      // Gradiente del papel (más claro arriba)
      const g = ctx.createLinearGradient(-W*0.60, BOT*0.35, W*0.40, TOP*0.70);
      g.addColorStop(0, rgba(C2.r, C2.g, C2.b, 0.82));
      g.addColorStop(0.45, rgba(C0.r, C0.g, C0.b, 0.92));
      g.addColorStop(1, rgba(C1.r, C1.g, C1.b, 0.98));

      ctx.globalAlpha *= alpha;
      ctx.fillStyle = g;
      ctx.shadowColor = 'rgba(0,0,0,0.24)';
      ctx.shadowBlur = 18;

      conePath(W, 0);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Borde doblado (boca del papel): una banda superior con sombra interior
      ctx.save();
      // Trazo oscuro (sombra interior)
      ctx.globalAlpha *= 0.55;
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      ctx.moveTo(-0.24*W, TOP+2);
      ctx.quadraticCurveTo(0, TOP-18, 0.24*W, TOP+2);
      ctx.stroke();

      // Banda clara del doblez
      const lip = ctx.createLinearGradient(0, TOP-24, 0, TOP+26);
      lip.addColorStop(0, 'rgba(255,255,255,0.68)');
      lip.addColorStop(0.55, 'rgba(248,246,240,0.42)');
      lip.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.globalAlpha *= 0.75;
      ctx.fillStyle = lip;
      ctx.beginPath();
      ctx.moveTo(-0.26*W, TOP+4);
      ctx.quadraticCurveTo(0, TOP-20, 0.26*W, TOP+4);
      ctx.quadraticCurveTo(0, TOP+20, -0.26*W, TOP+4);
      ctx.closePath();
      ctx.fill();

      // Highlight del borde
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha *= 0.35;
      ctx.strokeStyle = rgba(edge.r, edge.g, edge.b, 0.30);
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.moveTo(-0.22*W, TOP+3);
      ctx.quadraticCurveTo(0, TOP-16, 0.22*W, TOP+3);
      ctx.stroke();
      ctx.restore();

      // Pliegues suaves (poco, para que no se vea “cartón”)
      ctx.save();
      ctx.globalAlpha *= 0.18;
      ctx.strokeStyle = 'rgba(255,255,255,0.20)';
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(-0.08*W, -40);
      ctx.quadraticCurveTo(0.20*W, -190, 0.02*W, TOP+14);
      ctx.stroke();

      ctx.globalAlpha *= 0.90;
      ctx.strokeStyle = 'rgba(0,0,0,0.10)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(0.14*W, -70);
      ctx.quadraticCurveTo(0.38*W, -210, 0.16*W, TOP+32);
      ctx.stroke();
      ctx.restore();

      // Textura “papel”: puntitos y fibras (muy sutil)
      ctx.save();
      ctx.globalAlpha *= 0.07;
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      for(let i=0;i<28;i++){
        const x = (rnd()*2-1) * W*0.62;
        const y = TOP + rnd()*(BOT-TOP)*0.92;
        const r = 0.7 + rnd()*1.4;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, TAU);
        ctx.fill();
      }
      // fibras: trazos muy cortos
      ctx.globalAlpha *= 0.65;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1.0;
      for(let i=0;i<16;i++){
        const x = (rnd()*2-1) * W*0.58;
        const y = TOP + rnd()*(BOT-TOP)*0.90;
        const a = rnd()*TAU;
        const L = 6 + rnd()*10;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(a)*L, y + Math.sin(a)*L*0.5);
        ctx.stroke();
      }
      ctx.restore();

      // Tint cálido leve si se pide (para paneles laterales)
      if(warmTint){
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha *= 0.10;
        ctx.fillStyle = 'rgba(255,235,210,0.7)';
        conePath(W, 0);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    };

    // Paneles del cono (back -> front)
    paperPanel( 0.00,  1, 0.94, 1.18, 0, false);   // trasero
    paperPanel(-0.30,  1, 0.96, 1.08, 8, true);    // izquierdo
    paperPanel( 0.32, -1, 0.96, 1.08, 8, true);    // derecho
    paperPanel( 0.08,  1, 0.90, 0.98, 12, false);  // frontal

    // Banda central muy sutil (para “unir”)
    ctx.save();
    ctx.globalAlpha *= 0.22;
    const band = ctx.createLinearGradient(0, TOP, 0, 40);
    band.addColorStop(0, 'rgba(255,255,255,0.22)');
    band.addColorStop(0.5, 'rgba(240,236,226,0.10)');
    band.addColorStop(1, 'rgba(0,0,0,0.00)');
    ctx.fillStyle = band;
    ctx.beginPath();
    ctx.moveTo(-164, 14);
    ctx.quadraticCurveTo(0, -12, 164, 14);
    ctx.lineTo(130, TOP+12);
    ctx.quadraticCurveTo(0, TOP-30, -130, TOP+12);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Listón (mantener el contraste con el papel claro)
    ctx.save();
    ctx.translate(0, 18);

    const rib = ctx.createLinearGradient(-112, 0, 112, 0);
    rib.addColorStop(0, 'rgba(22,7,14,0.62)');
    rib.addColorStop(0.5, 'rgba(118,34,58,0.56)');
    rib.addColorStop(1, 'rgba(14,6,12,0.62)');

    ctx.fillStyle = rib;
    ctx.shadowColor = 'rgba(0,0,0,0.34)';
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(-114, -12);
    ctx.quadraticCurveTo(0, 20, 114, -12);
    ctx.quadraticCurveTo(0, 42, -114, -12);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;

    // brillo banda
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha *= 0.18;
    ctx.strokeStyle = 'rgba(255,235,245,0.24)';
    ctx.lineWidth = 2.0;
    ctx.beginPath();
    ctx.moveTo(-102, -10);
    ctx.quadraticCurveTo(0, 10, 102, -10);
    ctx.stroke();
    ctx.restore();

    // nudo
    const knot = ctx.createRadialGradient(-6, -2, 2, 0, 2, 30);
    knot.addColorStop(0, 'rgba(150,62,90,0.66)');
    knot.addColorStop(0.55, 'rgba(66,18,36,0.62)');
    knot.addColorStop(1, 'rgba(14,6,12,0.60)');
    ctx.fillStyle = knot;
    ctx.beginPath();
    ctx.ellipse(0, 2, 24, 15, 0, 0, TAU);
    ctx.fill();

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = 'rgba(255,255,255,0.40)';
    ctx.beginPath();
    ctx.ellipse(-6, -1, 11, 5.4, -0.2, 0, TAU);
    ctx.fill();

    // colitas
    ctx.globalAlpha = 0.74;
    const tailGrad = ctx.createLinearGradient(0, 10, 0, 84);
    tailGrad.addColorStop(0, 'rgba(112,32,56,0.42)');
    tailGrad.addColorStop(1, 'rgba(14,5,10,0.42)');
    ctx.fillStyle = tailGrad;

    const tail = (x, flip) => {
      ctx.save();
      ctx.translate(x, 20);
      ctx.scale(flip, 1);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(18, 12, 26, 36);
      ctx.quadraticCurveTo(14, 70, -14, 74);
      ctx.quadraticCurveTo(-18, 44, 0, 0);
      ctx.closePath();
      ctx.fill();

      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.moveTo(6, 68);
      ctx.lineTo(26, 72);
      ctx.lineTo(10, 90);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    };
    tail(-32, 1);
    tail( 32,-1);

    ctx.restore(); // ribbon
    ctx.restore();
  }





// ===== Bouquet =====
  const DESCS = [
    // 6 gerberas: ramo más junto (compacto) pero sin encimar pétalos
    {dx:-0.62, hf:0.98, bs:0.82},
    {dx:-0.40, hf:1.08, bs:0.92},
    {dx:-0.14, hf:1.16, bs:0.94},
    {dx: 0.14, hf:1.16, bs:0.94},
    {dx: 0.40, hf:1.08, bs:0.92},
    {dx: 0.62, hf:0.98, bs:0.82},
  ];
  const BLOOM_COLORS = ['#6EC1FF','#3A86FF','#2F74E8','#8ED4FF','#4DA3FF','#B7E6FF'];

  let bouquet = [];

  function seedBouquet(){
    const cx = W*0.5;
    const baseY = H*0.93;
    const scaleBase = lerp(0.74, 1.12, clamp(Math.min(W, H)/820, 0, 1));
    const spread = Math.min(W*0.52, 280 + W*0.06);
bouquet = DESCS.map((p,i)=>{
      const scale = scaleBase * p.bs;
      const bw = (36 + ((i%3)-1)*2) * scale;
      const bh = (82 + ((i%4)-2)*3) * scale;
      const twist = p.dx * 0.09;

      return {
        i,
        x: cx + p.dx*spread,
        baseY,
        scale,
        height: (235 * scaleBase) * p.hf,
        phase: i*0.85,
        bw, bh,
        twist,
        seed: 1337 + i*101,
        col: colorFromSeed(1337 + i*101),
        open: 0.92 + (i % 4) * 0.03
      };
    });
  }

  function drawBouquet(t){
    drawGrass(t);

        // sombra suave del primer plano (cacheado)
    rebuildBouquetShadeCache();
    if(bouquetShadeCache){
      ctx.drawImage(bouquetShadeCache, 0, 0, bouquetShadeCache.width / DPR, bouquetShadeCache.height / DPR);
    }else{
      const hx = W*0.5, hy = H*0.78;
      const hg = ctx.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
      hg.addColorStop(0, 'rgba(0,0,0,0)');
      hg.addColorStop(1, 'rgba(0,0,0,0.30)');
      ctx.fillStyle = hg;
      ctx.fillRect(0,0,W,H);
    }

// Campo de flores al fondo (detrás del arbusto y por encima del suelo)
    rebuildFieldBandCache();
    if(fieldBandCache){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha *= 0.95; // visible pero sin “aplastar” la noche
      ctx.drawImage(fieldBandCache, 0, 0, fieldBandCache.width / DPR, fieldBandCache.height / DPR);
      ctx.restore();
    }

// Arbusto: base cacheada + borde suave (sin tapar el campo ni borrar el césped)
    rebuildBushCache();
    if(bushCache){
      const bushTop = H*0.78;

      // Pasada 1: franja suave arriba (fade visual, sin composiciones destructivas)
      ctx.save();
      ctx.globalAlpha *= 0.22;
      ctx.beginPath();
      ctx.rect(0, bushTop - H*0.06, W, H*0.14);
      ctx.clip();
      ctx.drawImage(bushCache, 0, 0, bushCache.width / DPR, bushCache.height / DPR);
      ctx.restore();

      // Pasada 2: base más densa, recortada hacia abajo
      ctx.save();
      ctx.globalAlpha *= 0.62;
      ctx.beginPath();
      ctx.rect(0, bushTop, W, H - bushTop);
      ctx.clip();
      ctx.drawImage(bushCache, 0, 0, bushCache.width / DPR, bushCache.height / DPR);
      ctx.restore();
    }

    // Brillo animado leve
    // Brillo animado leve (como “respiración” del follaje)
    if(!(CONFIG.reduceMotion && !CONFIG.forceFlowerMotion)){
      const tt = t * 0.001;
      const pulse = 0.5 + 0.5*Math.sin(tt*0.9);
      const cx = W*(0.50 + 0.06*Math.sin(tt*0.25));
      const cy = H*0.80;
      const rr = Math.min(W,H) * (0.62 + 0.10*pulse);

      const glow = ctx.createRadialGradient(cx, cy, 10, cx, cy, rr);
      glow.addColorStop(0, `rgba(120,220,160,${0.06 + 0.04*pulse})`);
      glow.addColorStop(0.55, `rgba(80,180,130,${0.035 + 0.03*pulse})`);
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = glow;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }
const STEM = {r:55,g:155,b:92};
    const STEM2= {r:35,g:120,b:72};

    const gw = windField(t) * CONFIG.sway;

    const order = drawBouquet._order || (drawBouquet._order = []);
    order.length = bouquet.length;
    for(let i=0;i<bouquet.length;i++) order[i] = bouquet[i];
    order.sort((a,b)=> (b.height - a.height) || (a.x - b.x));

    const introActive = INTRO.active;
    const master = introActive ? clamp((t - INTRO.t0) / INTRO.dur, 0, 1) : 1;
    if(introActive && master >= 1) INTRO.active = false;

    for(const f of order){
      let uGen=1, stemU=1, leafU=1, bloomU=1, petals=6;
      if(introActive){
        const start = f.i * 0.055;
        const span  = 0.72;
        uGen   = clamp((master - start) / span, 0, 1);
        stemU  = smoothstep(0.00, 0.56, uGen);
        leafU  = smoothstep(0.18, 0.78, uGen);
        bloomU = smoothstep(0.56, 1.00, uGen);
        const pU = smoothstep(0.60, 1.00, uGen);
        petals = clamp(Math.floor(pU*6 + 0.001), 0, 6);
      }

      const sway = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : (gw*0.22 + Math.sin(t*0.001 + f.phase) * 0.08 * CONFIG.sway);
      const angle = sway + (f.x - W*0.5) * 0.0006;

      const baseX = f.x;
      const baseY = f.baseY;
      const topY  = baseY - f.height;

      const bloomXFull = baseX + Math.sin(angle) * 12 * f.scale;
      const bloomYFull = topY + Math.cos(angle) * 5 * f.scale;

      const cp1x = baseX + Math.sin(f.phase)*10*f.scale;
      const cp1y = baseY - f.height*0.40;
      const cp2x = baseX + Math.cos(f.phase*1.7)*16*f.scale;
      const cp2y = baseY - f.height*0.76;

      const endP = {
        x: cubic(stemU, baseX, cp1x, cp2x, bloomXFull),
        y: cubic(stemU, baseY, cp1y, cp2y, bloomYFull)
      };

      const leafMid1 = baseY - f.height*(0.52*stemU);
      const leafMid2 = baseY - f.height*(0.60*stemU);

      if(leafU > 0.001){
        ctx.save();
        ctx.globalAlpha *= leafU;
        const ls = f.scale * (0.18 + 0.82*leafU);
        drawTulipLeaf(baseX, leafMid1, angle, ls*0.56, -1);
        drawTulipLeaf(baseX, leafMid2, angle, ls*0.50,  1);
        drawLeafSprig(baseX, baseY - f.height*(0.56*stemU), angle, ls*0.52, -1);
        drawLeafSprig(baseX, baseY - f.height*(0.64*stemU), angle, ls*0.46,  1);
        ctx.restore();
      }

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Variación sutil por tallo (evita que todos sean el mismo “tubo”)
      let ss = (f.seed * 1664525 + 1013904223) >>> 0;
      const jr = (ss / 4294967296) - 0.5; // -0.5..0.5

      const STEMa = {
        r: clamp(STEM.r  + jr*10, 20, 90),
        g: clamp(STEM.g  + jr*14, 70, 190),
        b: clamp(STEM.b  + jr*10, 40, 140)
      };
      const STEMb = {
        r: clamp(STEM2.r + jr*12, 10, 80),
        g: clamp(STEM2.g + jr*14, 50, 170),
        b: clamp(STEM2.b + jr*12, 25, 120)
      };

      const wBase = 7.2 * f.scale;
      const wTip  = 3.6 * f.scale;

      const sg = ctx.createLinearGradient(baseX, baseY, endP.x, endP.y);
      sg.addColorStop(0.00, rgba(STEMb.r, STEMb.g, STEMb.b, 0.10));
      sg.addColorStop(0.12, rgba(STEMb.r, STEMb.g, STEMb.b, 0.55));
      sg.addColorStop(0.34, rgba(STEMa.r, STEMa.g, STEMa.b, 0.95));
      sg.addColorStop(1.00, rgba(STEMa.r, STEMa.g, STEMa.b, 0.95));

      // Cuerpo con taper
      ctx.strokeStyle = sg;
      strokeCubicTaperPartial(baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, stemU, wBase, wTip, 34);

      // “Nervio” interno oscuro (da profundidad)
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.10;
      ctx.strokeStyle = 'rgba(0,0,0,0.30)';
      strokeCubicTaperPartial(baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, stemU, wBase*0.38, Math.max(1, wTip*0.42), 28);
      ctx.restore();

      // Volumen del tallo: sombra (lado opuesto a la luna) + brillo (lado de la luna)
      const offX = LIGHT_DIR.x * wBase * 0.22;
      const offY = LIGHT_DIR.y * wBase * 0.22;

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.16;
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      strokeCubicTaperPartial(baseX - offX, baseY - offY, cp1x - offX, cp1y - offY, cp2x - offX, cp2y - offY, bloomXFull - offX, bloomYFull - offY, stemU, wBase*0.55, wTip*0.55, 26);
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.14;
      ctx.strokeStyle = 'rgba(210,255,230,0.60)';
      strokeCubicTaperPartial(baseX + offX*0.70, baseY + offY*0.70, cp1x + offX*0.70, cp1y + offY*0.70, cp2x + offX*0.70, cp2y + offY*0.70, bloomXFull + offX*0.70, bloomYFull + offY*0.70, stemU, Math.max(1, wBase*0.22), Math.max(1, wTip*0.20), 24);
      ctx.restore();

      // Nodos sutiles (pequeñas “juntas” del tallo)
      if(stemU > 0.40){
        drawStemNode(Math.min(stemU, 0.42), baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, 4.4*f.scale, 0.11);
      }
      if(stemU > 0.68){
        drawStemNode(Math.min(stemU, 0.68), baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, 4.0*f.scale, 0.10);
      }

      // Fade suave para integrarlo con el pasto (sin “corte” duro)
      const fadeH = 92 * f.scale;
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      const fg = ctx.createLinearGradient(0, baseY + 2, 0, baseY - fadeH);
      fg.addColorStop(0.00, 'rgba(0,0,0,0.85)');
      fg.addColorStop(0.55, 'rgba(0,0,0,0.22)');
      fg.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      ctx.strokeStyle = fg;
      strokeCubicTaperPartial(baseX, baseY, cp1x, cp1y, cp2x, cp2y, bloomXFull, bloomYFull, stemU, wBase + 4.6*f.scale, wTip + 3.0*f.scale, 22);
      ctx.restore();

      ctx.restore();

      // sombra de contacto bajo la flor (le da "peso" y profundidad)
      if(bloomU > 0.02){
        ctx.save();
        ctx.globalAlpha = 0.11 * bloomU;
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        ctx.beginPath();
        ctx.ellipse(endP.x, endP.y + 6*f.scale, 10*f.scale, 4.2*f.scale, angle, 0, TAU);
        ctx.fill();
        ctx.restore();
      }


      f.bloomX = endP.x;
      f.bloomY = endP.y;
      f.angle = angle + f.twist;
      f._bloomU = bloomU;
      f._petals = petals;
      f._bloomScale = introActive ? lerp(0.18, 1.0, bloomU) : 1;
      f._openNow = introActive ? (Math.round(lerp(0.86, f.open, bloomU)*20)/20) : f.open;
    }

    
    // Envoltura + bruma para que el ramo no flote como sticker
    const wrapS = lerp(0.82, 1.10, clamp(Math.min(W,H)/820, 0, 1));
    const wrapAlpha = introActive ? smoothstep(0.28, 0.78, master) : 1;
    ctx.save();
    ctx.globalAlpha *= wrapAlpha;
    // (envoltorio desactivado)
ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const fogTop = H*0.72;
    const fog = ctx.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(120,150,220,0)');
    fog.addColorStop(0.55, 'rgba(120,150,220,0.06)');
    fog.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = fog;
    ctx.fillRect(0, fogTop, W, H - fogTop);
    ctx.restore();

    const bloomOrder = drawBouquet._bloom || (drawBouquet._bloom = []);

    bloomOrder.length = order.length;
    for(let i=0;i<order.length;i++) bloomOrder[i] = order[i];
    bloomOrder.sort((a,b)=>a.bloomY - b.bloomY);

for(const f of bloomOrder){
      const bu = (f._bloomU ?? 1);
      if(bu <= 0.001) continue;

      ctx.save();
      ctx.translate(f.bloomX, f.bloomY);
      ctx.globalAlpha *= bu;
      const bScale = (f._bloomScale ?? 1);
      ctx.scale(bScale, bScale);

      // Depth of field barato pero efectivo: las flores del fondo se suavizan un poco
      const ny = f.bloomY / H;
      const depth = clamp((ny - 0.34) / 0.34, 0, 1); // 0=lejos, 1=cerca
      const blur = (1 - depth) * (1 - depth) * 1.6;
      ctx.globalAlpha *= lerp(0.86, 1.0, depth);
      if(HAS_FILTER && blur > 0.02) ctx.filter = `blur(${blur.toFixed(2)}px)`;

      // Movimiento suave extra sólo para la cabeza de la gerbera (independiente del tallo)
      const tt = t * 0.001; // ms -> s
      const headWobble = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : (
        (Math.sin(tt*2.2 + f.phase*3.7) * 0.16) +
        (Math.sin(tt*3.4 + f.phase*1.9) * 0.07)
      ) * CONFIG.sway;

      const bobX = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : Math.sin(tt*1.6 + f.phase*4.1) * (5.0*f.scale) * CONFIG.sway;
      const bobY = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 0 : Math.sin(tt*1.9 + f.phase*2.0) * (3.6*f.scale) * CONFIG.sway;

      const breathe = (CONFIG.reduceMotion && !CONFIG.forceFlowerMotion) ? 1 : (1 + Math.sin(tt*1.5 + f.phase*0.7) * 0.02 * CONFIG.sway);

      ctx.translate(bobX, bobY);
      ctx.scale(breathe, breathe);
      ctx.rotate(f.angle + headWobble);

      ctx.shadowColor = `rgba(${f.col.r},${f.col.g},${f.col.b},0.16)`;
      ctx.shadowBlur = (10 + 12*f.scale) * bScale;

      drawTulipBloom(f.bw, f.bh, f.col, f.seed, (f._openNow ?? f.open), (f._petals ?? 6));

      // “Shimmer” ligero sobre el centro/pétalos para dar vida sin re-renderizar sprites cada frame
      if(!CONFIG.reduceMotion){
        const cy = -f.bh*0.62;
        const r0 = Math.min(f.bw, f.bh) * 0.19;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha *= 0.075 * (0.35 + 0.65*(0.5 + 0.5*Math.sin(tt*4.1 + f.phase*1.3)));
        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.lineWidth = Math.max(0.9, 1.15 * f.scale);
        for(let k=0;k<8;k++){
          const a = (k/8)*TAU + tt*0.7 + f.phase*0.15;
          const x1 = Math.cos(a)*r0*0.18;
          const y1 = cy + Math.sin(a)*r0*0.14;
          const x2 = Math.cos(a)*r0*0.95;
          const y2 = cy + Math.sin(a)*r0*0.72;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();
      }
      if(HAS_FILTER) ctx.filter = 'none';
      ctx.restore();
    }

    const knotX = W*0.5, knotY = H*0.935;
    ctx.save();
    ctx.globalAlpha *= (introActive ? wrapAlpha : 1);
    // Sombra más suave bajo el nudo/envoltura (evita la “línea negra”)
    const ks = ctx.createRadialGradient(knotX, knotY, 6, knotX, knotY, Math.min(140, W*0.26));
    ks.addColorStop(0, 'rgba(0,0,0,0.16)');
    ks.addColorStop(0.55, 'rgba(0,0,0,0.08)');
    ks.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = ks;
    ctx.beginPath();
    ctx.ellipse(knotX, knotY, Math.min(130, W*0.24), 34, 0, 0, TAU);
    ctx.fill();ctx.restore();
  }

  function addSparkle(x, y, t){
    tapSparkles.push({ x, y, t0: t, seed: Math.random()*9999 });
    if(tapSparkles.length > 28) tapSparkles.shift();
  }

  function drawTapSparkles(t){
    if(!tapSparkles.length) return;

    for(let i=tapSparkles.length-1;i>=0;i--){
      const s = tapSparkles[i];
      const age = (t - s.t0) / 1000;
      if(age > 0.95){ tapSparkles.splice(i,1); continue; }

      const k = 1 - age/0.95;
      const r = (14 + age*56);
      const pulse = 0.6 + 0.4*Math.sin((t*0.01) + s.seed);

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.46 * k;

      const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, r);
      g.addColorStop(0, `rgba(255,255,255,${0.32*k})`);
      g.addColorStop(0.28, `rgba(200,220,255,${0.20*k})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;

      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, TAU);
      ctx.fill();

      ctx.globalAlpha = 0.18 * k * pulse;
      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.moveTo(s.x - r*0.55, s.y);
      ctx.lineTo(s.x + r*0.55, s.y);
      ctx.moveTo(s.x, s.y - r*0.55);
      ctx.lineTo(s.x, s.y + r*0.55);
      ctx.stroke();

      ctx.restore();
    }
  }


  function resize(){
    DPR = Math.min(CONFIG.dprCap || 1.8, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    bloomCache.clear();

    seedStars();
    buildStarText();
    rebuildSkyCache();
    rebuildMoonCache();
    rebuildStaticSkyOverlayCache();
    rebuildSkyDynCache();

    rebuildFieldCache();
    seedBouquet();
    seedSoil();
    seedGrass();
    rebuildGroundCache();

    rebuildBouquetShadeCache();

    for(const f of bouquet){
      getBloomSprite(f.bw, f.bh, f.col, f.seed, f.open);
    }
    if(CONFIG.debug) selfTest();
  }
  var _resizeRaf = 0;
  function requestResize(){
    if(_resizeRaf) cancelAnimationFrame(_resizeRaf);
    _resizeRaf = requestAnimationFrame(()=>{ _resizeRaf = 0; resize(); });
  }
  window.addEventListener('resize', requestResize, {passive:true});

  canvas.addEventListener('pointerdown', (e) => {
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left);
    const y = (e.clientY - r.top);
    addSparkle(x, y, performance.now());

    // si le picas cerca del cielo, regalamos una estrella fugaz
    if(y < H*0.55 && !shooting.active) maybeStartShootingStar(performance.now());
  }, {passive:true});



  function selfTest(){
    console.assert(!!canvas && !!ctx, 'Canvas/ctx no disponibles');
    console.assert(Number.isFinite(W) && W>0 && Number.isFinite(H) && H>0, 'Canvas size inválido');
    console.assert(Array.isArray(stars) && stars.length>0, 'Stars no inicializadas');
    console.assert(Array.isArray(starLinks), 'starLinks no existe');
    console.assert(stars.length < 40 || starLinks.length > 0, 'Constelaciones no generadas');
    console.assert(Array.isArray(tapSparkles), 'tapSparkles no existe');
    console.assert(Array.isArray(textStars) && textStars.length>200, 'Texto en estrellas no generado');
    console.assert(Array.isArray(grass) && grass.length>0, 'Grass no inicializado');
    console.assert(grassAnim1.length>0 && grassAnim2.length>0, 'Grass anim no inicializado');
    console.assert(Array.isArray(soil) && soil.length>0, 'Soil no inicializado');
    console.assert(!!groundCache && groundCache.width>0, 'Ground cache no generado');
    console.assert(!!skyCache && skyCache.width>0, 'Sky cache no generado');
    console.assert(Array.isArray(bouquet) && bouquet.length===DESCS.length, 'Bouquet no se generó correctamente');
    console.assert(CONFIG.crownStrength >= 0 && CONFIG.crownStrength <= 1, 'crownStrength fuera de rango');

    // Smoke test de dibujo: esto también calcula bloomX/bloomY
    try{ drawBouquet(0); }catch(e){ console.error('drawBouquet fallo', e); }
    console.assert(bouquet.every(f=>Number.isFinite(f.bloomX) && Number.isFinite(f.bloomY)), 'bloomX/bloomY no calculados');

    const spr = getBloomSprite(60, 100, {r:235,g:55,b:70}, 42, 0.95);
    console.assert(spr && spr.canvas && spr.ss === 2 && spr.canvas.width>0, 'Sprite inválido');
  }
  requestResize();

  let _rafId = 0;
  let _lastDraw = 0;

  // Auto-calidad (A): baja/sube preset según el rendimiento real
  let _emaDt = 16;
  let _goodFrames = 0;
  let _cooldownUntil = 0;

  function autoQualityTick(dt, t){
    if(!CONFIG.autoQuality) return;

    _emaDt = _emaDt*0.92 + dt*0.08;

    if(t < _cooldownUntil) return;

    const q = (CONFIG.quality ?? 2);

    // si va lento, baja calidad rápido
    if(_emaDt > 28 && q > 0){
      applyQuality(q - 1);
      _cooldownUntil = t + 2500;
      _goodFrames = 0;
      return;
    }

    // si va muy fluido sostenido, sube calidad con paciencia
    if(_emaDt < 17 && q < 2){
      _goodFrames++;
      if(_goodFrames > 160){
        applyQuality(q + 1);
        _cooldownUntil = t + 4500;
        _goodFrames = 0;
      }
    }else{
      _goodFrames = 0;
    }
  }

  function frame(t){
    _rafId = requestAnimationFrame(frame);

    const minStep = 1000 / (CONFIG.maxFPS || 60);
    if(_lastDraw && (t - _lastDraw) < minStep) return;

    const dt = _lastDraw ? (t - _lastDraw) : 0;
    _lastDraw = t;

    if(dt) autoQualityTick(dt, t);

    drawSky(t);
    drawBouquet(t);
    drawTapSparkles(t);

    updateHUD(false);
  }


function start(){
  if(_rafId) return;
  _lastDraw = 0;
  _rafId = requestAnimationFrame(frame);
}

function stop(){
  if(!_rafId) return;
  cancelAnimationFrame(_rafId);
  _rafId = 0;
}

document.addEventListener('visibilitychange', () => {
  if(document.hidden) stop();
  else start();
}, {passive:true});

start();
})();
</script>
</body>
</html>
