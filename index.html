<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ramo de tulipanes rosados (noche)</title>
  <style>
    :root{
      --bg1:#070814;
      --bg2:#0b1030;
      --bg3:#151a40;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(900px 650px at 50% 10%, var(--bg3), var(--bg2), var(--bg1));
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="err" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:24px;color:#e8e8ff;font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;background:rgba(0,0,0,0.55);backdrop-filter: blur(6px);-webkit-backdrop-filter: blur(6px);text-align:center;z-index:5;">Cargando…</div>

<script>
/* Fallback: si algo truena, al menos verás el error en pantalla (en vez de “nada”). */
const __err = document.getElementById('err');
window.__hideErr = () => { if(__err) __err.style.display = 'none'; };
window.addEventListener('error', (e) => {
  if(!__err) return;
  const msg = (e && (e.message || (e.error && e.error.message))) || 'Error desconocido';
  __err.innerHTML = 'Ups. El navegador se quejó y no dibujó nada.<br><br><b>' + msg + '</b><br><br>Si esto pasa en Safari viejo, es por compatibilidad de JS.';
  __err.style.display = 'flex';
});

(() => {
  'use strict';

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  let HAS_FILTER = false; try{ ctx.filter = 'none'; HAS_FILTER = (typeof ctx.filter !== 'undefined'); }catch(_){ HAS_FILTER = false; }

  let W = 0, H = 0, DPR = 1;

  const TAU = Math.PI * 2;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rgba  = (r,g,b,a)=>`rgba(${r},${g},${b},${a})`;

  // Campo de viento global (compartido por pasto y tulipanes)
  const windField = (t) => {
    if(CONFIG.reduceMotion) return 0;
    // combinación lenta (natural y suave)
    return (Math.sin(t*0.00055)*0.78 + Math.sin(t*0.00023 + 1.7)*0.34);
  };

  const shuffleInPlace = (arr) => {
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  };

  const makePRNG = (seed) => {
    let s = (seed >>> 0) || 1;
    return () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);
  };

  const CONFIG = {
    stars: 240,
    twinkle: 0.80,
    sway: 0.28,
    reduceMotion: false,
    shootingStars: 1,

    // 0..1: “corona/picos” (arriba del tulipán). 0 = casi lisa
    crownStrength: 0.006,

    // Texto “en estrellas”
    starText: 'For you <3',
    starTextStrength: 0.95
  };

  try{
    const m = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
    if(m && m.matches) CONFIG.reduceMotion = true;
  }catch(_){}

  // ===== Stars =====
  const stars = [];
  const starLinks = [];
  const textStars = [];
  const tapSparkles = [];

  // Luz “luna” coherente (arriba-derecha)
  const LIGHT = { x: 0.82, y: 0.14 };
  const LIGHT_DIR = (() => {
    const dx = 0.74, dy = -0.52;
    const inv = 1 / Math.max(1e-6, Math.hypot(dx,dy));
    return { x: dx*inv, y: dy*inv };
  })();

  const shooting = { active:false, t0:0, dur:0, x0:0,y0:0, x1:0,y1:0 };

  function seedStars(){
    stars.length = 0;
    starLinks.length = 0;

    const clusters = [
      {cx: 0.28, cy: 0.20, r: 0.18},
      {cx: 0.72, cy: 0.16, r: 0.20},
      {cx: 0.52, cy: 0.30, r: 0.16},
    ];

    const mwBand = () => {
      const t = Math.random();
      const x = lerp(0.14, 0.92, t);
      const y = lerp(0.48, 0.20, t);
      const off = (Math.random()-0.5) * 0.10;
      return { x: clamp(x + off*0.90, 0, 1), y: clamp(y + off*(-0.55), 0, 1) };
    };

    const pick = () => {
      const r = Math.random();
      if(r < 0.62){
        const x = Math.random();
        const y = Math.pow(Math.random(), 1.55);
        return {x, y};
      }
      if(r < 0.78) return mwBand();

      const c = clusters[(Math.random()*clusters.length)|0];
      const a = Math.random()*TAU;
      const rr = Math.sqrt(Math.random()) * c.r;
      return { x: clamp(c.cx + Math.cos(a)*rr, 0, 1), y: clamp(c.cy + Math.sin(a)*rr, 0, 1) };
    };

    for(let i=0;i<CONFIG.stars;i++){
      const p = pick();
      const yBias = Math.pow(1 - p.y, 1.8);

      const roll = Math.random();
      const big = roll < (0.035 + 0.020*yBias);
      const mid = !big && roll < (0.18 + 0.05*yBias);

      const rBase = big ? (2.2 + Math.random()*3.0)
                  : (mid ? (1.2 + Math.random()*1.4) : (0.55 + Math.random()*0.95));
      const aBase = big ? (0.18 + Math.random()*0.28)
                  : (mid ? (0.10 + Math.random()*0.16) : (0.05 + Math.random()*0.12));

      let hue = 0;
      const temp = Math.random();
      if(temp < 0.10) hue = 205 + Math.random()*35;
      else if(temp < 0.16) hue = 35 + Math.random()*18;
      else if(big && temp < 0.45) hue = 200 + Math.random()*60;

      stars.push({
        x: p.x, y: p.y,
        z: big ? 0.92 : (mid ? 0.68 : (0.35 + Math.random()*0.35)),
        r: rBase, a: aBase,
        p: Math.random()*TAU,
        s: (0.25 + Math.random()*0.95),
        hue,
        flare: big ? (0.55 + Math.random()*0.45) : (mid ? (0.18 + Math.random()*0.35) : 0),
        tw: big ? (0.45 + Math.random()*0.40) : (mid ? (0.30 + Math.random()*0.30) : (0.18 + Math.random()*0.22))
      });
    }

    buildConstellations();

    shooting.active = false;
    shooting.t0 = 0;
    shooting.dur = 0;
  }

  function buildConstellations(){
    starLinks.length = 0;
    if(stars.length < 6) return;

    // Conectamos algunas estrellas brillantes en "constelaciones" sutiles (sin volverlo un mapa de metro)
    const ids = stars
      .map((s,i)=>({i, score: s.r * (0.85 + s.a)}))
      .sort((a,b)=>b.score-a.score)
      .slice(0, 18)
      .map(o=>o.i);

    const maxDist = 0.13;
    const used = new Set();

    for(const i of ids){
      let best1=-1,best2=-1;
      let d1=1e9,d2=1e9;

      for(const j of ids){
        if(j===i) continue;
        const dx = stars[i].x - stars[j].x;
        const dy = stars[i].y - stars[j].y;
        const d = Math.hypot(dx,dy);
        if(d > maxDist) continue;

        if(d < d1){ d2=d1; best2=best1; d1=d; best1=j; }
        else if(d < d2){ d2=d; best2=j; }
      }

      const add = (j, dist) => {
        if(j < 0 || !Number.isFinite(dist)) return;
        const a = Math.max(0.016, 0.055 - dist*0.22);
        const key = i<j ? `${i}-${j}` : `${j}-${i}`;
        if(used.has(key)) return;
        used.add(key);
        starLinks.push({i, j, a});
      };

      add(best1, d1);
      add(best2, d2);
    }
  }


  
  // ===== Texto "en estrellas" =====
  // Genera puntos (textStars) a partir de un renderizado offscreen del texto.
  function buildStarText(){
    textStars.length = 0;
    const txt = (CONFIG.starText || '').trim();
    if(!txt || CONFIG.starTextStrength <= 0) return;

    // Offscreen pequeño para no freír el teléfono
    const off = document.createElement('canvas');
    const scale = 0.85; // baja resolución = más rápido
    const w = Math.max(320, Math.floor(W * scale));
    const h = Math.max(320, Math.floor(H * scale));
    off.width = w;
    off.height = h;

    const g = off.getContext('2d', { alpha:true, willReadFrequently:true });

    // Limpia
    g.clearRect(0,0,w,h);

    // Tipografía: grande pero sobria (como ya tenías en el cielo)
    const tSize = Math.min(w, h) * 0.095;
    g.textAlign = 'center';
    g.textBaseline = 'middle';
    g.font = `700 ${Math.round(tSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;

    // Sombra/glow para engordar el trazo (mejor muestreo)
    g.save();
    g.fillStyle = 'rgba(255,255,255,1)';
    g.shadowColor = 'rgba(255,255,255,0.85)';
    g.shadowBlur = Math.max(6, tSize*0.22);
    g.fillText(txt, w*0.5, h*0.28);
    g.restore();

    // Lee pixeles y muestrea puntos
    let img;
    try{
      img = g.getImageData(0,0,w,h).data;
    }catch(e){
      // Si el navegador se pone exquisito, mejor no romper nada.
      return;
    }

    const pr = makePRNG((w*2654435761) ^ (h*1597334677) ^ (txt.length*97531));
    const step = Math.max(2, Math.floor(tSize / 14));
    const thr = 18; // alpha threshold

    const pts = [];
    // zona alrededor del texto: arriba del cielo
    const y0 = Math.floor(h*0.12);
    const y1 = Math.floor(h*0.42);

    for(let y=y0; y<y1; y+=step){
      for(let x=0; x<w; x+=step){
        const a = img[(y*w + x)*4 + 3];
        if(a > thr){
          // jitter sutil para que no sea "grid"
          const jx = (pr()-0.5) * step;
          const jy = (pr()-0.5) * step;
          pts.push({x: (x+jx)/scale, y: (y+jy)/scale, a: a/255});
        }
      }
    }

    if(pts.length === 0) return;

    // Limita cantidad (móvil friendly) y distribuye uniforme
    const target = clamp(Math.floor(Math.min(1400, 420 + (W*0.55))), 320, 1400);
    shuffleInPlace(pts);

    // Convertimos a "estrellas" del texto
    const count = Math.min(target, pts.length);
    for(let i=0;i<count;i++){
      const p = pts[i];
      const big = pr() < 0.10;
      textStars.push({
        x: p.x,
        y: p.y,
        r: big ? (1.6 + pr()*1.6) : (0.8 + pr()*1.1),
        a: (0.10 + p.a*0.55) * (big ? 1.05 : 0.95),
        p: pr()*TAU,
        s: (0.45 + pr()*1.10),
        flare: big ? (0.35 + pr()*0.55) : 0
      });
    }
  }

  function drawStarText(t){
    if(!textStars.length || CONFIG.starTextStrength <= 0) return;

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';

    const strength = CONFIG.starTextStrength;
    for(const st of textStars){
      const tw = CONFIG.reduceMotion ? 1 : (0.60 + 0.40*Math.sin(t*0.001*st.s + st.p) * CONFIG.twinkle);
      const alpha = st.a * tw * strength;

      ctx.globalAlpha = alpha;
      ctx.shadowColor = 'rgba(255,255,255,0.55)';
      ctx.shadowBlur = 10 + st.r*4;

      ctx.fillStyle = 'rgba(255,255,255,1)';
      ctx.beginPath();
      ctx.arc(st.x, st.y, st.r, 0, TAU);
      ctx.fill();

      // flare discreto (para algunas)
      if(st.flare){
        ctx.save();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = alpha * 0.55 * st.flare;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        const k = 3.5 + st.r*1.4;
        ctx.beginPath();
        ctx.moveTo(st.x-k, st.y); ctx.lineTo(st.x+k, st.y);
        ctx.moveTo(st.x, st.y-k); ctx.lineTo(st.x, st.y+k);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }

function maybeStartShootingStar(t){
    if(CONFIG.reduceMotion || !CONFIG.shootingStars) return;
    if(shooting.active) return;

    if(Math.random() < 0.0022){
      shooting.active = true;
      shooting.t0 = t;
      shooting.dur = 900 + Math.random()*900;

      const startX = Math.random()*W*0.90;
      const startY = Math.random()*H*0.35;
      const dx = (120 + Math.random()*220);
      const dy = (40 + Math.random()*120);

      shooting.x0 = startX; shooting.y0 = startY;
      shooting.x1 = startX + dx; shooting.y1 = startY + dy;
    }
  }

  function drawShootingStar(t){
    if(!shooting.active) return;

    const u = clamp((t - shooting.t0) / shooting.dur, 0, 1);
    const ease = u*u*(3-2*u);

    const x = lerp(shooting.x0, shooting.x1, ease);
    const y = lerp(shooting.y0, shooting.y1, ease);

    const tail = 120;
    const ang = Math.atan2(shooting.y1 - shooting.y0, shooting.x1 - shooting.x0);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = (1-u) * 0.85;

    const tx = x - Math.cos(ang)*tail;
    const ty = y - Math.sin(ang)*tail;

    const g = ctx.createLinearGradient(tx, ty, x, y);
    g.addColorStop(0, 'rgba(255,255,255,0)');
    g.addColorStop(0.55, 'rgba(255,255,255,0.14)');
    g.addColorStop(1, 'rgba(255,255,255,0.85)');

    ctx.strokeStyle = g;
    ctx.lineWidth = 2.0;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(x, y);
    ctx.stroke();

    ctx.globalAlpha = (1-u) * 0.95;
    ctx.shadowColor = 'rgba(255,255,255,0.8)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x,y, 1.8, 0, TAU);
    ctx.fill();

    ctx.restore();

    if(u >= 1) shooting.active = false;
  }

  // ===== Campo (pendiente + flores pequeñas) =====
  // Reemplaza el "césped" denso por una pradera con pendiente, dejando el cielo intacto.
  const meadow = {
    // curva de pendiente (alto en el centro, baja hacia los lados)
    yCenter: 0.78,     // altura base (0..1)
    rise: 0.09,        // cuánto sube el campo donde está el ramo
    softness: 1.65,    // qué tan suave es la colina
    haze: 0.22,        // bruma en la línea del horizonte del campo
    flowers: [],       // flores pequeñas de fondo
    stems: [],         // tallos cortos del campo
  };

  let meadowCache = null;
  let skyCache = null;
  const bloomCache = new Map();
  let meadowTopY = 0;  // y del horizonte del campo en el centro

  function hillY(xNorm){
    // xNorm 0..1, pico en 0.5
    const d = Math.abs(xNorm - 0.5) * 2;             // 0 centro -> 1 borde
    const shape = Math.pow(d, meadow.softness);      // curva
    const y = meadow.yCenter - meadow.rise * (1 - shape);
    return clamp(y, 0.55, 0.92);
  }

  function seedMeadow(){
    meadow.flowers.length = 0;
    meadow.stems.length = 0;

    // Más densidad cerca del horizonte; menos cerca del borde inferior (para no saturar)
    const nFlowers = clamp(Math.floor(W * 0.38), 140, 320);
    const nStems   = clamp(Math.floor(W * 0.55), 220, 520);

    // paleta de florecitas (pastel, lejos)
    const miniCols = [
      {r:215,g:185,b:255}, // lavender
      {r:255,g:200,b:230}, // pink
      {r:255,g:235,b:170}, // warm
      {r:190,g:235,b:255}, // sky-ish
      {r:235,g:245,b:210}, // pale
    ];

    for(let i=0;i<nStems;i++){
      const x = Math.random()*W;
      const xn = x / W;
      const baseY = H * hillY(xn) + (H*0.22) * Math.random(); // desde el horizonte hacia abajo
      const depth = clamp((baseY - H*hillY(xn)) / (H*0.22), 0, 1);

      meadow.stems.push({
        x,
        y: baseY,
        h: 10 + (1-depth) * (28 + Math.random()*22),
        w: 0.6 + Math.random()*1.2,
        a: 0.10 + (1-depth)*0.22,
        bend: (Math.random()-0.5) * (0.10 + (1-depth)*0.18),
        p: Math.random()*TAU,
        s: 0.6 + Math.random()*1.4
      });
    }

    for(let i=0;i<nFlowers;i++){
      const x = Math.random()*W;
      const xn = x / W;
      const hy = H * hillY(xn);

      // Coloca principalmente cerca del horizonte del campo
      const y = hy + Math.random() * (H*0.16);
      const d = clamp((y - hy) / (H*0.16), 0, 1); // 0 cerca horizonte, 1 más abajo
      const size = (1-d) * (2.6 + Math.random()*2.6) + 0.8;
      const col = miniCols[(Math.random()*miniCols.length)|0];

      meadow.flowers.push({
        x, y,
        r: size,
        a: 0.06 + (1-d)*0.12,
        col,
        p: Math.random()*TAU,
        s: 0.35 + Math.random()*0.95
      });
    }
  }

  function rebuildMeadowCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    // pinta el campo con pendiente usando un gradiente por columnas (barato y efectivo)
    const cols = clamp(Math.floor(W / 4), 160, 420);

    for(let i=0;i<cols;i++){
      const xn = i/(cols-1);
      const x = xn * W;
      const yTop = H * hillY(xn);
      if(i===Math.floor(cols/2)) meadowTopY = yTop;

      // gradiente del campo (más claro arriba, más oscuro abajo)
      const gg = g.createLinearGradient(0, yTop, 0, H);
      gg.addColorStop(0, 'rgba(18,70,46,0.18)');
      gg.addColorStop(0.30, 'rgba(18,88,56,0.40)');
      gg.addColorStop(0.62, 'rgba(10,46,30,0.72)');
      gg.addColorStop(1, 'rgba(0,0,0,0.84)');
      g.fillStyle = gg;
      g.fillRect(x, yTop, (W/cols)+1, H - yTop);
    }

    // textura: manchas suaves de color para que no se vea plano
    const blobs = clamp(Math.floor(W / 140), 8, 16);
    for(let i=0;i<blobs;i++){
      const x = W*(0.06 + Math.random()*0.88);
      const xn = x / W;
      const yTop = H * hillY(xn);
      const y = yTop + (H - yTop) * (0.20 + Math.random()*0.80);
      const r = (90 + Math.random()*240);
      const a = 0.05 + Math.random()*0.08;

      const rg = g.createRadialGradient(x, y, 10, x, y, r);
      rg.addColorStop(0, `rgba(55,140,90,${a})`);
      rg.addColorStop(0.55, `rgba(20,70,45,${a*0.55})`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.fillRect(0,0,W,H);
    }

    // tallitos del campo (estáticos)
    g.save();
    g.lineCap = 'round';
    g.lineJoin = 'round';
    for(const b of meadow.stems){
      g.globalAlpha = b.a;
      const sway = 0; // cache estático
      const x0=b.x, y0=b.y;
      const x1=x0 + (b.bend + sway)*18;
      const y1=y0 - b.h;

      const lg = g.createLinearGradient(x0,y0,x1,y1);
      lg.addColorStop(0,'rgba(8,30,18,0.75)');
      lg.addColorStop(1,'rgba(80,220,150,0.28)');
      g.strokeStyle = lg;
      g.lineWidth = b.w;
      g.beginPath();
      g.moveTo(x0,y0);
      g.quadraticCurveTo(x0+(x1-x0)*0.55, y0-(b.h*0.55), x1,y1);
      g.stroke();
    }
    g.restore();

    // flores pequeñas (puntos y mini pétalos)
    g.save();
    g.globalCompositeOperation = 'lighter';
    
    for(const fl of meadow.flowers){
      const x = fl.x, y = fl.y;
      const r = fl.r;

      // halo (atmósfera) para que se sienta “campo” y no puntos planos
      g.globalAlpha = fl.a * 0.55;
      const hh = g.createRadialGradient(x, y - r*3.0, 1, x, y - r*2.2, Math.max(10, r*6.5));
      hh.addColorStop(0, `rgba(${fl.col.r},${fl.col.g},${fl.col.b},0.40)`);
      hh.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = hh;
      g.beginPath();
      g.ellipse(x, y - r*2.3, r*3.2, r*4.0, 0, 0, TAU);
      g.fill();

      g.save();
      g.translate(x, y);

      const w = r * 2.20;
      const h = r * 3.35;

      const topR = Math.min(255, fl.col.r + 55);
      const topG = Math.min(255, fl.col.g + 55);
      const topB = Math.min(255, fl.col.b + 55);

      const botR = Math.max(0, fl.col.r - 45);
      const botG = Math.max(0, fl.col.g - 45);
      const botB = Math.max(0, fl.col.b - 45);

      const vg = g.createLinearGradient(0, -h, 0, h*0.25);
      vg.addColorStop(0, `rgba(${topR},${topG},${topB},0.62)`);
      vg.addColorStop(0.42, `rgba(${fl.col.r},${fl.col.g},${fl.col.b},0.96)`);
      vg.addColorStop(1, `rgba(${botR},${botG},${botB},0.96)`);

      g.globalAlpha = fl.a;
      g.fillStyle = vg;

      // mini tulipán (copita + coronita suave, sin “agujas”)
      const crown = 0.10;
      g.beginPath();
      g.moveTo(-w*0.55, 0);

      g.bezierCurveTo(
        -w*0.80, -h*0.25,
        -w*0.62, -h*0.78,
        -w*0.14, -h*(0.92 - crown*0.12)
      );

      g.quadraticCurveTo(-w*0.06, -h*(1.02 + crown*0.18), 0, -h*(0.96));
      g.quadraticCurveTo( w*0.06, -h*(1.02 + crown*0.18), w*0.14, -h*(0.92 - crown*0.12));

      g.bezierCurveTo(
         w*0.62, -h*0.78,
         w*0.80, -h*0.25,
         w*0.55, 0
      );

      g.quadraticCurveTo(0, h*0.16, -w*0.55, 0);
      g.closePath();
      g.fill();

      // sombra interior
      g.globalCompositeOperation = 'multiply';
      g.globalAlpha = fl.a * 0.18;
      const ig = g.createRadialGradient(0, -h*0.35, 1, 0, -h*0.35, w*0.95);
      ig.addColorStop(0, 'rgba(0,0,0,0)');
      ig.addColorStop(1, 'rgba(0,0,0,0.35)');
      g.fillStyle = ig;
      g.beginPath();
      g.ellipse(0, -h*0.35, w*0.52, h*0.58, 0, 0, TAU);
      g.fill();

      // rim highlight (como “rocío”)
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = fl.a * 0.22;
      const rim = g.createRadialGradient(w*0.18, -h*0.72, 0, w*0.18, -h*0.72, w*1.00);
      rim.addColorStop(0, 'rgba(255,255,255,0.20)');
      rim.addColorStop(1, 'rgba(255,255,255,0)');
      g.fillStyle = rim;
      g.beginPath();
      g.ellipse(0, -h*0.55, w*0.62, h*0.72, 0, 0, TAU);
      g.fill();

      g.restore();
    }
    g.restore();

    // bruma/haze en el horizonte del campo para unir con el cielo
    const hazeY = meadowTopY - H*0.02;
    const hz = g.createLinearGradient(0, hazeY, 0, hazeY + H*0.20);
    hz.addColorStop(0, `rgba(0,0,0,0)`);
    hz.addColorStop(0.25, `rgba(15,35,25,${meadow.haze})`);
    hz.addColorStop(1, `rgba(0,0,0,0.30)`);
    g.fillStyle = hz;
    g.fillRect(0, hazeY, W, H);

    meadowCache = off;
  }

  function drawMeadow(t){
    if(meadowCache){
      ctx.drawImage(meadowCache, 0, 0, meadowCache.width / DPR, meadowCache.height / DPR);
    }else{
      // fallback si por algo no hay cache
      ctx.save();
      for(let i=0;i<220;i++){
        const xn=i/219;
        const yTop=H*hillY(xn);
        ctx.fillStyle='rgba(10,60,35,0.35)';
        ctx.fillRect(xn*W,yTop, W/220+1, H-yTop);
      }
      ctx.restore();
    }

    // animación ligera: algunos tallos (pocos) para "vida" sin saturar
    if(CONFIG.reduceMotion) return;

    const wind = Math.sin(t*0.0007) * 0.55;
    const n = clamp(Math.floor(W*0.22), 70, 140);

    ctx.save();
    ctx.lineCap='round';
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = 'rgba(140,255,200,0.20)';
    ctx.lineWidth = 1;

    for(let i=0;i<n;i++){
      const b = meadow.stems[(i*17) % meadow.stems.length];
      const sway = Math.sin(t*0.0012*b.s + b.p) * 0.16 + wind*0.22;
      const x0=b.x, y0=b.y;
      const x1=x0 + (b.bend + sway)*22;
      const y1=y0 - b.h*(0.85+0.25*Math.sin(t*0.0009+b.p));
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.quadraticCurveTo(x0+(x1-x0)*0.55, y0-(b.h*0.55), x1,y1);
      ctx.stroke();
    }
    ctx.restore();
  }


  // ===== Cielo (cache) =====

  const _spA = {x:0,y:0};
  const _spB = {x:0,y:0};

  function starPos(st, t, out){
    const z = (st.z == null ? 0.55 : st.z);
    if(CONFIG.reduceMotion){
      out.x = st.x * W;
      out.y = st.y * H;
      return out;
    }
    const px = (Math.sin(t*0.00009 + st.p) * 5 + Math.sin(t*0.00023 + st.p*0.7) * 2) * z;
    const py = (Math.cos(t*0.00008 + st.p*1.1) * 4 + Math.sin(t*0.00019 + st.p*0.5) * 1.5) * z;
    out.x = st.x * W + px;
    out.y = st.y * H + py;
    return out;
  }

  function drawConstellations(t){
    if(!starLinks.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = 'rgba(200,220,255,1)';

    for(const L of starLinks){
      const a = stars[L.i];
      const b = stars[L.j];
      starPos(a, t, _spA);
      starPos(b, t, _spB);

      // Mantén las líneas en la parte alta del cielo (para no ensuciar el ramo)
      if(_spA.y > H*0.62 || _spB.y > H*0.62) continue;

      ctx.globalAlpha = L.a;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(_spA.x, _spA.y);
      ctx.lineTo(_spB.x, _spB.y);
      ctx.stroke();
    }

    ctx.restore();
  }


  function rebuildSkyCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const sky = g.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, 'rgba(12,14,46,1)');
    sky.addColorStop(0.40, 'rgba(7,9,24,1)');
    sky.addColorStop(1, 'rgba(3,3,10,1)');
    g.fillStyle = sky;
    g.fillRect(0,0,W,H);


    // Luna mejorada (halo + sombreado + textura sutil)
    const moonX = W * LIGHT.x;
    const moonY = H * LIGHT.y;
    const moonR = Math.min(W,H) * 0.062;

    // halo principal
    const halo = g.createRadialGradient(moonX, moonY, moonR*0.22, moonX, moonY, moonR*7.0);
    halo.addColorStop(0, 'rgba(255,255,255,0.22)');
    halo.addColorStop(0.18, 'rgba(210,230,255,0.10)');
    halo.addColorStop(0.52, 'rgba(140,190,255,0.045)');
    halo.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = halo;
    g.fillRect(0,0,W,H);

    // halo externo frío (muy sutil)
    const halo2 = g.createRadialGradient(moonX, moonY, moonR*0.8, moonX, moonY, moonR*12.0);
    halo2.addColorStop(0, 'rgba(180,210,255,0.035)');
    halo2.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = halo2;
    g.fillRect(0,0,W,H);

    // dibuja el disco con gradiente (sensación de esfera)
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.92;

    const disc = g.createRadialGradient(moonX - moonR*0.25, moonY - moonR*0.25, moonR*0.12,
                                        moonX, moonY, moonR);
    disc.addColorStop(0, 'rgba(255,255,255,0.95)');
    disc.addColorStop(0.42, 'rgba(238,245,255,0.90)');
    disc.addColorStop(0.78, 'rgba(210,225,245,0.86)');
    disc.addColorStop(1, 'rgba(190,205,230,0.82)');
    g.fillStyle = disc;
    g.beginPath();
    g.arc(moonX, moonY, moonR, 0, TAU);
    g.fill();

    // sombreado suave del borde opuesto (terminador muy leve)
    g.globalCompositeOperation = 'multiply';
    g.globalAlpha = 0.22;
    const shade = g.createLinearGradient(moonX - moonR, moonY, moonX + moonR, moonY);
    shade.addColorStop(0, 'rgba(0,0,0,0.22)');
    shade.addColorStop(0.55, 'rgba(0,0,0,0.00)');
    shade.addColorStop(1, 'rgba(0,0,0,0.14)');
    g.fillStyle = shade;
    g.beginPath();
    g.arc(moonX, moonY, moonR, 0, TAU);
    g.fill();

    // textura/cráteres (determinística por tamaño para que no "cambie" cada resize)
    let ms = (((W*73856093) ^ (H*19349663) ^ 0x9e3779b9) >>> 0) || 1;
    const mrnd = () => (ms = (ms * 1664525 + 1013904223) >>> 0, ms / 4294967296);

    g.save();
    g.beginPath();
    g.arc(moonX, moonY, moonR, 0, TAU);
    g.clip();

    // polvo fino
    g.globalCompositeOperation = 'overlay';
    g.globalAlpha = 0.10;
    for(let i=0;i<80;i++){
      const a = mrnd()*TAU;
      const rr = Math.sqrt(mrnd()) * moonR*0.92;
      const x = moonX + Math.cos(a)*rr;
      const y = moonY + Math.sin(a)*rr;
      g.fillStyle = 'rgba(255,255,255,0.08)';
      g.fillRect(x, y, 1, 1);
    }

    // cráteres con rim + sombra
    const craterN = 14;
    for(let i=0;i<craterN;i++){
      const a = mrnd()*TAU;
      const rr = Math.sqrt(mrnd()) * moonR*0.78;
      const cx = moonX + Math.cos(a)*rr;
      const cy = moonY + Math.sin(a)*rr;
      const cr = moonR*(0.06 + mrnd()*0.16);

      // sombra interna
      g.globalCompositeOperation = 'multiply';
      g.globalAlpha = 0.18;
      const cg = g.createRadialGradient(cx + cr*0.18, cy + cr*0.18, cr*0.15, cx, cy, cr);
      cg.addColorStop(0, 'rgba(0,0,0,0.00)');
      cg.addColorStop(1, 'rgba(0,0,0,0.38)');
      g.fillStyle = cg;
      g.beginPath();
      g.arc(cx, cy, cr, 0, TAU);
      g.fill();

      // rim iluminado
      g.globalCompositeOperation = 'screen';
      g.globalAlpha = 0.14;
      const rg = g.createRadialGradient(cx - cr*0.25, cy - cr*0.25, cr*0.05, cx, cy, cr);
      rg.addColorStop(0, 'rgba(255,255,255,0.22)');
      rg.addColorStop(1, 'rgba(255,255,255,0.00)');
      g.fillStyle = rg;
      g.beginPath();
      g.arc(cx, cy, cr, 0, TAU);
      g.fill();
    }

    g.restore();
    g.restore();

    // bloom suave para integrarla al cielo
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.10;
    const bloom = g.createRadialGradient(moonX, moonY, moonR*0.6, moonX, moonY, moonR*2.8);
    bloom.addColorStop(0, 'rgba(255,255,255,0.22)');
    bloom.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = bloom;
    g.beginPath();
    g.arc(moonX, moonY, moonR*2.8, 0, TAU);
    g.fill();
    g.restore();


    const neb = (x,y,r, a, cr,cg,cb) => {
      const gg = g.createRadialGradient(x,y, 10, x,y, r);
      gg.addColorStop(0, rgba(cr,cg,cb,a));
      gg.addColorStop(0.55, rgba(cr,cg,cb,a*0.26));
      gg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = gg;
      g.fillRect(0,0,W,H);
    };
    neb(W*0.16, H*0.15, Math.max(W,H)*0.66, 0.09, 120,150,255);
    neb(W*0.82, H*0.20, Math.max(W,H)*0.60, 0.08, 160,120,255);
    neb(W*0.55, H*0.10, Math.max(W,H)*0.52, 0.06, 90,170,255);

    g.save();
    g.translate(W*0.56, H*0.34);
    g.rotate(-0.36);
    const mw = Math.max(W,H)*1.25;
    const mh = Math.max(W,H)*0.24;

    const mg = g.createRadialGradient(0,0, mh*0.03, 0,0, mh);
    mg.addColorStop(0, 'rgba(255,255,255,0.095)');
    mg.addColorStop(0.55, 'rgba(190,210,255,0.040)');
    mg.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = mg;
    g.beginPath();
    g.ellipse(0,0, mw*0.56, mh, 0, 0, TAU);
    g.fill();

    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.38;
    const dust = clamp(Math.floor((W*H)/8500), 160, 460);
    const prDust = makePRNG((W*2654435761) ^ (H*2246822519));
    for(let i=0;i<dust;i++){
      const dx = (prDust()-0.5) * mw*0.85;
      const dy = (prDust()-0.5) * mh*0.55;
      const rr = 0.6 + prDust()*1.9;
      g.fillStyle = 'rgba(255,255,255,0.11)';
      g.beginPath();
      g.arc(dx, dy, rr, 0, TAU);
      g.fill();
    }
    g.restore();

    g.save();
    g.globalCompositeOperation = 'screen';
    const pr = makePRNG((W*73856093) ^ (H*19349663) ^ 0xA53);
    const count = clamp(Math.floor((W*H)/2600), 520, 1500);
    for(let i=0;i<count;i++){
      const x = pr()*W;
      const y = Math.pow(pr(), 1.62) * (H*0.74);
      const a = 0.025 + pr()*0.085;
      const r = (pr()<0.90) ? (0.55 + pr()*0.85) : (0.95 + pr()*1.25);
      const warm = pr() < 0.18;
      g.fillStyle = warm ? `rgba(255,245,230,${a})` : `rgba(210,230,255,${a})`;
      g.beginPath();
      g.arc(x, y, r, 0, TAU);
      g.fill();
    }
    g.restore();

    const mx = W*0.80, my = H*0.14;
    const moon = g.createRadialGradient(mx, my, 10, mx, my, Math.max(W,H)*0.55);
    moon.addColorStop(0, 'rgba(245,250,255,0.12)');
    moon.addColorStop(0.35, 'rgba(210,225,255,0.06)');
    moon.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = moon;
    g.fillRect(0,0,W,H);

    const hz = g.createLinearGradient(0, H*0.56, 0, H*0.80);
    hz.addColorStop(0, 'rgba(120,150,255,0)');
    hz.addColorStop(1, 'rgba(90,120,210,0.06)');
    g.fillStyle = hz;
    g.fillRect(0,0,W,H);

    // Glow difuminado detrás del texto
    const sMin = Math.min(W, H);
    const fontSize = clamp(sMin * 0.09, 26, 58);
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.10;
    g.shadowColor = 'rgba(210,230,255,0.45)';
    g.shadowBlur = fontSize * 0.95;
    g.fillStyle = 'rgba(210,230,255,0.10)';
    g.textAlign = 'center';
    g.textBaseline = 'middle';
    g.font = `700 ${Math.round(fontSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    g.fillText(CONFIG.starText, W*0.5, H*0.28);
    g.restore();

    g.save();
    g.globalAlpha = 0.045;
    g.fillStyle = 'rgba(255,255,255,0.06)';
    const n = clamp(Math.floor((W*H)/14000), 220, 520);
    const prG = makePRNG((W*1597334677) ^ (H*3812015801));
    for(let i=0;i<n;i++){
      const x = prG()*W;
      const y = prG()*(H*0.72);
      g.fillRect(x,y,1,1);
    }
    g.restore();

    const vg = g.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.98);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.62)');
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);

    skyCache = off;
  }

  function drawSky(t){
    ctx.clearRect(0,0,W,H);

    if(skyCache){
      ctx.drawImage(skyCache, 0, 0, skyCache.width / DPR, skyCache.height / DPR);
    }else{
      const sky = ctx.createLinearGradient(0, 0, 0, H);
      sky.addColorStop(0, 'rgba(12,14,46,1)');
      sky.addColorStop(0.40, 'rgba(7,9,24,1)');
      sky.addColorStop(1, 'rgba(3,3,10,1)');
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);
    }

    drawStarText(t);

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    drawConstellations(t);

    for(const st of stars){
      const tw = CONFIG.reduceMotion ? 1 : (0.72 + 0.28*Math.sin(t*0.0011*st.s + st.p)) * (0.85 + st.tw*0.30);
      const alpha = st.a * (0.72 + 0.58*tw) * CONFIG.twinkle;

      starPos(st, t, _spA);
      const x = _spA.x;
      const y = _spA.y;

      ctx.globalAlpha = alpha;

      if(st.r < 1.15){
        ctx.shadowBlur = 0;
      }else{
        ctx.shadowColor = 'rgba(255,255,255,0.55)';
        ctx.shadowBlur = 8 + st.r*3.2;
      }

      ctx.fillStyle = st.hue ? `hsla(${st.hue}, 80%, 90%, 1)` : 'rgba(255,255,255,1)';
      ctx.beginPath();
      ctx.arc(x, y, st.r, 0, TAU);
      ctx.fill();

      if(st.flare){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowBlur = 0;

        ctx.globalAlpha = alpha * 0.42 * st.flare;
        const rg = ctx.createRadialGradient(x,y, 0, x,y, 18 + st.r*11);
        rg.addColorStop(0, 'rgba(255,255,255,0.20)');
        rg.addColorStop(0.45, 'rgba(255,255,255,0.07)');
        rg.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(x,y, 18 + st.r*11, 0, TAU);
        ctx.fill();

        ctx.globalAlpha = alpha * 0.28 * st.flare;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        const k = 3.6 + st.r*1.6;
        ctx.beginPath();
        ctx.moveTo(x-k, y); ctx.lineTo(x+k, y);
        ctx.moveTo(x, y-k); ctx.lineTo(x, y+k);
        ctx.stroke();
        ctx.restore();
      }
    }
    ctx.restore();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';

    maybeStartShootingStar(t);
    drawShootingStar(t);
  }

  // ===== Hojas =====
  function drawTulipLeaf(attachX, attachY, angle, scale, side){
    const id = ((attachX * 97) ^ (attachY * 193) ^ (side * 911)) | 0;
    const j = (Math.sin(id) * 0.5 + 0.5);

    const len = (95 + j*10) * scale;
    const baseWid = (7.5 + j*1.2) * scale;

    const baseDir = Math.PI/2 + angle;
    const leafAngle = baseDir + side * (0.16 + j*0.03);

    const p0x = attachX, p0y = attachY;
    const p3x = attachX + Math.cos(leafAngle) * len;
    const p3y = attachY - Math.sin(leafAngle) * len;

    const p1x = attachX + side * baseWid * (0.34 + j*0.08);
    const p1y = attachY - len * (0.35 + j*0.05);

    const p2x = attachX + side * baseWid * (0.14 + j*0.06);
    const p2y = attachY - len * (0.82 + j*0.06);

    const bez = (t, a,b,c,d) => {
      const u = 1 - t;
      return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
    };

    const G0 = {r:28,g:88,b:56};
    const G1 = {r:52,g:140,b:88};
    const G2 = {r:96,g:190,b:130};

    const grad = ctx.createLinearGradient(p0x, p0y, p3x, p3y);
    grad.addColorStop(0, rgba(G0.r,G0.g,G0.b, 0.92));
    grad.addColorStop(0.55, rgba(G1.r,G1.g,G1.b, 0.84));
    grad.addColorStop(1, rgba(G2.r,G2.g,G2.b, 0.70));

    const steps = 14;
    const L = [], R = [], C = [];

    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const x = bez(t, p0x,p1x,p2x,p3x);
      const y = bez(t, p0y,p1y,p2y,p3y);
      C.push({x,y});

      const t2 = Math.min(1, t + 0.015);
      const x2 = bez(t2, p0x,p1x,p2x,p3x);
      const y2 = bez(t2, p0y,p1y,p2y,p3y);
      const dx = x2-x, dy=y2-y;
      const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
      const nx = -dy*inv, ny = dx*inv;

      const taper = Math.pow(1 - t, 1.55);
      const w = baseWid * (0.04 + 0.50*taper);

      L.push({x: x + nx*w, y: y + ny*w});
      R.push({x: x - nx*w, y: y - ny*w});
    }

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.14)';
    ctx.shadowBlur = 4 * scale;

    ctx.fillStyle = grad;
    ctx.strokeStyle = 'rgba(255,255,255,0.012)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(L[0].x, L[0].y);
    for(const p of L) ctx.lineTo(p.x, p.y);
    for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i].x, R[i].y);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.stroke();

    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = Math.max(1, 1.15*scale);
    ctx.beginPath();
    for(let i=0;i<C.length;i++){
      const p = C[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.10;
    const edge = side < 0 ? L : R;
    ctx.strokeStyle = 'rgba(180,255,210,0.14)';
    ctx.lineWidth = Math.max(1, 0.9*scale);
    ctx.beginPath();
    for(let i=0;i<edge.length;i++){
      const p = edge[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawLeafSprig(x, y, angle, scale, side){
    const baseDir = Math.PI/2 + angle;
    const a = baseDir + side*(0.30);

    const len = 72 * scale;
    const spread = 14 * scale;

    const tipX = x + Math.cos(a) * len;
    const tipY = y - Math.sin(a) * len;

    const cX = x + side * spread;
    const cY = y - len * 0.55;

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const lg = ctx.createLinearGradient(x, y, tipX, tipY);
    lg.addColorStop(0, 'rgba(8,20,12,0.10)');
    lg.addColorStop(0.55, 'rgba(70,200,130,0.08)');
    lg.addColorStop(1, 'rgba(90,240,160,0.12)');

    ctx.strokeStyle = lg;
    ctx.lineWidth = Math.max(1, 0.9 * scale);

    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(cX, cY, tipX, tipY);
    ctx.stroke();

    ctx.globalAlpha = 0.45;
    ctx.beginPath();
    ctx.moveTo(x + side*2.0*scale, y + 1.3*scale);
    ctx.quadraticCurveTo(cX - side*spread*0.55, cY + len*0.12, tipX - side*3.0*scale, tipY + 1.2*scale);
    ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(120,255,180,0.08)';
    ctx.lineWidth = Math.max(1, 0.8 * scale);
    ctx.beginPath();
    ctx.moveTo(x + side*0.8*scale, y);
    ctx.quadraticCurveTo((x+tipX)*0.5, (y+tipY)*0.5, tipX, tipY);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Pétalos =====
  function getBloomSprite(w, h, col, seed, open){
    const key = `${Math.round(w)}x${Math.round(h)}_${col.r},${col.g},${col.b}_${seed}_${Math.round((open||1)*100)}`;
    const cached = bloomCache.get(key);
    if(cached) return cached;

    const ss = 2;
    const cw = Math.ceil(w * 2.8);
    const ch = Math.ceil(h * 2.4 + w * 0.35);

    const ax = Math.ceil(cw * 0.50);
    const ay = Math.ceil(h  * 1.55);

    const off = document.createElement('canvas');
    off.width  = cw * ss;
    off.height = ch * ss;

    const c2 = off.getContext('2d', { alpha:true });
    c2.setTransform(ss,0,0,ss,0,0);
    c2.translate(ax, ay);

    renderTulipBloomSprite(c2, w, h, col, seed, open);

    const obj = { canvas: off, ox: ax, oy: ay, ss };
    bloomCache.set(key, obj);
    return obj;
  }

  function renderTulipBloomSprite(c2, w, h, col, seed, open){
    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const mix = (a,b,t)=>({
      r: Math.round(lerp(a.r,b.r,t)),
      g: Math.round(lerp(a.g,b.g,t)),
      b: Math.round(lerp(a.b,b.b,t))
    });

    const dark  = mix(col, {r:18,g:6,b:28}, 0.46);
    const deep  = mix(col, {r: 6,g:2,b:10}, 0.72);
    const lite  = mix(col, {r:255,g:255,b:255}, 0.36);
    const warm  = mix(col, {r:245,g:235,b:255}, 0.20);

    const op = clamp(((open||1) - 0.88) / 0.22, 0, 1);
    const spread = lerp(0.10, 0.22, op);

    c2.save();
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.16;
    const gg = c2.createRadialGradient(0, -h*0.55, 10, 0, -h*0.40, w*1.55);
    gg.addColorStop(0, rgba(col.r,col.g,col.b,0.32));
    gg.addColorStop(1, rgba(col.r,col.g,col.b,0));
    c2.fillStyle = gg;
    c2.beginPath();
    c2.ellipse(0, -h*0.40, w*1.20, h*1.10, 0, 0, TAU);
    c2.fill();
    c2.restore();
    const petalPath = (petW, petH, notch, wave, lip) => {
      const cs = clamp(CONFIG.crownStrength, 0, 1);

      // Corona ultra suave: elimina picos visibles sin perder silueta
      const topBaseY = -petH * (0.995 + lip*0.85);
      const leftTopX  = -petW * (0.10 + wave*0.02);
      const rightTopX =  petW * (0.10 + wave*0.02);
      const leftTopY  = -petH * (0.965 - notch);
      const rightTopY = leftTopY;

      // levantamiento mínimo al centro (muy sutil)
      const capLift = petH * (0.006 + 0.010*cs);

      c2.beginPath();
      c2.moveTo(-petW*0.44, 0);

      c2.bezierCurveTo(
        -petW*0.66, -petH*0.26,
        -petW*0.48, -petH*0.84,
        leftTopX,   leftTopY
      );

      // Cap superior continuo (sin "puntos")
      c2.bezierCurveTo(
        leftTopX*0.35,  topBaseY - capLift,
        rightTopX*0.35, topBaseY - capLift,
        rightTopX, rightTopY
      );

      c2.bezierCurveTo(
        petW*0.48, -petH*0.84,
        petW*0.66, -petH*0.26,
        petW*0.44, 0
      );

      c2.quadraticCurveTo(0, petH*0.14, -petW*0.44, 0);
      c2.closePath();
    };

    const fillPetal = (front, idx) => {
      const v1 = (rnd()-0.5);
      const v2 = (rnd()-0.5);

      const petW = w * (front ? 0.62 : 0.56) * (1 + v1*0.05);
      const petH = h * (front ? 1.18 : 1.10) * (0.94 + op*0.10) * (1 + v2*0.035);
      const notch = 0.008 + rnd()*0.012;
      const wave  = (rnd()-0.5) * 0.22;

      const vg = c2.createLinearGradient(0, -petH, 0, petH*0.24);
      vg.addColorStop(0, rgba(lite.r,lite.g,lite.b, front ? 0.44 : 0.30));
      vg.addColorStop(0.22, rgba(warm.r,warm.g,warm.b, front ? 0.22 : 0.16));
      vg.addColorStop(0.38, rgba(col.r,col.g,col.b, front ? 0.98 : 0.88));
      vg.addColorStop(1, rgba(dark.r,dark.g,dark.b, 0.98));

      const hg = c2.createLinearGradient(-petW, -petH*0.35, petW, -petH*0.15);
      hg.addColorStop(0, rgba(0,0,0,0.18));
      hg.addColorStop(0.42, rgba(0,0,0,0));
      hg.addColorStop(1, rgba(0,0,0,0.22));

      const rim = c2.createRadialGradient(0, -petH*0.96, petW*0.02, 0, -petH*0.86, petW*0.95);
      rim.addColorStop(0, rgba(255,255,255, front ? 0.14 : 0.10));
      rim.addColorStop(0.55, rgba(255,255,255,0.04));
      rim.addColorStop(1, rgba(255,255,255,0));

      c2.save();
      c2.shadowColor = rgba(col.r,col.g,col.b, 0.10);
      c2.shadowBlur = Math.max(10, w*0.30);
      const lip = 0.016 + op*0.030;
      petalPath(petW, petH, notch, wave, lip);
      c2.fillStyle = vg;
      c2.fill();

      c2.shadowBlur = 0;
      c2.globalAlpha = front ? 0.06 : 0.045;
      c2.strokeStyle = rgba(255,255,255,0.22);
      c2.lineWidth = 1;
      c2.stroke();
      c2.globalAlpha = 1;

      c2.save();
      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = front ? 0.20 : 0.16;
      c2.fillStyle = hg;
      c2.fill();
      c2.restore();

      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = front ? 0.22 : 0.16;
      c2.fillStyle = rim;
      c2.fill();
      c2.restore();

      c2.save();
      c2.clip();


      // subsurface scattering (falso): glow cálido en el borde superior
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = front ? 0.20 : 0.14;
      const sss = c2.createRadialGradient(0, -petH*0.98, petW*0.06, 0, -petH*0.98, petW*0.92);
      sss.addColorStop(0, rgba(255,240,250,0.55));
      sss.addColorStop(0.35, rgba(col.r,col.g,col.b,0.20));
      sss.addColorStop(1, rgba(col.r,col.g,col.b,0));
      c2.fillStyle = sss;
      c2.beginPath();
      c2.ellipse(0, -petH*0.92, petW*0.74, petH*0.34, 0, 0, TAU);
      c2.fill();
      c2.restore();

      
      // grano muy sutil para que el pétalo no se vea plano
      c2.globalAlpha = front ? 0.030 : 0.024;
      c2.fillStyle = rgba(255,255,255,0.10);
      for(let k=0;k<(front?85:70);k++){
        const gx = (Math.random()*2 - 1) * petW * 0.55;
        const gy = -petH * (0.10 + Math.random()*0.85);
        const s = 0.6 + Math.random()*0.9;
        c2.fillRect(gx, gy, s, s);
      }

      c2.globalAlpha = front ? 0.10 : 0.075;
      c2.strokeStyle = rgba(255,255,255,0.14);
      c2.lineWidth = 1;
      const veins = 3 + (idx % 2);
      for(let i=-veins;i<=veins;i++){
        c2.beginPath();
        c2.moveTo(i*petW*0.10, -petH*0.96);
        c2.quadraticCurveTo(i*petW*0.08, -petH*0.55, i*petW*0.03, -petH*0.10);
        c2.stroke();
      }

      c2.globalAlpha = front ? 0.05 : 0.04;
      for(let k=0;k<12;k++){
        const px = (rnd()-0.5) * petW * 0.82;
        const py = -petH*(0.18 + rnd()*0.70);
        const pr = 0.6 + rnd()*1.0;
        c2.fillStyle = rgba(255,255,255, 0.10);
        c2.beginPath();
        c2.arc(px, py, pr, 0, TAU);
        c2.fill();
      }

      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = front ? 0.16 : 0.12;
      const fg = c2.createRadialGradient(0, -petH*0.42, petW*0.08, 0, -petH*0.42, petW*0.70);
      fg.addColorStop(0, rgba(deep.r,deep.g,deep.b,0.30));
      fg.addColorStop(1, rgba(0,0,0,0));
      c2.fillStyle = fg;
      c2.beginPath();
      c2.ellipse(0, -petH*0.42, petW*0.50, petH*0.34, 0, 0, TAU);
      c2.fill();

      c2.restore();
      c2.restore();
    };

    for(let i=0;i<3;i++){
      c2.save();
      const a = (-spread + i*spread) + (rnd()-0.5)*0.018;
      c2.rotate(a);
      c2.translate(0, h*0.06);
      c2.scale(1, 1.02 - op*0.05);
      fillPetal(false, i);
      c2.restore();
    }

    c2.save();
    c2.globalCompositeOperation = 'multiply';
    const ig = c2.createRadialGradient(0, -h*0.30, w*0.06, 0, -h*0.22, w*1.05);
    ig.addColorStop(0, rgba(0,0,0,0));
    ig.addColorStop(1, rgba(0,0,0,0.36));
    c2.fillStyle = ig;
    c2.beginPath();
    c2.ellipse(0, -h*0.30, w*0.55, h*0.60, 0, 0, TAU);
    c2.fill();
    c2.restore();

    for(let i=0;i<3;i++){
      c2.save();
      const a = (-(spread+0.08) + i*(spread+0.08)) + (rnd()-0.5)*0.018;
      c2.rotate(a);
      c2.translate((i-1)*w*0.018*op, -h*0.01);
      c2.scale(1, 1.04);
      fillPetal(true, 3+i);
      c2.restore();
    }

    c2.save();
    c2.globalAlpha = 0.95;
    c2.fillStyle = rgba(50,170,105,0.92);
    c2.strokeStyle = rgba(255,255,255,0.06);
    c2.lineWidth = 1;
    for(let i=0;i<3;i++){
      const a = (-0.56 + i*0.56);
      c2.save();
      c2.rotate(a);
      c2.beginPath();
      c2.moveTo(-w*0.11, h*0.02);
      c2.quadraticCurveTo(0, -h*0.12, w*0.11, h*0.02);
      c2.quadraticCurveTo(0, h*0.16, -w*0.11, h*0.02);
      c2.closePath();
      c2.fill();
      c2.stroke();
      c2.restore();
    }
    c2.restore();

    c2.fillStyle = rgba(40,140,85,0.52);
    c2.beginPath();
    c2.ellipse(0, 0, w*0.18, h*0.10, 0, 0, TAU);
    c2.fill();

    c2.save();
    c2.globalAlpha = 0.28;
    c2.fillStyle = rgba(0,0,0,0.18);
    c2.beginPath();
    c2.ellipse(0, h*0.02, w*0.26, h*0.10, 0, 0, TAU);
    c2.fill();
    c2.restore();
  }

  function drawTulipBloom(w, h, col, seed, open){
    const spr = getBloomSprite(w, h, col, seed, open);
    ctx.drawImage(
      spr.canvas,
      -spr.ox,
      -spr.oy,
      spr.canvas.width / spr.ss,
      spr.canvas.height / spr.ss
    );
  }

  // highlight suave consistente con la “luz de luna” (sin afectar el sprite cacheado)
  function drawBloomRim(w, h, col, angle){
    // Luz global (en canvas). La convertimos a coordenadas locales de la flor.
    const ca = Math.cos(-angle), sa = Math.sin(-angle);
    const lx = LIGHT.x*ca - LIGHT.y*sa;
    const ly = LIGHT.x*sa + LIGHT.y*ca;

    const hx = lx * w * 0.22;
    const hy = ly * (-h) * 0.38;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.14;

    // clip aproximado del bloom
    ctx.beginPath();
    ctx.ellipse(0, -h*0.45, w*0.62, h*0.80, 0, 0, TAU);
    ctx.clip();

    const g = ctx.createRadialGradient(hx, hy - h*0.12, 0, hx, hy - h*0.12, w*1.15);
    g.addColorStop(0, 'rgba(255,255,255,0.22)');
    g.addColorStop(0.55, `rgba(${col.r},${col.g},${col.b},0.08)`);
    g.addColorStop(1, 'rgba(255,255,255,0)');

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(0, -h*0.45, w*0.74, h*0.92, 0, 0, TAU);
    ctx.fill();

    // brillo finito
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = Math.max(1, w*0.03);
    ctx.beginPath();
    ctx.moveTo(-w*0.10, -h*0.95);
    ctx.quadraticCurveTo(hx*0.25, -h*0.62, w*0.14, -h*0.10);
    ctx.stroke();

    ctx.restore();
  }


  
  function drawBouquetWrap(cx, cy, s){
    // Un envoltorio simple (hojas + listón) para que sí se lea como "ramo"
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(s, s);

    const leaf = (rot, flip) => {
      ctx.save();
      ctx.rotate(rot);
      ctx.scale(flip, 1);

      const g = ctx.createLinearGradient(-40, 10, 40, -120);
      g.addColorStop(0, 'rgba(8,26,16,0.82)');
      g.addColorStop(0.55, 'rgba(38,130,78,0.66)');
      g.addColorStop(1, 'rgba(190,255,220,0.18)');

      ctx.fillStyle = g;
      ctx.shadowColor = 'rgba(0,0,0,0.28)';
      ctx.shadowBlur = 14;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-48, -30, -64, -92, -14, -138);
      ctx.bezierCurveTo(10, -156, 64, -116, 48, -56);
      ctx.bezierCurveTo(38, -18, 14, -6, 0, 0);
      ctx.closePath();
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-6, -6);
      ctx.quadraticCurveTo(10, -58, -2, -126);
      ctx.stroke();

      ctx.restore();
    };

    // hojas de envoltura
    leaf(-0.26, 1);
    leaf( 0.30, -1);
    leaf( 0.02, 1);

    // Listón oscuro con brillo
    ctx.save();
    ctx.translate(0, 10);

    const band = ctx.createLinearGradient(-80, 0, 80, 0);
    band.addColorStop(0, 'rgba(30,10,18,0.55)');
    band.addColorStop(0.5, 'rgba(80,22,38,0.48)');
    band.addColorStop(1, 'rgba(18,6,12,0.55)');

    ctx.fillStyle = band;
    ctx.shadowColor = 'rgba(0,0,0,0.40)';
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(-88, -10);
    ctx.quadraticCurveTo(0, 18, 88, -10);
    ctx.quadraticCurveTo(0, 34, -88, -10);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.16;
    ctx.strokeStyle = 'rgba(255,235,245,0.20)';
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.moveTo(-80, -8);
    ctx.quadraticCurveTo(0, 10, 80, -8);
    ctx.stroke();

    // nudo
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(50,14,24,0.62)';
    ctx.beginPath();
    ctx.ellipse(0, 2, 18, 12, 0, 0, TAU);
    ctx.fill();

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    ctx.ellipse(-5, -1, 8, 4, -0.2, 0, TAU);
    ctx.fill();

    ctx.restore();
    ctx.restore();
  }

// ===== Bouquet =====
  const DESCS = [
    // 10 tulipanes: más compacto y con capas para que se vea como un ramo
    {dx:-0.48, hf:0.70, bs:0.82},
    {dx: 0.48, hf:0.72, bs:0.84},

    {dx:-0.30, hf:0.84, bs:0.90},
    {dx: 0.30, hf:0.86, bs:0.92},

    {dx:-0.14, hf:0.98, bs:1.00},
    {dx: 0.14, hf:0.98, bs:1.00},

    {dx: 0.00, hf:1.06, bs:1.02}, // un poquito más alto al fondo

    // capa frontal
    {dx:-0.08, hf:0.80, bs:0.96},
    {dx: 0.08, hf:0.80, bs:0.96},
    {dx: 0.00, hf:0.86, bs:0.98},
  ];
  const COLORS = [
    // Violetas (variación sutil para que no se vea plano)
    { r: 124, g:  58, b: 237 }, // violet intenso
    { r: 147, g:  97, b: 255 }, // violeta brillante
    { r: 104, g:  48, b: 200 }, // deep violet
    { r: 173, g: 132, b: 255 }, // lavender violeta
    { r:  90, g:  42, b: 170 }, // plum violeta
  ];

  let bouquet = [];

  function seedBouquet(){
    const cx = W*0.5;
    const baseY = H*0.94; // fallback; se ajusta por flor según la pendiente
    const scaleBase = lerp(0.74, 1.12, clamp(Math.min(W, H)/820, 0, 1));
    const spread = Math.min(W*0.44, 220 + W*0.05);

    bouquet = DESCS.map((p,i)=>{
      const scale = scaleBase * p.bs;
      const bw = (40 + ((i%3)-1)*2) * scale;
      const bh = (86 + ((i%4)-2)*4) * scale;
      const center = (DESCS.length - 1) / 2;
      const twist = (i - center) * 0.016;

      const x = cx + p.dx*spread;
      const xn = x / W;
      const hill = H * hillY(xn);
      const baseYf = hill + (H - hill) * 0.86; // nace en la ladera

      return {
        i,
        x,
        baseY: baseYf,
        scale,
        height: (235 * scaleBase) * p.hf,
        phase: i*0.85,
        bw, bh,
        twist,
        col: COLORS[i % COLORS.length],
        seed: 1337 + i*101,
        open: 0.92 + (i % 4) * 0.03
      };
    });
  }

  function drawBouquet(t){
    drawMeadow(t);

    const hx = W*0.5, hy = (meadowTopY || H*0.78) + H*0.10;
    const hg = ctx.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
    hg.addColorStop(0, 'rgba(0,0,0,0)');
    hg.addColorStop(1, 'rgba(0,0,0,0.30)');
    ctx.fillStyle = hg;
    ctx.fillRect(0,0,W,H);

    const bush = ctx.createRadialGradient(W*0.5, H*0.955, 10, W*0.5, H*0.955, Math.min(W,H)*0.52);
    bush.addColorStop(0, 'rgba(65,150,95,0.16)');
    bush.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = bush;
    ctx.fillRect(0,0,W,H);

    const STEM = {r:55,g:155,b:92};
    const STEM2= {r:35,g:120,b:72};

    const gw = windField(t) * CONFIG.sway;

    const order = bouquet.slice().sort((a,b)=> (b.height - a.height) || (a.x - b.x));

    for(const f of order){
      const sway = CONFIG.reduceMotion ? 0 : (gw*0.22 + Math.sin(t*0.001 + f.phase) * 0.08 * CONFIG.sway);
      const angle = sway + (f.x - W*0.5) * 0.0006;

      const baseX = f.x;
      const baseY = f.baseY;
      const topY  = baseY - f.height;

      const bloomX = baseX + Math.sin(angle) * 12 * f.scale;
      const bloomY = topY + Math.cos(angle) * 5 * f.scale;

      const cp1x = baseX + Math.sin(f.phase)*10*f.scale;
      const cp1y = baseY - f.height*0.40;
      const cp2x = baseX + Math.cos(f.phase*1.7)*16*f.scale;
      const cp2y = baseY - f.height*0.76;

      const leafMid1 = baseY - f.height*0.52;
      const leafMid2 = baseY - f.height*0.60;

      ctx.save();
      drawTulipLeaf(baseX, leafMid1, angle, f.scale*0.56, -1);
      drawTulipLeaf(baseX, leafMid2, angle, f.scale*0.50,  1);
      drawLeafSprig(baseX, baseY - f.height*0.56, angle, f.scale*0.52, -1);
      drawLeafSprig(baseX, baseY - f.height*0.64, angle, f.scale*0.46,  1);
      ctx.restore();

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const stemW = 7.0 * f.scale;

      const sg = ctx.createLinearGradient(baseX, baseY, bloomX, bloomY);
      sg.addColorStop(0.00, rgba(STEM2.r, STEM2.g, STEM2.b, 0.10));
      sg.addColorStop(0.10, rgba(STEM2.r, STEM2.g, STEM2.b, 0.45));
      sg.addColorStop(0.32, rgba(STEM.r,  STEM.g,  STEM.b,  0.95));
      sg.addColorStop(1.00, rgba(STEM.r,  STEM.g,  STEM.b,  0.95));

      ctx.strokeStyle = sg;
      ctx.lineWidth = stemW;

      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, bloomX, bloomY);
      ctx.stroke();


      // volumen del tallo: sombra (lado opuesto a la luna) + brillo (lado de la luna)
      const offX = LIGHT_DIR.x * stemW * 0.22;
      const offY = LIGHT_DIR.y * stemW * 0.22;

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = stemW * 0.55;
      ctx.beginPath();
      ctx.moveTo(baseX - offX, baseY - offY);
      ctx.bezierCurveTo(cp1x - offX, cp1y - offY, cp2x - offX, cp2y - offY, bloomX - offX, bloomY - offY);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.16;
      ctx.strokeStyle = 'rgba(210,255,230,0.55)';
      ctx.lineWidth = Math.max(1, stemW * 0.28);
      ctx.beginPath();
      ctx.moveTo(baseX + offX*0.75, baseY + offY*0.75);
      ctx.bezierCurveTo(cp1x + offX*0.75, cp1y + offY*0.75, cp2x + offX*0.75, cp2y + offY*0.75, bloomX + offX*0.75, bloomY + offY*0.75);
      ctx.stroke();
      ctx.restore();

      const fadeH = 92 * f.scale;
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      const fg = ctx.createLinearGradient(0, baseY + 2, 0, baseY - fadeH);
      fg.addColorStop(0.00, 'rgba(0,0,0,0.90)');
      fg.addColorStop(0.55, 'rgba(0,0,0,0.22)');
      fg.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      ctx.strokeStyle = fg;
      ctx.lineWidth = stemW + 5.0 * f.scale;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, bloomX, bloomY);
      ctx.stroke();
      ctx.restore();

      ctx.restore();

      // sombra de contacto bajo la flor (le da "peso" y profundidad)
      ctx.save();
      ctx.globalAlpha = 0.11;
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.beginPath();
      ctx.ellipse(bloomX, bloomY + 6*f.scale, 10*f.scale, 4.2*f.scale, angle, 0, TAU);
      ctx.fill();
      ctx.restore();


      f.bloomX = bloomX;
      f.bloomY = bloomY;
      f.angle = angle + f.twist;
    }

    
    // Envoltura + bruma para que el ramo no flote como sticker
    const wrapS = lerp(0.82, 1.10, clamp(Math.min(W,H)/820, 0, 1));
    drawBouquetWrap(W*0.5, H*0.935, wrapS);

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const fogTop = H*0.72;
    const fog = ctx.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(120,150,220,0)');
    fog.addColorStop(0.55, 'rgba(120,150,220,0.06)');
    fog.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = fog;
    ctx.fillRect(0, fogTop, W, H - fogTop);
    ctx.restore();

    const bloomOrder = order.slice().sort((a,b)=>a.bloomY - b.bloomY);

for(const f of bloomOrder){
      ctx.save();
      ctx.translate(f.bloomX, f.bloomY);

      // Depth of field barato pero efectivo: las flores del fondo se suavizan un poco
      const ny = f.bloomY / H;
      const depth = clamp((ny - 0.34) / 0.34, 0, 1); // 0=lejos, 1=cerca
      const blur = (1 - depth) * (1 - depth) * 1.6;
      ctx.globalAlpha *= lerp(0.86, 1.0, depth);
      if(HAS_FILTER && blur > 0.02) ctx.filter = `blur(${blur.toFixed(2)}px)`;

      ctx.rotate(f.angle);
      ctx.shadowColor = `rgba(${f.col.r},${f.col.g},${f.col.b},0.16)`;
      ctx.shadowBlur = 10 + 12*f.scale;
      drawTulipBloom(f.bw, f.bh, f.col, f.seed, f.open);
      drawBloomRim(f.bw, f.bh, f.col, f.angle);
      if(HAS_FILTER) ctx.filter = 'none';
      ctx.restore();
    }

    const knotX = W*0.5, knotY = H*0.935;
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath();
    ctx.ellipse(knotX, knotY, Math.min(110, W*0.20), 26, 0, 0, TAU);
    ctx.fill();
  }

  function addSparkle(x, y, t){
    tapSparkles.push({ x, y, t0: t, seed: Math.random()*9999 });
    if(tapSparkles.length > 28) tapSparkles.shift();
  }

  function drawTapSparkles(t){
    if(!tapSparkles.length) return;

    for(let i=tapSparkles.length-1;i>=0;i--){
      const s = tapSparkles[i];
      const age = (t - s.t0) / 1000;
      if(age > 0.95){ tapSparkles.splice(i,1); continue; }

      const k = 1 - age/0.95;
      const r = (14 + age*56);
      const pulse = 0.6 + 0.4*Math.sin((t*0.01) + s.seed);

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.46 * k;

      const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, r);
      g.addColorStop(0, `rgba(255,255,255,${0.32*k})`);
      g.addColorStop(0.28, `rgba(200,220,255,${0.20*k})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;

      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, TAU);
      ctx.fill();

      ctx.globalAlpha = 0.18 * k * pulse;
      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.moveTo(s.x - r*0.55, s.y);
      ctx.lineTo(s.x + r*0.55, s.y);
      ctx.moveTo(s.x, s.y - r*0.55);
      ctx.lineTo(s.x, s.y + r*0.55);
      ctx.stroke();

      ctx.restore();
    }
  }


  function resize(){
    DPR = Math.min(1.8, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    bloomCache.clear();

    seedStars();
    buildStarText();
    rebuildSkyCache();

    seedBouquet();
    seedMeadow();
    
    rebuildMeadowCache();

    for(const f of bouquet){
      getBloomSprite(f.bw, f.bh, f.col, f.seed, f.open);
    }

    selfTest();
  }
  window.addEventListener('resize', resize, {passive:true});

  canvas.addEventListener('pointerdown', (e) => {
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left);
    const y = (e.clientY - r.top);
    addSparkle(x, y, performance.now());

    // si le picas cerca del cielo, regalamos una estrella fugaz
    if(y < H*0.55 && !shooting.active) maybeStartShootingStar(performance.now());
  }, {passive:true});



  function selfTest(){
    console.assert(!!canvas && !!ctx, 'Canvas/ctx no disponibles');
    console.assert(Number.isFinite(W) && W>0 && Number.isFinite(H) && H>0, 'Canvas size inválido');
    console.assert(Array.isArray(stars) && stars.length>0, 'Stars no inicializadas');
    console.assert(Array.isArray(starLinks), 'starLinks no existe');
    console.assert(stars.length < 40 || starLinks.length > 0, 'Constelaciones no generadas');
    console.assert(Array.isArray(tapSparkles), 'tapSparkles no existe');
    console.assert(Array.isArray(textStars) && textStars.length>200, 'Texto en estrellas no generado');
    console.assert(!!skyCache && skyCache.width>0, 'Sky cache no generado');
    console.assert(!!meadowCache && meadowCache.width>0, 'Meadow cache no generado');
    console.assert(Array.isArray(bouquet) && bouquet.length===DESCS.length, 'Bouquet no se generó correctamente');
    console.assert(CONFIG.crownStrength >= 0 && CONFIG.crownStrength <= 1, 'crownStrength fuera de rango');

    // Smoke test de dibujo: esto también calcula bloomX/bloomY
    try{ drawBouquet(0); }catch(e){ console.error('drawBouquet fallo', e); }
    console.assert(bouquet.every(f=>Number.isFinite(f.bloomX) && Number.isFinite(f.bloomY)), 'bloomX/bloomY no calculados');

    const spr = getBloomSprite(60, 100, {r:235,g:55,b:70}, 42, 0.95);
    console.assert(spr && spr.canvas && spr.ss === 2 && spr.canvas.width>0, 'Sprite inválido');
  }

  seedStars();
  resize();

  

  // color grading / atmósfera final (vignette + glow lunar + bruma suave)
  function drawFinalGrade(t){
    ctx.save();

    // viñeta
    const vg = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.95);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.36)');
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);

    // gradiente frío general
    const cg = ctx.createLinearGradient(0,0,0,H);
    cg.addColorStop(0, 'rgba(120,140,255,0.06)');
    cg.addColorStop(0.55, 'rgba(0,0,0,0)');
    cg.addColorStop(1, 'rgba(0,0,0,0.12)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = cg;
    ctx.fillRect(0,0,W,H);

    // glow lunar extra (por encima de TODO)
    const mx = W * LIGHT.x;
    const my = H * LIGHT.y;
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.10;
    const mg = ctx.createRadialGradient(mx, my, 10, mx, my, Math.max(W,H)*0.35);
    mg.addColorStop(0, 'rgba(255,255,255,0.18)');
    mg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = mg;
    ctx.fillRect(0,0,W,H);

    // bruma de “horizonte” para profundidad
    ctx.globalAlpha = 0.10;
    const hm = ctx.createLinearGradient(0, meadowTopY - 30, 0, meadowTopY + Math.min(H*0.40, 380));
    hm.addColorStop(0, 'rgba(210,220,255,0.16)');
    hm.addColorStop(0.55, 'rgba(120,160,190,0.05)');
    hm.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = hm;
    ctx.fillRect(0, meadowTopY - 60, W, Math.min(H*0.50, 520));

    ctx.restore();
  }
function frame(t){
    if(window.__hideErr) window.__hideErr();
    requestAnimationFrame(frame);
    drawSky(t);
    drawBouquet(t);
    drawFinalGrade(t);
    drawTapSparkles(t);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
    console.assert(typeof drawBloomRim === 'function', 'drawBloomRim no existe');
    console.assert(typeof drawFinalGrade === 'function', 'drawFinalGrade no existe');
    console.assert(meadow && Array.isArray(meadow.flowers) && meadow.flowers.length>0, 'Meadow flowers no generadas');

