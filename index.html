<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ramo de tulipanes (noche)</title>
  <style>
    :root{
      --bg1:#070814;
      --bg2:#0b1030;
      --bg3:#151a40;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(900px 650px at 50% 10%, var(--bg3), var(--bg2), var(--bg1));
      touch-action: manipulation;
    }
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  let W=0, H=0, DPR=1;

  const TAU = Math.PI*2;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rgba  = (r,g,b,a)=>`rgba(${r},${g},${b},${a})`;

  const CONFIG = {
    tulips: 7,
    stars: 90,
    twinkle: 0.7,
    sway: 0.28,
    reduceMotion: false
  };

  // ===== Stars =====
  const stars = [];
  function seedStars(){
    stars.length = 0;
    for(let i=0;i<CONFIG.stars;i++){
      stars.push({
        x: Math.random(),
        y: Math.random(),
        r: (0.9 + Math.random()*1.6),
        a: (0.10 + Math.random()*0.26),
        p: Math.random()*TAU,
        s: (0.25 + Math.random()*0.8)
      });
    }
  }

  // ===== Césped =====
  const grass = [];
  function seedGrass(){
    grass.length = 0;
    // densidad moderada: se ve bien en móvil sin pesar
    const count = Math.min(200, Math.floor(W * 0.34));
    for(let i=0;i<count;i++){
      grass.push({
        x: Math.random() * W,
        y: H * (0.84 + Math.random()*0.16),
        h: 18 + Math.random()*44,
        w: 0.8 + Math.random()*1.4,
        p: Math.random()*TAU,
        s: 0.6 + Math.random()*1.2,
        a: 0.10 + Math.random()*0.22
      });
    }
  }

  function drawGrass(t){
    const groundH = H * 0.22;
    const gy = H - groundH;

    // base del suelo
    const gg = ctx.createLinearGradient(0, gy, 0, H);
    gg.addColorStop(0, 'rgba(10,18,12,0.10)');
    gg.addColorStop(0.35, 'rgba(18,40,26,0.28)');
    gg.addColorStop(1, 'rgba(0,0,0,0.58)');
    ctx.fillStyle = gg;
    ctx.fillRect(0, gy, W, groundH);

    // briznas
    ctx.save();
    for(const b of grass){
      const sway = CONFIG.reduceMotion ? 0 : Math.sin(t*0.001*b.s + b.p) * 0.35;
      const x0 = b.x;
      const y0 = b.y;
      const x1 = x0 + sway * 8;
      const y1 = y0 - b.h;
      const cx = (x0 + x1)*0.5 + sway * 6;
      const cy = y0 - b.h*0.55;

      const blade = ctx.createLinearGradient(x0, y0, x1, y1);
      blade.addColorStop(0, `rgba(40,120,70,${b.a})`);
      blade.addColorStop(1, `rgba(140,220,160,${b.a*0.55})`);

      ctx.strokeStyle = blade;
      ctx.lineWidth = b.w;
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();
    }
    ctx.restore();

    // niebla baja para suavizar y evitar bordes duros
    const fg = ctx.createLinearGradient(0, H*0.78, 0, H);
    fg.addColorStop(0, 'rgba(0,0,0,0)');
    fg.addColorStop(1, 'rgba(0,0,0,0.28)');
    ctx.fillStyle = fg;
    ctx.fillRect(0, H*0.78, W, H*0.22);
  }

  function resize(){
    DPR = Math.min(1.8, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    seedBouquet();
    seedGrass();

    // mini checks (no interrumpen)
    console.assert(W>0 && H>0, 'Canvas size inválido');
    console.assert(bouquet.length === DESCS.length, 'Bouquet no se generó correctamente');
    console.assert(stars.length > 0, 'Stars no inicializadas');
    console.assert(grass.length > 0, 'Grass no inicializado');
  }
  window.addEventListener('resize', resize);

  // ===== Cielo =====
  function drawSky(t){
    ctx.clearRect(0,0,W,H);

    const sky = ctx.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, 'rgba(10,12,38,1)');
    sky.addColorStop(0.45, 'rgba(6,8,20,1)');
    sky.addColorStop(1, 'rgba(3,3,10,1)');
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,W,H);

    const neb = (x,y,r, a) => {
      const g = ctx.createRadialGradient(x,y, 10, x,y, r);
      g.addColorStop(0, `rgba(120,140,255,${a})`);
      g.addColorStop(0.55, `rgba(120,140,255,${a*0.28})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
    };
    neb(W*0.20, H*0.18, Math.max(W,H)*0.55, 0.07);
    neb(W*0.78, H*0.22, Math.max(W,H)*0.52, 0.06);

    // vía láctea
    ctx.save();
    ctx.translate(W*0.55, H*0.35);
    ctx.rotate(-0.35);
    const mw = Math.max(W,H)*1.2;
    const mh = Math.max(W,H)*0.22;
    const mg = ctx.createRadialGradient(0,0, mh*0.05, 0,0, mh);
    mg.addColorStop(0, 'rgba(255,255,255,0.07)');
    mg.addColorStop(0.55, 'rgba(190,210,255,0.028)');
    mg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = mg;
    ctx.beginPath();
    ctx.ellipse(0,0, mw*0.55, mh, 0, 0, TAU);
    ctx.fill();
    ctx.restore();

    // estrellas (más marcadas)
    for(const st of stars){
      const tw = CONFIG.reduceMotion ? 1 : (0.55 + 0.45*Math.sin(t*0.001*st.s + st.p) * CONFIG.twinkle);
      const alpha = st.a * (0.85 + 0.70*tw);

      // glow
      ctx.globalAlpha = alpha;
      ctx.shadowColor = 'rgba(255,255,255,0.55)';
      ctx.shadowBlur = 10 + st.r*3;
      ctx.beginPath();
      ctx.arc(st.x*W, st.y*H, st.r, 0, TAU);
      ctx.fillStyle = 'white';
      ctx.fill();

      // chispa (solo algunas)
      if(st.r > 1.8 && st.a > 0.22){
        ctx.shadowBlur = 0;
        ctx.globalAlpha = alpha * 0.55;
        ctx.strokeStyle = 'rgba(255,255,255,0.65)';
        ctx.lineWidth = 1;
        const x = st.x*W, y = st.y*H;
        const k = 3.5 + st.r*1.2;
        ctx.beginPath();
        ctx.moveTo(x-k, y);
        ctx.lineTo(x+k, y);
        ctx.moveTo(x, y-k);
        ctx.lineTo(x, y+k);
        ctx.stroke();
      }
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;

    // brillo leve arriba
    const gx = W*0.52, gy = H*0.16;
    const g = ctx.createRadialGradient(gx, gy, 10, gx, gy, Math.max(W,H)*0.60);
    g.addColorStop(0, 'rgba(255,255,255,0.085)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // viñeta
    const vg = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.98);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.62)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);
  }

  // ===== Hojas (suaves) =====
  function drawTulipLeaf(attachX, attachY, angle, scale, side){
    // Hoja tipo tulipán (realista): larga, delgada, con pliegue central.
    // Ajustada para que NO quede enorme vs el tallo.

    // variación estable mini
    const id = ((attachX * 97) ^ (attachY * 193) ^ (side * 911)) | 0;
    const j = (Math.sin(id) * 0.5 + 0.5);

    // tamaño (más chico y delgado)
    const len = (95 + j*10) * scale;
    const baseWid = (7.5 + j*1.2) * scale;

    // 0 rad = derecha; para hojas erguidas usamos PI/2
    const baseDir = Math.PI/2 + angle;
    // un poquito menos abierto, con un twist natural
    const leafAngle = baseDir + side * (0.16 + j*0.03);

    const p0x = attachX, p0y = attachY;
    const p3x = attachX + Math.cos(leafAngle) * len;
    const p3y = attachY - Math.sin(leafAngle) * len;

    // curva pegada al tallo (sin abrirse en abanico)
    const p1x = attachX + side * baseWid * (0.34 + j*0.08);
    const p1y = attachY - len * (0.35 + j*0.05);

    const p2x = attachX + side * baseWid * (0.14 + j*0.06);
    const p2y = attachY - len * (0.82 + j*0.06);

    const bez = (t, a,b,c,d) => {
      const u = 1 - t;
      return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
    };

    const G0 = {r:28,g:88,b:56};
    const G1 = {r:52,g:140,b:88};
    const G2 = {r:96,g:190,b:130};

    const grad = ctx.createLinearGradient(p0x, p0y, p3x, p3y);
    grad.addColorStop(0, rgba(G0.r,G0.g,G0.b, 0.92));
    grad.addColorStop(0.55, rgba(G1.r,G1.g,G1.b, 0.84));
    grad.addColorStop(1, rgba(G2.r,G2.g,G2.b, 0.70));

    const steps = 14;
    const L = [], R = [], C = [];

    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const x = bez(t, p0x,p1x,p2x,p3x);
      const y = bez(t, p0y,p1y,p2y,p3y);
      C.push({x,y});

      const t2 = Math.min(1, t + 0.015);
      const x2 = bez(t2, p0x,p1x,p2x,p3x);
      const y2 = bez(t2, p0y,p1y,p2y,p3y);
      const dx = x2-x, dy=y2-y;
      const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
      const nx = -dy*inv, ny = dx*inv;

      const taper = Math.pow(1 - t, 1.55);
      const w = baseWid * (0.04 + 0.50*taper);

      L.push({x: x + nx*w, y: y + ny*w});
      R.push({x: x - nx*w, y: y - ny*w});
    }

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.14)';
    ctx.shadowBlur = 4 * scale;

    ctx.fillStyle = grad;
    ctx.strokeStyle = 'rgba(255,255,255,0.012)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(L[0].x, L[0].y);
    for(const p of L) ctx.lineTo(p.x, p.y);
    for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i].x, R[i].y);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.stroke();

    // pliegue central sutil
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = Math.max(1, 1.15*scale);
    ctx.beginPath();
    for(let i=0;i<C.length;i++){
      const p = C[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    // highlight lateral (da volumen)
    ctx.globalAlpha = 0.10;
    const edge = side < 0 ? L : R;
    ctx.strokeStyle = 'rgba(180,255,210,0.14)';
    ctx.lineWidth = Math.max(1, 0.9*scale);
    ctx.beginPath();
    for(let i=0;i<edge.length;i++){
      const p = edge[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;

    ctx.restore();
  }

  // ----- Patrón extra de hojas (líneas) -----
  // Son hojas delgadas tipo contorno para dar sensación de más follaje, como tu trazo blanco.
  function drawLeafSprig(x, y, angle, scale, side){
    // Patrón extra de hojas (líneas) como tu dibujo, pero en VERDE suave (no blanco).
    const baseDir = Math.PI/2 + angle;
    const a = baseDir + side*(0.30);

    const len = 72 * scale;
    const spread = 14 * scale;

    const tipX = x + Math.cos(a) * len;
    const tipY = y - Math.sin(a) * len;

    const cX = x + side * spread;
    const cY = y - len * 0.55;

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const lg = ctx.createLinearGradient(x, y, tipX, tipY);
    lg.addColorStop(0, 'rgba(8,20,12,0.10)');
    lg.addColorStop(0.55, 'rgba(70,200,130,0.08)');
    lg.addColorStop(1, 'rgba(90,240,160,0.12)');

    ctx.strokeStyle = lg;
    ctx.lineWidth = Math.max(1, 0.9 * scale);

    // borde 1
    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(cX, cY, tipX, tipY);
    ctx.stroke();

    // borde 2
    ctx.globalAlpha = 0.45;
    ctx.beginPath();
    ctx.moveTo(x + side*2.0*scale, y + 1.3*scale);
    ctx.quadraticCurveTo(cX - side*spread*0.55, cY + len*0.12, tipX - side*3.0*scale, tipY + 1.2*scale);
    ctx.stroke();

    // nervadura central
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(120,255,180,0.08)';
    ctx.lineWidth = Math.max(1, 0.8 * scale);
    ctx.beginPath();
    ctx.moveTo(x + side*0.8*scale, y);
    ctx.quadraticCurveTo((x+tipX)*0.5, (y+tipY)*0.5, tipX, tipY);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Pétalos realistas =====
  function drawTulipBloom(w, h, col, seed, open){
    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const mix = (a,b,t)=>({
      r: Math.round(lerp(a.r,b.r,t)),
      g: Math.round(lerp(a.g,b.g,t)),
      b: Math.round(lerp(a.b,b.b,t))
    });

    const dark  = mix(col, {r:18,g:6,b:28}, 0.42);
    const deep  = mix(col, {r: 8,g:3,b:14}, 0.65);
    const light = mix(col, {r:255,g:255,b:255}, 0.30);

    const o = open || 1;

    ctx.shadowColor = rgba(col.r, col.g, col.b, 0.16);
    ctx.shadowBlur = Math.max(10, w*0.32);

    const drawPetal = (zFront, idx) => {
      const v1 = (rnd()-0.5);
      const v2 = (rnd()-0.5);
      const v3 = (rnd()-0.5);

      const petW = w * (zFront ? 0.66 : 0.60) * (1 + v1*0.06);
      const petH = h * (zFront ? 1.03 : 0.96) * o * (1 + v2*0.05);
      const tipNotch = 0.10 + rnd()*0.10;
      const belly = 0.20 + rnd()*0.10;

      const pg = ctx.createLinearGradient(0, -petH, 0, petH*0.30);
      pg.addColorStop(0, rgba(light.r, light.g, light.b, zFront ? 0.42 : 0.28));
      pg.addColorStop(0.28, rgba(col.r, col.g, col.b, zFront ? 0.98 : 0.88));
      pg.addColorStop(1, rgba(dark.r, dark.g, dark.b, 0.98));

      ctx.fillStyle = pg;
      ctx.strokeStyle = rgba(255,255,255, zFront ? 0.11 : 0.07);
      ctx.lineWidth = 1;

      const tipX = v3 * petW * 0.08;
      const tipY = -petH;

      ctx.beginPath();
      ctx.moveTo(-petW*0.46, 0);
      ctx.bezierCurveTo(-petW*0.72, -petH*0.30, -petW*0.50, -petH*0.90, tipX - petW*0.10, tipY + petH*tipNotch);
      ctx.quadraticCurveTo(tipX, tipY - petH*0.04, tipX + petW*0.10, tipY + petH*tipNotch);
      ctx.bezierCurveTo(petW*0.50, -petH*0.90, petW*0.72, -petH*0.30, petW*0.46, 0);
      ctx.quadraticCurveTo(0, petH*belly, -petW*0.46, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // translucencia en la punta
      ctx.shadowBlur = 0;
      const tg = ctx.createRadialGradient(tipX, tipY + petH*0.10, petW*0.04, tipX, tipY + petH*0.10, petW*0.55);
      tg.addColorStop(0, rgba(255,255,255, zFront ? 0.10 : 0.07));
      tg.addColorStop(1, rgba(255,255,255, 0));
      ctx.fillStyle = tg;
      ctx.beginPath();
      ctx.ellipse(tipX, tipY + petH*0.18, petW*0.45, petH*0.30, 0, 0, TAU);
      ctx.fill();

      // sombra de pliegue
      ctx.globalAlpha = zFront ? 0.18 : 0.14;
      ctx.fillStyle = rgba(deep.r, deep.g, deep.b, 0.35);
      ctx.beginPath();
      ctx.ellipse(-petW*0.10, -petH*0.40, petW*0.22, petH*0.30, 0.2, 0, TAU);
      ctx.fill();
      ctx.globalAlpha = 1;

      // venas sutiles
      ctx.globalAlpha = zFront ? 0.14 : 0.10;
      ctx.strokeStyle = rgba(255,255,255,0.18);
      ctx.lineWidth = 1;
      const veins = 2 + (idx % 2);
      for(let i=-veins;i<=veins;i++){
        ctx.beginPath();
        ctx.moveTo(i*petW*0.12, tipY + petH*0.06);
        ctx.quadraticCurveTo(i*petW*0.08, -petH*0.55, i*petW*0.03, -petH*0.12);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // rim light
      ctx.globalAlpha = zFront ? 0.20 : 0.14;
      ctx.strokeStyle = rgba(255,255,255,0.22);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(tipX - petW*0.18, tipY + petH*0.10);
      ctx.quadraticCurveTo(tipX, tipY - petH*0.02, tipX + petW*0.18, tipY + petH*0.10);
      ctx.stroke();
      ctx.globalAlpha = 1;
    };

    // traseros
    for(let i=0;i<3;i++){
      ctx.save();
      const a = (-0.36 + i*0.36) + (rnd()-0.5)*0.03;
      ctx.rotate(a);
      ctx.translate(0, h*0.04);
      drawPetal(false, i);
      ctx.restore();
    }

    // sombra interior
    const ig = ctx.createRadialGradient(0, -h*0.30, w*0.05, 0, -h*0.22, w*0.95);
    ig.addColorStop(0, rgba(0,0,0,0));
    ig.addColorStop(1, rgba(0,0,0,0.30));
    ctx.fillStyle = ig;
    ctx.beginPath();
    ctx.ellipse(0, -h*0.30, w*0.50, h*0.56, 0, 0, TAU);
    ctx.fill();

    // frontales
    for(let i=0;i<3;i++){
      ctx.save();
      const a = (-0.40 + i*0.40) + (rnd()-0.5)*0.03;
      ctx.rotate(a);
      drawPetal(true, 3+i);
      ctx.restore();
    }

    // sépalos
    ctx.shadowBlur = 0;
    ctx.fillStyle = rgba(50,170,105,0.92);
    ctx.strokeStyle = rgba(255,255,255,0.06);
    ctx.lineWidth = 1;
    for(let i=0;i<3;i++){
      const a = (-0.55 + i*0.55);
      ctx.save();
      ctx.rotate(a);
      ctx.beginPath();
      ctx.moveTo(-w*0.10, h*0.02);
      ctx.quadraticCurveTo(0, -h*0.10, w*0.10, h*0.02);
      ctx.quadraticCurveTo(0, h*0.15, -w*0.10, h*0.02);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    // base cap
    ctx.fillStyle = rgba(40,140,85,0.50);
    ctx.beginPath();
    ctx.ellipse(0, 0, w*0.18, h*0.10, 0, 0, TAU);
    ctx.fill();

    ctx.fillStyle = rgba(deep.r, deep.g, deep.b, 0.10);
    ctx.beginPath();
    ctx.ellipse(0, -h*0.04, w*0.34, h*0.18, 0, 0, TAU);
    ctx.fill();
  }

  // ===== Bouquet =====
  const DESCS = [
    {dx:-0.30, hf:0.86, bs:0.92},
    {dx: 0.30, hf:0.88, bs:0.95},
    {dx:-0.12, hf:0.98, bs:1.00},
    {dx: 0.12, hf:0.98, bs:1.00},
    {dx:-0.44, hf:0.72, bs:0.84},
    {dx: 0.44, hf:0.74, bs:0.86},
    {dx: 0.00, hf:0.80, bs:0.90},
  ];

  const COLORS = [
    // Paleta más natural (variada pero menos "neón")
    {r:220,g: 55,b: 75},  // rojo tulipán
    {r:245,g:120,b:175},  // rosa
    {r:168,g: 96,b:230},  // lila
    {r: 95,g:175,b:245},  // azul cielo
    {r:255,g:168,b: 70},  // naranja
    {r:245,g:215,b: 95},  // amarillo suave
    {r:245,g:245,b:245},  // blanco
  ];

  let bouquet = [];

  function seedBouquet(){
    const cx = W*0.5;
    const baseY = H*0.93;
    const scaleBase = lerp(0.74, 1.12, clamp(Math.min(W, H)/820, 0, 1));
    const spread = Math.min(W*0.45, 240 + W*0.08);

    bouquet = DESCS.map((p,i)=>{
      const scale = scaleBase * p.bs;
      const bw = (40 + ((i%3)-1)*2) * scale;
      const bh = (86 + ((i%4)-2)*4) * scale;
      const twist = (i-3) * 0.018;

      return {
        i,
        x: cx + p.dx*spread,
        baseY,
        scale,
        height: (235 * scaleBase) * p.hf,
        phase: i*0.85,
        bw, bh,
        twist,
        col: COLORS[i] || COLORS[i % COLORS.length],
        seed: 1337 + i*101,
        open: 0.92 + (i % 4) * 0.03
      };
    });
  }

  function drawBouquet(t){
    // césped primero (para que el ramo quede encima)
    drawGrass(t);

    // haze detrás del ramo
    const hx = W*0.5, hy = H*0.78;
    const hg = ctx.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
    hg.addColorStop(0, 'rgba(0,0,0,0)');
    hg.addColorStop(1, 'rgba(0,0,0,0.30)');
    ctx.fillStyle = hg;
    ctx.fillRect(0,0,W,H);

    // masa verde sutil en la base
    const bush = ctx.createRadialGradient(W*0.5, H*0.95, 10, W*0.5, H*0.95, Math.min(W,H)*0.45);
    bush.addColorStop(0, 'rgba(65,150,95,0.16)');
    bush.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = bush;
    ctx.fillRect(0,0,W,H);

    const STEM = {r:55,g:155,b:92};
    const STEM2= {r:35,g:120,b:72};

    // tallos + hojas
    for(const f of bouquet){
      const sway = CONFIG.reduceMotion ? 0 : Math.sin(t*0.001*(0.9) + f.phase) * 0.22 * CONFIG.sway;
      const angle = sway + (f.x - W*0.5) * 0.0006;

      const baseX = f.x;
      const baseY = f.baseY;
      const topY  = baseY - f.height;

      const bloomX = baseX + Math.sin(angle) * 12 * f.scale;
      const bloomY = topY + Math.cos(angle) * 5 * f.scale;

      const cp1x = baseX + Math.sin(f.phase)*10*f.scale;
      const cp1y = baseY - f.height*0.40;
      const cp2x = baseX + Math.cos(f.phase*1.7)*16*f.scale;
      const cp2y = baseY - f.height*0.76;

      // hojas: proporción realista y nacen aprox. a la mitad del tallo
      const leafMid1 = baseY - f.height*0.52;
      const leafMid2 = baseY - f.height*0.60;
      ctx.save();
      drawTulipLeaf(baseX, leafMid1, angle, f.scale*0.56, -1);
      drawTulipLeaf(baseX, leafMid2, angle, f.scale*0.50,  1);

      // patrón sutil (sin blanco): 2 sprigs máximo para no ensuciar
      drawLeafSprig(baseX, baseY - f.height*0.56, angle, f.scale*0.52, -1);
      drawLeafSprig(baseX, baseY - f.height*0.64, angle, f.scale*0.46,  1);
      ctx.restore();

      // tallo
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      const sg = ctx.createLinearGradient(baseX, baseY, bloomX, bloomY);
      sg.addColorStop(0, rgba(STEM2.r, STEM2.g, STEM2.b, 0.95));
      sg.addColorStop(1, rgba(STEM.r, STEM.g, STEM.b, 0.95));
      ctx.strokeStyle = sg;
      ctx.lineWidth = 7.0 * f.scale;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, bloomX, bloomY);
      ctx.stroke();
      ctx.restore();

      f.bloomX = bloomX;
      f.bloomY = bloomY;
      f.angle = angle + f.twist;
    }

    // flores
    for(const f of bouquet){
      ctx.save();
      ctx.translate(f.bloomX, f.bloomY);
      ctx.rotate(f.angle);

      ctx.shadowColor = `rgba(${f.col.r},${f.col.g},${f.col.b},0.20)`;
      ctx.shadowBlur = 16 + 16*f.scale;

      drawTulipBloom(f.bw, f.bh, f.col, f.seed, f.open);
      ctx.restore();
    }

    // base del ramo
    const knotX = W*0.5, knotY = H*0.935;
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath();
    ctx.ellipse(knotX, knotY, Math.min(110, W*0.20), 26, 0, 0, TAU);
    ctx.fill();
  }

  // init
  seedStars();
  resize();

  // loop
  function frame(t){
    requestAnimationFrame(frame);
    drawSky(t);
    drawBouquet(t);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
