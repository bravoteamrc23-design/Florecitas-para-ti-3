<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ramo de tulipanes (noche)</title>
  <style>
    :root{
      --bg1:#070814;
      --bg2:#0b1030;
      --bg3:#151a40;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(900px 650px at 50% 10%, var(--bg3), var(--bg2), var(--bg1));
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

<script>
(() => {
  'use strict';

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  let W = 0, H = 0, DPR = 1;

  const TAU = Math.PI * 2;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rgba  = (r,g,b,a)=>`rgba(${r},${g},${b},${a})`;

  const shuffleInPlace = (arr) => {
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  };

  const CONFIG = {
    stars: 160,
    twinkle: 0.85,
    sway: 0.28,
    reduceMotion: false,
    shootingStars: 1,

    // 0 = casi sin corona, 1 = corona marcada
    crownStrength: 0.55,
  };

  try{
    const m = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
    if(m && m.matches) CONFIG.reduceMotion = true;
  }catch(_){}

  // ===== Stars =====
  const stars = [];

  const shooting = { active:false, t0:0, dur:0, x0:0,y0:0, x1:0,y1:0 };

  function seedStars(){
    stars.length = 0;
    const clusters = [
      {cx: 0.30, cy: 0.22, r: 0.18},
      {cx: 0.72, cy: 0.18, r: 0.20},
    ];

    const pick = () => {
      if(Math.random() < 0.70) return {x: Math.random(), y: Math.random()};
      const c = clusters[(Math.random()*clusters.length)|0];
      const a = Math.random()*TAU;
      const rr = Math.sqrt(Math.random()) * c.r;
      return { x: clamp(c.cx + Math.cos(a)*rr, 0, 1), y: clamp(c.cy + Math.sin(a)*rr, 0, 1) };
    };

    for(let i=0;i<CONFIG.stars;i++){
      const p = pick();
      const yBias = Math.pow(1 - p.y, 1.6);
      const bigChance = 0.06 + 0.07*yBias;
      const big = Math.random() < bigChance;

      stars.push({
        x: p.x, y: p.y,
        r: big ? (1.9 + Math.random()*2.8) : (0.7 + Math.random()*1.7),
        a: big ? (0.18 + Math.random()*0.30) : (0.08 + Math.random()*0.24),
        p: Math.random()*TAU,
        s: (0.25 + Math.random()*0.95),
        hue: big ? (200 + Math.random()*60) : 0,
        flare: big ? (0.55 + Math.random()*0.45) : 0,
      });
    }

    shooting.active = false;
    shooting.t0 = 0;
    shooting.dur = 0;
  }

  function maybeStartShootingStar(t){
    if(CONFIG.reduceMotion || !CONFIG.shootingStars) return;
    if(shooting.active) return;

    if(Math.random() < 0.0022){
      shooting.active = true;
      shooting.t0 = t;
      shooting.dur = 900 + Math.random()*900;

      const startX = Math.random()*W*0.90;
      const startY = Math.random()*H*0.35;
      const dx = (120 + Math.random()*220);
      const dy = (40 + Math.random()*120);

      shooting.x0 = startX; shooting.y0 = startY;
      shooting.x1 = startX + dx; shooting.y1 = startY + dy;
    }
  }

  function drawShootingStar(t){
    if(!shooting.active) return;

    const u = clamp((t - shooting.t0) / shooting.dur, 0, 1);
    const ease = u*u*(3-2*u);

    const x = lerp(shooting.x0, shooting.x1, ease);
    const y = lerp(shooting.y0, shooting.y1, ease);

    const tail = 120;
    const ang = Math.atan2(shooting.y1 - shooting.y0, shooting.x1 - shooting.x0);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = (1-u) * 0.85;

    const tx = x - Math.cos(ang)*tail;
    const ty = y - Math.sin(ang)*tail;

    const g = ctx.createLinearGradient(tx, ty, x, y);
    g.addColorStop(0, 'rgba(255,255,255,0)');
    g.addColorStop(0.55, 'rgba(255,255,255,0.14)');
    g.addColorStop(1, 'rgba(255,255,255,0.85)');

    ctx.strokeStyle = g;
    ctx.lineWidth = 2.0;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(x, y);
    ctx.stroke();

    ctx.globalAlpha = (1-u) * 0.95;
    ctx.shadowColor = 'rgba(255,255,255,0.8)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x,y, 1.8, 0, TAU);
    ctx.fill();

    ctx.restore();

    if(u >= 1) shooting.active = false;
  }

  // ===== Césped =====
  const grass = [];
  const soil = [];
  const grassAnim1 = [];
  const grassAnim2 = [];

  let groundCache = null;
  let skyCache = null;
  const bloomCache = new Map();

  function seedSoil(){
    soil.length = 0;
    const gy = H * 0.74;
    const groundH = H - gy;

    const blobs = clamp(Math.floor(W / 160), 6, 12);
    for(let i=0;i<blobs;i++){
      soil.push({
        x: W*(0.05 + Math.random()*0.90),
        y: gy + groundH*(0.25 + Math.random()*0.75),
        r: (90 + Math.random()*220),
        a: (0.08 + Math.random()*0.12)
      });
    }
  }

  function seedGrass(){
    grass.length = 0;

    const gy = H * 0.74;
    const groundH = H - gy;

    const tufts = clamp(Math.floor(W / 14), 42, 110);
    const bladesBase = 10;
    const bladesExtra = 10;

    for(let t=0;t<tufts;t++){
      const tx = (t + Math.random()*0.85) * (W / tufts);
      const tuftSeed = Math.random()*TAU;
      const count = bladesBase + Math.floor(Math.random()*bladesExtra);

      for(let i=0;i<count;i++){
        const r = Math.random();
        const layer = (r < 0.52) ? 0 : (r < 0.86 ? 1 : 2);

        const baseBand = layer===2 ? 0.72 : (layer===1 ? 0.64 : 0.56);
        const ty = gy + groundH*(baseBand + Math.random()*(1-baseBand));

        const jitterX = (Math.random()-0.5) * (12 + layer*22);
        const jitterY = (Math.random()-0.5) * (6 + layer*10);

        const hBase = layer===2 ? 84 : (layer===1 ? 62 : 44);
        const hVar  = layer===2 ? 98 : (layer===1 ? 72 : 54);

        const curlAmp = layer===2 ? 0.65 : (layer===1 ? 0.55 : 0.45);

        grass.push({
          layer,
          x: tx + jitterX,
          y: ty + jitterY,
          h: hBase + Math.random()*hVar,
          w: (layer===2 ? 1.55 : (layer===1 ? 1.05 : 0.78)) + Math.random()*(layer===2 ? 1.55 : (layer===1 ? 1.10 : 0.90)),
          p: tuftSeed + i*0.52 + Math.random()*0.85,
          s: (layer===2 ? 0.72 : (layer===1 ? 0.90 : 0.66)) + Math.random()*(layer===2 ? 1.05 : (layer===1 ? 1.05 : 1.00)),
          a: (layer===2 ? 0.18 : (layer===1 ? 0.14 : 0.11)) + Math.random()*(layer===2 ? 0.22 : (layer===1 ? 0.18 : 0.14)),
          bend: (layer===2 ? 1.35 : (layer===1 ? 1.10 : 0.95)) + Math.random()*0.35,
          curl: (Math.random()-0.5) * curlAmp,
          thick: layer===2 ? (0.55 + Math.random()*0.85) : 0,
          tip: 0.75 + Math.random()*0.9
        });
      }
    }

    grassAnim1.length = 0;
    grassAnim2.length = 0;

    const g1 = [];
    const g2 = [];
    for(const b of grass){
      if(b.layer === 1) g1.push(b);
      else if(b.layer === 2) g2.push(b);
    }

    shuffleInPlace(g1);
    shuffleInPlace(g2);

    const max1 = clamp(Math.floor(W * 0.55), 200, 650);
    const max2 = clamp(Math.floor(W * 0.40), 160, 520);

    grassAnim1.push(...g1.slice(0, max1));
    grassAnim2.push(...g2.slice(0, max2));
  }

  function rebuildGroundCache(){
    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const gy = H * 0.74;
    const groundH = H - gy;

    const gg = g.createLinearGradient(0, gy, 0, H);
    gg.addColorStop(0, 'rgba(8,14,10,0.05)');
    gg.addColorStop(0.22, 'rgba(16,44,28,0.28)');
    gg.addColorStop(0.66, 'rgba(8,22,16,0.60)');
    gg.addColorStop(1, 'rgba(0,0,0,0.78)');
    g.fillStyle = gg;
    g.fillRect(0, gy, W, groundH);

    for(const b of soil){
      const rg = g.createRadialGradient(b.x, b.y, 8, b.x, b.y, b.r);
      rg.addColorStop(0, `rgba(25,85,48,${b.a})`);
      rg.addColorStop(0.55, `rgba(12,40,24,${b.a*0.55})`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.fillRect(0,0,W,H);
    }

    g.save();
    g.globalAlpha = 0.10;
    g.fillStyle = 'rgba(255,255,255,0.08)';
    const dots = clamp(Math.floor(W * groundH / 1800), 180, 420);
    for(let i=0;i<dots;i++){
      const x = Math.random()*W;
      const y = gy + Math.random()*groundH;
      const r = 0.6 + Math.random()*1.4;
      g.beginPath();
      g.arc(x,y,r,0,TAU);
      g.fill();
    }
    g.restore();

    const drawStaticBlade = (b, front) => {
      const x0 = b.x, y0 = b.y;
      const len = b.h;
      const tilt = b.curl*0.18;

      const x1 = x0 + tilt * (10 + b.bend*5);
      const y1 = y0 - len;

      const cx = x0 + tilt * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      g.strokeStyle = front ? 'rgba(24,105,62,1)' : 'rgba(16,75,44,1)';
      g.lineWidth = b.w * (front ? 1.10 : 1.0);
      g.beginPath();
      g.moveTo(x0, y0);
      g.quadraticCurveTo(cx, cy, x1, y1);
      g.stroke();

      const old = g.globalAlpha;
      g.globalAlpha = old * (front ? 0.22 : 0.16);
      g.strokeStyle = 'rgba(190,255,220,1)';
      g.lineWidth = Math.max(0.7, b.w*0.30);
      g.beginPath();
      g.moveTo(x0 + 0.7, y0);
      g.quadraticCurveTo(cx + 0.5, cy, x1 + 0.3, y1);
      g.stroke();
      g.globalAlpha = old;
    };

    g.save();
    for(const b of grass){
      if(b.layer !== 0) continue;
      g.globalAlpha = 0.18 + b.a*0.90;
      drawStaticBlade(b, false);
    }
    g.restore();

    g.save();
    for(const b of grass){
      if(b.layer !== 1) continue;
      if(b.h > 90) continue;
      g.globalAlpha = 0.16 + b.a*0.80;
      drawStaticBlade(b, true);
    }
    g.restore();

    const fogTop = gy + groundH*0.18;
    const fog = g.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(1, 'rgba(0,0,0,0.34)');
    g.fillStyle = fog;
    g.fillRect(0, fogTop, W, H - fogTop);

    groundCache = off;
  }

  function drawGrass(t){
    if(groundCache){
      ctx.drawImage(groundCache, 0, 0, groundCache.width / DPR, groundCache.height / DPR);
    }

    const gy = H * 0.74;
    const groundH = H - gy;

    const wind = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00065) * 0.75;

    const drawBlade = (b, front) => {
      const sway = CONFIG.reduceMotion ? 0 : Math.sin(t*0.001*b.s + b.p) * (front ? 0.40 : 0.26);
      const sway2 = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00135*b.s + b.p*0.7) * 0.08;

      const x0 = b.x;
      const y0 = b.y;
      const len = b.h;

      const tilt = (sway + wind + b.curl*0.22);
      const x1 = x0 + tilt * (9 + b.bend*6);
      const y1 = y0 - len;

      const cx = x0 + (tilt + sway2) * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      if(front){
        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.18;
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        ctx.beginPath();
        ctx.ellipse(x0, y0+1.2, 3.2 + b.w, 1.2 + b.w*0.34, 0, 0, TAU);
        ctx.fill();
        ctx.globalAlpha = old;
      }

      if(b.layer === 2){
        const w0 = b.w * (1.00 + b.thick);
        const w1 = Math.max(0.8, w0 * 0.16);

        const t0x = x0, t0y = y0;
        const t1x = cx, t1y = cy;
        const t2x = x1, t2y = y1;

        const dx = t2x - t0x;
        const dy = t2y - t0y;
        const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
        const px = -dy * inv;
        const py =  dx * inv;

        const lg = ctx.createLinearGradient(x0, y0, x1, y1);
        lg.addColorStop(0, 'rgba(10,55,32,0.88)');
        lg.addColorStop(0.55, 'rgba(28,118,68,0.78)');
        lg.addColorStop(1, 'rgba(115,220,150,0.56)');

        ctx.save();
        ctx.fillStyle = lg;

        ctx.beginPath();
        ctx.moveTo(t0x + px*w0, t0y + py*w0);
        ctx.quadraticCurveTo(t1x + px*(w0*0.60), t1y + py*(w0*0.60), t2x + px*w1, t2y + py*w1);
        ctx.lineTo(t2x - px*w1, t2y - py*w1);
        ctx.quadraticCurveTo(t1x - px*(w0*0.52), t1y - py*(w0*0.52), t0x - px*w0, t0y - py*w0);
        ctx.closePath();
        ctx.fill();

        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.24;
        ctx.strokeStyle = 'rgba(215,255,235,0.32)';
        ctx.lineWidth = Math.max(0.8, b.w*0.34);
        ctx.beginPath();
        ctx.moveTo(x0 + px*0.4, y0 + py*0.4);
        ctx.quadraticCurveTo(cx + px*0.2, cy + py*0.2, x1 + px*0.10, y1 + py*0.10);
        ctx.stroke();
        ctx.globalAlpha = old;

        ctx.restore();
      }

      ctx.strokeStyle = front ? 'rgba(22,98,58,1)' : 'rgba(18,72,42,1)';
      ctx.lineWidth = b.w * (front ? 1.12 : 1.0);
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();

      const old = ctx.globalAlpha;
      ctx.globalAlpha = old * (front ? 0.22 : 0.16);
      ctx.strokeStyle = 'rgba(190,255,220,1)';
      ctx.lineWidth = Math.max(0.7, b.w*0.30);
      ctx.beginPath();
      ctx.moveTo(x0 + 0.8, y0);
      ctx.quadraticCurveTo(cx + 0.55, cy, x1 + 0.35, y1);
      ctx.stroke();
      ctx.globalAlpha = old;
    };

    ctx.save();
    for(const b of grassAnim1){
      ctx.globalAlpha = 0.16 + b.a*0.92;
      drawBlade(b, false);
    }
    ctx.restore();

    ctx.save();
    for(const b of grassAnim2){
      ctx.globalAlpha = 0.22 + b.a*0.98;
      drawBlade(b, true);
    }
    ctx.restore();

    ctx.save();
    const thatchTop = gy + groundH*0.74;
    const tg = ctx.createLinearGradient(0, thatchTop, 0, H);
    tg.addColorStop(0, 'rgba(0,0,0,0)');
    tg.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = tg;
    ctx.fillRect(0, thatchTop, W, H - thatchTop);
    ctx.restore();

    if(!CONFIG.reduceMotion){
      ctx.save();
      ctx.globalAlpha = 0.05;
      ctx.fillStyle = 'rgba(220,255,240,0.18)';
      const drops = 16;
      for(let i=0;i<drops;i++){
        const x = W*(0.18 + Math.random()*0.64);
        const y = (gy + groundH*0.25) + Math.random()*(groundH*0.70);
        ctx.beginPath();
        ctx.arc(x,y, 0.9 + Math.random()*1.2, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  // ===== Cielo (cache) =====
  function rebuildSkyCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const sky = g.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, 'rgba(10,12,38,1)');
    sky.addColorStop(0.45, 'rgba(6,8,20,1)');
    sky.addColorStop(1, 'rgba(3,3,10,1)');
    g.fillStyle = sky;
    g.fillRect(0,0,W,H);

    const neb = (x,y,r, a, cr,cg,cb) => {
      const gg = g.createRadialGradient(x,y, 10, x,y, r);
      gg.addColorStop(0, rgba(cr,cg,cb,a));
      gg.addColorStop(0.55, rgba(cr,cg,cb,a*0.26));
      gg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = gg;
      g.fillRect(0,0,W,H);
    };
    neb(W*0.18, H*0.16, Math.max(W,H)*0.62, 0.08, 120,150,255);
    neb(W*0.80, H*0.22, Math.max(W,H)*0.56, 0.07, 150,120,255);
    neb(W*0.55, H*0.10, Math.max(W,H)*0.50, 0.05, 90,170,255);

    g.save();
    g.translate(W*0.56, H*0.34);
    g.rotate(-0.36);
    const mw = Math.max(W,H)*1.25;
    const mh = Math.max(W,H)*0.24;

    const mg = g.createRadialGradient(0,0, mh*0.03, 0,0, mh);
    mg.addColorStop(0, 'rgba(255,255,255,0.085)');
    mg.addColorStop(0.55, 'rgba(190,210,255,0.035)');
    mg.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = mg;
    g.beginPath();
    g.ellipse(0,0, mw*0.56, mh, 0, 0, TAU);
    g.fill();

    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.35;
    const dust = clamp(Math.floor((W*H)/9000), 120, 360);
    for(let i=0;i<dust;i++){
      const dx = (Math.random()-0.5) * mw*0.85;
      const dy = (Math.random()-0.5) * mh*0.55;
      const rr = 0.6 + Math.random()*1.7;
      g.fillStyle = 'rgba(255,255,255,0.10)';
      g.beginPath();
      g.arc(dx, dy, rr, 0, TAU);
      g.fill();
    }
    g.restore();

    const gx = W*0.52, gy = H*0.16;
    const glow = g.createRadialGradient(gx, gy, 10, gx, gy, Math.max(W,H)*0.62);
    glow.addColorStop(0, 'rgba(255,255,255,0.085)');
    glow.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = glow;
    g.fillRect(0,0,W,H);

    g.save();
    g.globalAlpha = 0.05;
    g.fillStyle = 'rgba(255,255,255,0.06)';
    const n = clamp(Math.floor((W*H)/14000), 220, 520);
    for(let i=0;i<n;i++){
      const x = Math.random()*W;
      const y = Math.random()*H*0.70;
      g.fillRect(x,y,1,1);
    }
    g.restore();

    const vg = g.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.98);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.62)');
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);

    skyCache = off;
  }

  function drawSky(t){
    ctx.clearRect(0,0,W,H);

    if(skyCache){
      ctx.drawImage(skyCache, 0, 0, skyCache.width / DPR, skyCache.height / DPR);
    }else{
      const sky = ctx.createLinearGradient(0, 0, 0, H);
      sky.addColorStop(0, 'rgba(10,12,38,1)');
      sky.addColorStop(0.45, 'rgba(6,8,20,1)');
      sky.addColorStop(1, 'rgba(3,3,10,1)');
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);
    }

    ctx.save();
    for(const st of stars){
      const tw = CONFIG.reduceMotion ? 1 : (0.55 + 0.45*Math.sin(t*0.001*st.s + st.p) * CONFIG.twinkle);
      const alpha = st.a * (0.78 + 0.82*tw);

      const x = st.x*W;
      const y = st.y*H;

      ctx.globalAlpha = alpha;
      ctx.shadowColor = 'rgba(255,255,255,0.55)';
      ctx.shadowBlur = 10 + st.r*3;
      ctx.fillStyle = st.hue ? `hsla(${st.hue}, 85%, 88%, 1)` : 'white';

      ctx.beginPath();
      ctx.arc(x, y, st.r, 0, TAU);
      ctx.fill();

      if(st.flare){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = alpha * 0.55 * st.flare;
        ctx.shadowBlur = 0;
        const rg = ctx.createRadialGradient(x,y, 0, x,y, 22 + st.r*10);
        rg.addColorStop(0, 'rgba(255,255,255,0.22)');
        rg.addColorStop(0.45, 'rgba(255,255,255,0.08)');
        rg.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(x,y, 24 + st.r*10, 0, TAU);
        ctx.fill();

        ctx.globalAlpha = alpha * 0.40 * st.flare;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        const k = 4.0 + st.r*1.6;
        ctx.beginPath();
        ctx.moveTo(x-k, y); ctx.lineTo(x+k, y);
        ctx.moveTo(x, y-k); ctx.lineTo(x, y+k);
        ctx.stroke();
        ctx.restore();
      }
    }
    ctx.restore();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;

    maybeStartShootingStar(t);
    drawShootingStar(t);
  }

  // ===== Hojas =====
  function drawTulipLeaf(attachX, attachY, angle, scale, side){
    const id = ((attachX * 97) ^ (attachY * 193) ^ (side * 911)) | 0;
    const j = (Math.sin(id) * 0.5 + 0.5);

    const len = (95 + j*10) * scale;
    const baseWid = (7.5 + j*1.2) * scale;

    const baseDir = Math.PI/2 + angle;
    const leafAngle = baseDir + side * (0.16 + j*0.03);

    const p0x = attachX, p0y = attachY;
    const p3x = attachX + Math.cos(leafAngle) * len;
    const p3y = attachY - Math.sin(leafAngle) * len;

    const p1x = attachX + side * baseWid * (0.34 + j*0.08);
    const p1y = attachY - len * (0.35 + j*0.05);

    const p2x = attachX + side * baseWid * (0.14 + j*0.06);
    const p2y = attachY - len * (0.82 + j*0.06);

    const bez = (t, a,b,c,d) => {
      const u = 1 - t;
      return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
    };

    const G0 = {r:28,g:88,b:56};
    const G1 = {r:52,g:140,b:88};
    const G2 = {r:96,g:190,b:130};

    const grad = ctx.createLinearGradient(p0x, p0y, p3x, p3y);
    grad.addColorStop(0, rgba(G0.r,G0.g,G0.b, 0.92));
    grad.addColorStop(0.55, rgba(G1.r,G1.g,G1.b, 0.84));
    grad.addColorStop(1, rgba(G2.r,G2.g,G2.b, 0.70));

    const steps = 14;
    const L = [], R = [], C = [];

    for(let i=0;i<=steps;i++){
      const tt = i/steps;
      const x = bez(tt, p0x,p1x,p2x,p3x);
      const y = bez(tt, p0y,p1y,p2y,p3y);
      C.push({x,y});

      const tt2 = Math.min(1, tt + 0.015);
      const x2 = bez(tt2, p0x,p1x,p2x,p3x);
      const y2 = bez(tt2, p0y,p1y,p2y,p3y);
      const dx = x2-x, dy=y2-y;
      const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
      const nx = -dy*inv, ny = dx*inv;

      const taper = Math.pow(1 - tt, 1.55);
      const w = baseWid * (0.04 + 0.50*taper);

      L.push({x: x + nx*w, y: y + ny*w});
      R.push({x: x - nx*w, y: y - ny*w});
    }

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.14)';
    ctx.shadowBlur = 4 * scale;

    ctx.fillStyle = grad;
    ctx.strokeStyle = 'rgba(255,255,255,0.012)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(L[0].x, L[0].y);
    for(const p of L) ctx.lineTo(p.x, p.y);
    for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i].x, R[i].y);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.stroke();

    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = Math.max(1, 1.15*scale);
    ctx.beginPath();
    for(let i=0;i<C.length;i++){
      const p = C[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.10;
    const edge = side < 0 ? L : R;
    ctx.strokeStyle = 'rgba(180,255,210,0.14)';
    ctx.lineWidth = Math.max(1, 0.9*scale);
    ctx.beginPath();
    for(let i=0;i<edge.length;i++){
      const p = edge[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawLeafSprig(x, y, angle, scale, side){
    const baseDir = Math.PI/2 + angle;
    const a = baseDir + side*(0.30);

    const len = 72 * scale;
    const spread = 14 * scale;

    const tipX = x + Math.cos(a) * len;
    const tipY = y - Math.sin(a) * len;

    const cX = x + side * spread;
    const cY = y - len * 0.55;

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const lg = ctx.createLinearGradient(x, y, tipX, tipY);
    lg.addColorStop(0, 'rgba(8,20,12,0.10)');
    lg.addColorStop(0.55, 'rgba(70,200,130,0.08)');
    lg.addColorStop(1, 'rgba(90,240,160,0.12)');

    ctx.strokeStyle = lg;
    ctx.lineWidth = Math.max(1, 0.9 * scale);

    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(cX, cY, tipX, tipY);
    ctx.stroke();

    ctx.globalAlpha = 0.45;
    ctx.beginPath();
    ctx.moveTo(x + side*2.0*scale, y + 1.3*scale);
    ctx.quadraticCurveTo(cX - side*spread*0.55, cY + len*0.12, tipX - side*3.0*scale, tipY + 1.2*scale);
    ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(120,255,180,0.08)';
    ctx.lineWidth = Math.max(1, 0.8 * scale);
    ctx.beginPath();
    ctx.moveTo(x + side*0.8*scale, y);
    ctx.quadraticCurveTo((x+tipX)*0.5, (y+tipY)*0.5, tipX, tipY);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Bloom sprite =====
  function getBloomSprite(w, h, col, seed, open){
    const key = `${Math.round(w)}x${Math.round(h)}_${col.r},${col.g},${col.b}_${seed}_${Math.round((open||1)*100)}_${Math.round(CONFIG.crownStrength*100)}`;
    const cached = bloomCache.get(key);
    if(cached) return cached;

    const ss = 2;
    const cw = Math.ceil(w * 3.25);
    const ch = Math.ceil(h * 2.75 + w * 0.55);

    const ax = Math.ceil(cw * 0.50);
    const ay = Math.ceil(h  * 1.75);

    const off = document.createElement('canvas');
    off.width  = cw * ss;
    off.height = ch * ss;

    const c2 = off.getContext('2d', { alpha:true });
    c2.setTransform(ss,0,0,ss,0,0);
    c2.translate(ax, ay);

    renderTulipBloomSprite(c2, w, h, col, seed, open);

    const obj = { canvas: off, ox: ax, oy: ay, ss };
    bloomCache.set(key, obj);
    return obj;
  }

  function renderTulipBloomSprite(c2, w, h, col, seed, open){
    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const mix = (a,b,t)=>({
      r: Math.round(lerp(a.r,b.r,t)),
      g: Math.round(lerp(a.g,b.g,t)),
      b: Math.round(lerp(a.b,b.b,t))
    });

    const dark  = mix(col, {r:18,g:6,b:28}, 0.48);
    const deep  = mix(col, {r: 6,g:2,b:10}, 0.76);
    const lite  = mix(col, {r:255,g:255,b:255}, 0.40);
    const warm  = mix(col, {r:255,g:240,b:220}, 0.22);

    const op = clamp(((open||1) - 0.86) / 0.26, 0, 1);
    const spread = lerp(0.10, 0.28, op);

    c2.save();
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.18;
    const gg = c2.createRadialGradient(0, -h*0.56, 10, 0, -h*0.40, w*1.85);
    gg.addColorStop(0, rgba(col.r,col.g,col.b,0.34));
    gg.addColorStop(0.55, rgba(col.r,col.g,col.b,0.10));
    gg.addColorStop(1, rgba(col.r,col.g,col.b,0));
    c2.fillStyle = gg;
    c2.beginPath();
    c2.ellipse(0, -h*0.42, w*1.25, h*1.12, 0, 0, TAU);
    c2.fill();
    c2.restore();

    const petalPath = (petW, petH, notch, wave, lip, asym, crown) => {
      const baseL = -petW*0.44;
      const baseR =  petW*0.44;

      const leftShoulderX  = -petW*0.70;
      const rightShoulderX =  petW*0.70;
      const shoulderY = -petH*0.24;

      const topBaseY = -petH*(0.965 - notch*0.50);
      const crownY   = -petH*(1.010 + lip*0.10);
      const waveX = wave * petW * 0.05;

      const cs = clamp(crown * CONFIG.crownStrength, 0.10, 1.0);
      const peakSide = petH * (0.015 + 0.012*cs);
      const peakMid  = petH * (0.020 + 0.016*cs);
      const valley   = petH * (0.006 + 0.006*cs);

      const pL  = {x: -petW*0.15 + asym + waveX,              y: topBaseY};
      const pR  = {x:  petW*0.15 + asym*0.25 + waveX,         y: topBaseY};

      const p1  = {x: -petW*0.17 + asym*0.10 + waveX,         y: crownY - peakSide};
      const v1  = {x: -petW*0.06 + asym*0.10 + waveX,         y: crownY + valley};
      const pC  = {x:  0 + asym*0.06 + waveX,                 y: crownY - peakMid};
      const v2  = {x:  petW*0.06 + asym*0.04 + waveX,         y: crownY + valley};
      const p2  = {x:  petW*0.17 + asym*0.02 + waveX,         y: crownY - peakSide};

      const mid = (a,b)=>({x:(a.x+b.x)*0.5, y:(a.y+b.y)*0.5});

      c2.beginPath();
      c2.moveTo(baseL, 0);

      c2.bezierCurveTo(leftShoulderX, shoulderY, -petW*0.56, -petH*0.84, pL.x, pL.y);

      const q = (toX, toY, cX, cY) => c2.quadraticCurveTo(cX, cY, toX, toY);
      const m01 = mid(pL,p1); q(p1.x, p1.y, m01.x, m01.y);
      const m12 = mid(p1,v1); q(v1.x, v1.y, m12.x, m12.y);
      const m23 = mid(v1,pC); q(pC.x, pC.y, m23.x, m23.y);
      const m34 = mid(pC,v2); q(v2.x, v2.y, m34.x, m34.y);
      const m45 = mid(v2,p2); q(p2.x, p2.y, m45.x, m45.y);
      const m56 = mid(p2,pR); q(pR.x, pR.y, m56.x, m56.y);

      c2.bezierCurveTo(petW*0.56, -petH*0.84, rightShoulderX, shoulderY, baseR, 0);
      c2.quadraticCurveTo(0, petH*0.14, baseL, 0);
      c2.closePath();
    };

    const fillPetal = (front, idx, sizeMul) => {
      const v1 = (rnd()-0.5);
      const v2 = (rnd()-0.5);

      const notch = 0.028 + rnd()*0.040;
      const petW = w * (front ? 0.70 : 0.62) * sizeMul * (1 + v1*0.05);
      const petH = h * (front ? 1.34 : 1.22) * sizeMul * (0.92 + op*0.18) * (1 + v2*0.035);

      const wave  = (rnd()-0.5) * 0.55;
      const lip   = 0.050 + op*0.055;
      const asym  = (rnd()-0.5) * petW * 0.06;
      const crown = 0.55 + rnd()*0.30;

      const vg = c2.createLinearGradient(0, -petH, 0, petH*0.30);
      vg.addColorStop(0, rgba(lite.r,lite.g,lite.b, front ? 0.56 : 0.40));
      vg.addColorStop(0.18, rgba(warm.r,warm.g,warm.b, front ? 0.24 : 0.18));
      vg.addColorStop(0.45, rgba(col.r,col.g,col.b, front ? 1.00 : 0.92));
      vg.addColorStop(1, rgba(dark.r,dark.g,dark.b, 0.98));

      const hg = c2.createLinearGradient(-petW, -petH*0.35, petW, -petH*0.10);
      hg.addColorStop(0, rgba(0,0,0,0.24));
      hg.addColorStop(0.45, rgba(0,0,0,0.00));
      hg.addColorStop(1, rgba(0,0,0,0.28));

      const rim = c2.createRadialGradient(0, -petH*0.95, petW*0.02, 0, -petH*0.88, petW*1.15);
      rim.addColorStop(0, rgba(255,255,255, front ? 0.20 : 0.16));
      rim.addColorStop(0.55, rgba(255,255,255,0.06));
      rim.addColorStop(1, rgba(255,255,255,0));

      c2.save();
      c2.shadowColor = rgba(col.r,col.g,col.b, 0.10);
      c2.shadowBlur = Math.max(10, w*0.30);

      petalPath(petW, petH, notch, wave, lip, asym, crown);
      c2.fillStyle = vg;
      c2.fill();

      c2.save();
      c2.clip();
      c2.globalCompositeOperation = 'source-atop';
      c2.globalAlpha = front ? 0.10 : 0.08;
      const cap = c2.createLinearGradient(0, -petH*1.06, 0, -petH*0.74);
      cap.addColorStop(0, rgba(255,255,255,0.22));
      cap.addColorStop(0.55, rgba(255,255,255,0.10));
      cap.addColorStop(1, rgba(255,255,255,0.00));
      c2.fillStyle = cap;
      c2.fillRect(-petW*1.25, -petH*1.10, petW*2.50, petH*0.46);
      c2.restore();

      c2.shadowBlur = 0;
      c2.globalAlpha = front ? 0.07 : 0.05;
      c2.strokeStyle = rgba(255,255,255,0.22);
      c2.lineWidth = 1;
      c2.stroke();
      c2.globalAlpha = 1;

      c2.save();
      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = front ? 0.22 : 0.18;
      c2.fillStyle = hg;
      c2.fill();
      c2.restore();

      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = front ? 0.24 : 0.18;
      c2.fillStyle = rim;
      c2.fill();
      c2.restore();

      c2.save();
      c2.clip();

      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = front ? 0.12 : 0.09;
      c2.strokeStyle = rgba(255,255,255,0.16);
      c2.lineWidth = 1;
      const veins = 4 + (idx % 2);
      for(let i=-veins;i<=veins;i++){
        c2.beginPath();
        c2.moveTo(i*petW*0.10, -petH*0.97);
        c2.quadraticCurveTo(i*petW*0.08, -petH*0.58, i*petW*0.03, -petH*0.08);
        c2.stroke();
      }

      c2.globalAlpha = front ? 0.06 : 0.045;
      c2.fillStyle = rgba(255,255,255, 0.10);
      for(let k=0;k<18;k++){
        const px = (rnd()-0.5) * petW * 0.86;
        const py = -petH*(0.16 + rnd()*0.78);
        const pr = 0.55 + rnd()*1.05;
        c2.beginPath();
        c2.arc(px, py, pr, 0, TAU);
        c2.fill();
      }

      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = front ? 0.18 : 0.14;
      const fg = c2.createRadialGradient(0, -petH*0.40, petW*0.06, 0, -petH*0.38, petW*0.86);
      fg.addColorStop(0, rgba(deep.r,deep.g,deep.b,0.34));
      fg.addColorStop(1, rgba(0,0,0,0));
      c2.fillStyle = fg;
      c2.beginPath();
      c2.ellipse(0, -petH*0.40, petW*0.60, petH*0.38, 0, 0, TAU);
      c2.fill();

      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = front ? 0.06 : 0.045;
      const topGlow = c2.createLinearGradient(0, -petH*1.05, 0, -petH*0.70);
      topGlow.addColorStop(0, rgba(255,255,255,0.18));
      topGlow.addColorStop(1, rgba(255,255,255,0.00));
      c2.fillStyle = topGlow;
      c2.fill();

      c2.restore();
      c2.restore();
    };

    for(let i=0;i<4;i++){
      c2.save();
      const a = (-(spread*1.25) + i*(spread*0.85)) + (rnd()-0.5)*0.020;
      c2.rotate(a);
      c2.translate((i-1.5)*w*0.012*op, h*(0.070 + 0.014*op));
      c2.scale(1, 1.03 - op*0.06);
      fillPetal(false, i, 0.98);
      c2.restore();
    }

    c2.save();
    c2.globalCompositeOperation = 'multiply';
    const ig = c2.createRadialGradient(0, -h*0.30, w*0.06, 0, -h*0.22, w*1.20);
    ig.addColorStop(0, rgba(0,0,0,0));
    ig.addColorStop(1, rgba(0,0,0,0.42));
    c2.fillStyle = ig;
    c2.beginPath();
    c2.ellipse(0, -h*0.30, w*0.62, h*0.74, 0, 0, TAU);
    c2.fill();
    c2.restore();

    for(let i=0;i<4;i++){
      c2.save();
      const a = (-(spread*1.40) + i*(spread*0.95)) + (rnd()-0.5)*0.020;
      c2.rotate(a);
      c2.translate((i-1.5)*w*0.018*op, -h*(0.012 + 0.012*op));
      c2.scale(1, 1.06);
      fillPetal(true, 4+i, 1.00);
      c2.restore();
    }

    c2.save();
    c2.globalAlpha = 0.95;
    c2.fillStyle = rgba(50,170,105,0.92);
    c2.strokeStyle = rgba(255,255,255,0.06);
    c2.lineWidth = 1;
    for(let i=0;i<3;i++){
      const a = (-0.56 + i*0.56);
      c2.save();
      c2.rotate(a);
      c2.beginPath();
      c2.moveTo(-w*0.11, h*0.02);
      c2.quadraticCurveTo(0, -h*0.12, w*0.11, h*0.02);
      c2.quadraticCurveTo(0, h*0.16, -w*0.11, h*0.02);
      c2.closePath();
      c2.fill();
      c2.stroke();
      c2.restore();
    }
    c2.restore();

    c2.fillStyle = rgba(40,140,85,0.52);
    c2.beginPath();
    c2.ellipse(0, 0, w*0.18, h*0.10, 0, 0, TAU);
    c2.fill();

    c2.save();
    c2.globalAlpha = 0.28;
    c2.fillStyle = rgba(0,0,0,0.18);
    c2.beginPath();
    c2.ellipse(0, h*0.02, w*0.26, h*0.10, 0, 0, TAU);
    c2.fill();
    c2.restore();
  }

  function drawTulipBloom(w, h, col, seed, open){
    const spr = getBloomSprite(w, h, col, seed, open);
    ctx.drawImage(spr.canvas, -spr.ox, -spr.oy, spr.canvas.width / spr.ss, spr.canvas.height / spr.ss);
  }

  // ===== Bouquet =====
  const DESCS = [
    {dx:-0.30, hf:0.86, bs:0.92},
    {dx: 0.30, hf:0.88, bs:0.95},
    {dx:-0.12, hf:0.98, bs:1.00},
    {dx: 0.12, hf:0.98, bs:1.00},
    {dx:-0.44, hf:0.72, bs:0.84},
    {dx: 0.44, hf:0.74, bs:0.86},
    {dx: 0.00, hf:0.80, bs:0.90},
  ];

  // TODOS azules (mismo color para todos)
  const TULIP_BLUE = {r: 70, g: 150, b: 255};
  const COLORS = [TULIP_BLUE];

  let bouquet = [];

  function seedBouquet(){
    const cx = W*0.5;
    const baseY = H*0.93;
    const scaleBase = lerp(0.74, 1.12, clamp(Math.min(W, H)/820, 0, 1));
    const spread = Math.min(W*0.45, 240 + W*0.08);

    bouquet = DESCS.map((p,i)=>{
      const scale = scaleBase * p.bs;
      const bw = (40 + ((i%3)-1)*2) * scale;
      const bh = (86 + ((i%4)-2)*4) * scale;
      const twist = (i-3) * 0.018;

      return {
        i,
        x: cx + p.dx*spread,
        baseY,
        scale,
        height: (235 * scaleBase) * p.hf,
        phase: i*0.85,
        bw, bh,
        twist,
        col: TULIP_BLUE,
        seed: 1337 + i*101,
        open: 0.90 + (i % 4) * 0.03
      };
    });
  }

  function drawBouquet(t){
    drawGrass(t);

    const hx = W*0.5, hy = H*0.78;
    const hg = ctx.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
    hg.addColorStop(0, 'rgba(0,0,0,0)');
    hg.addColorStop(1, 'rgba(0,0,0,0.30)');
    ctx.fillStyle = hg;
    ctx.fillRect(0,0,W,H);

    const bush = ctx.createRadialGradient(W*0.5, H*0.95, 10, W*0.5, H*0.95, Math.min(W,H)*0.45);
    bush.addColorStop(0, 'rgba(65,150,95,0.16)');
    bush.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = bush;
    ctx.fillRect(0,0,W,H);

    const STEM = {r:55,g:155,b:92};
    const STEM2= {r:35,g:120,b:72};

    for(const f of bouquet){
      const sway = CONFIG.reduceMotion ? 0 : Math.sin(t*0.001*(0.9) + f.phase) * 0.22 * CONFIG.sway;
      const angle = sway + (f.x - W*0.5) * 0.0006;

      const baseX = f.x;
      const baseY = f.baseY;
      const topY  = baseY - f.height;

      const bloomX = baseX + Math.sin(angle) * 12 * f.scale;
      const bloomY = topY + Math.cos(angle) * 5 * f.scale;

      const cp1x = baseX + Math.sin(f.phase)*10*f.scale;
      const cp1y = baseY - f.height*0.40;
      const cp2x = baseX + Math.cos(f.phase*1.7)*16*f.scale;
      const cp2y = baseY - f.height*0.76;

      const leafMid1 = baseY - f.height*0.52;
      const leafMid2 = baseY - f.height*0.60;
      ctx.save();
      drawTulipLeaf(baseX, leafMid1, angle, f.scale*0.56, -1);
      drawTulipLeaf(baseX, leafMid2, angle, f.scale*0.50,  1);
      drawLeafSprig(baseX, baseY - f.height*0.56, angle, f.scale*0.52, -1);
      drawLeafSprig(baseX, baseY - f.height*0.64, angle, f.scale*0.46,  1);
      ctx.restore();

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const stemW = 7.0 * f.scale;

      const sg = ctx.createLinearGradient(baseX, baseY, bloomX, bloomY);
      sg.addColorStop(0.00, rgba(STEM2.r, STEM2.g, STEM2.b, 0.10));
      sg.addColorStop(0.10, rgba(STEM2.r, STEM2.g, STEM2.b, 0.45));
      sg.addColorStop(0.32, rgba(STEM.r,  STEM.g,  STEM.b,  0.95));
      sg.addColorStop(1.00, rgba(STEM.r,  STEM.g,  STEM.b,  0.95));

      ctx.strokeStyle = sg;
      ctx.lineWidth = stemW;

      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, bloomX, bloomY);
      ctx.stroke();

      const fadeH = 92 * f.scale;
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      const fg = ctx.createLinearGradient(0, baseY + 2, 0, baseY - fadeH);
      fg.addColorStop(0.00, 'rgba(0,0,0,0.90)');
      fg.addColorStop(0.55, 'rgba(0,0,0,0.22)');
      fg.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      ctx.strokeStyle = fg;
      ctx.lineWidth = stemW + 5.0 * f.scale;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, bloomX, bloomY);
      ctx.stroke();
      ctx.restore();

      ctx.restore();

      f.bloomX = bloomX;
      f.bloomY = bloomY;
      f.angle = angle + f.twist;
    }

    // flores arriba (ESTO ERA LO QUE TE FALTABA)
    for(const f of bouquet){
      ctx.save();
      ctx.translate(f.bloomX, f.bloomY);
      ctx.rotate(f.angle);
      ctx.shadowColor = `rgba(${f.col.r},${f.col.g},${f.col.b},0.16)`;
      ctx.shadowBlur = 10 + 12*f.scale;
      drawTulipBloom(f.bw, f.bh, f.col, f.seed, f.open);
      ctx.restore();
    }

    const knotX = W*0.5, knotY = H*0.935;
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath();
    ctx.ellipse(knotX, knotY, Math.min(110, W*0.20), 26, 0, 0, TAU);
    ctx.fill();
  }

  function resize(){
    DPR = Math.min(1.8, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    bloomCache.clear();

    rebuildSkyCache();
    seedStars();
    seedBouquet();
    seedSoil();
    seedGrass();
    rebuildGroundCache();

    for(const f of bouquet){
      getBloomSprite(f.bw, f.bh, f.col, f.seed, f.open);
    }

    selfTest();
  }
  window.addEventListener('resize', resize, {passive:true});

  // error visible si algo truena
  function ensureErr(){
    let el = document.getElementById('err');
    if(el) return el;
    el = document.createElement('div');
    el.id = 'err';
    el.style.cssText = 'position:fixed;left:12px;right:12px;bottom:12px;padding:10px 12px;border-radius:12px;background:rgba(0,0,0,0.65);color:#fff;font:12px/1.35 system-ui,Segoe UI,Roboto,sans-serif;z-index:9;display:none;white-space:pre-wrap';
    document.body.appendChild(el);
    return el;
  }
  window.addEventListener('error', (e)=>{
    const el = ensureErr();
    el.style.display = 'block';
    el.textContent = (e && (e.message || e.error)) ? String(e.message || e.error) : 'Error desconocido';
  });

  function selfTest(){
    console.assert(!!canvas && !!ctx, 'Canvas/ctx no disponibles');
    console.assert(Number.isFinite(W) && W>0 && Number.isFinite(H) && H>0, 'Canvas size invalido');
    console.assert(Array.isArray(stars) && stars.length>0, 'Stars no inicializadas');
    console.assert(Array.isArray(grass) && grass.length>0, 'Grass no inicializado');
    console.assert(grassAnim1.length>0 && grassAnim2.length>0, 'Grass anim no inicializado');
    console.assert(Array.isArray(soil) && soil.length>0, 'Soil no inicializado');
    console.assert(!!groundCache && groundCache.width>0, 'Ground cache no generado');
    console.assert(!!skyCache && skyCache.width>0, 'Sky cache no generado');
    console.assert(Array.isArray(bouquet) && bouquet.length===DESCS.length, 'Bouquet no se genero correctamente');

    console.assert(Array.isArray(COLORS) && COLORS.length===1, 'COLORS debe ser 1 (azul único)');
    console.assert(COLORS[0].b >= COLORS[0].r && COLORS[0].b >= COLORS[0].g, 'El color no parece azul');
  }

  resize();

  function frame(t){
    requestAnimationFrame(frame);
    drawSky(t);
    drawBouquet(t);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
