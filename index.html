<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Girasoles bajo estrellas</title>
  <style>
    :root{
      --bg1:#060714;
      --bg2:#0a0f2b;
      --bg3:#131b43;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(1100px 700px at 20% 10%, var(--bg3), var(--bg2), var(--bg1));
      touch-action: manipulation;
    }
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}

    /* Optional: tiny, non-intrusive hint that doesn't look like a "menu" */
    .hint{
      position:fixed;
      left:14px;
      bottom:14px;
      padding:8px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      color:rgba(255,255,255,.72);
      font: 12px/1.1 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      backdrop-filter: blur(8px);
      user-select:none;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Toca para plantar un girasol ðŸŒ»</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // Mobile-friendly: cap devicePixelRatio to reduce load on phones
  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rand  = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));
  const TAU = Math.PI*2;

  function rgba(r,g,b,a){ return `rgba(${r},${g},${b},${a})`; }

  // ===== CONFIG (sin menÃº, listo para telÃ©fono) =====
  const CONFIG = {
    sunflowerCount: 16,
    starCount: 180,
    twinkle: 0.9,
    sway: 0.55,           // movement of stems
    breeze: 0.45,         // horizontal drift
    vignette: 0.55,
    hintAutoHideMs: 3500, // hide hint after a few seconds
    reduceMotion: false,  // set true if you want static scene
  };

  // Auto-hide hint after first seconds or on first tap
  const hint = document.querySelector('.hint');
  let hintHidden = false;
  function hideHint(){
    if(hintHidden) return;
    hintHidden = true;
    hint.style.display = 'none';
  }
  setTimeout(hideHint, CONFIG.hintAutoHideMs);

  // Stars
  const stars = [];
  function seedStars(){
    stars.length = 0;
    const n = CONFIG.starCount;
    for(let i=0;i<n;i++){
      stars.push({
        x: Math.random(),
        y: Math.random(),
        r: rand(0.6, 1.9),
        a: rand(0.04, 0.25),
        p: rand(0, TAU),
        s: rand(0.25, 1.25),
        hue: rand(0,1),
      });
    }
  }
  seedStars();

  function drawBackground(t){
    ctx.clearRect(0,0,W,H);

    // star field
    for(const st of stars){
      const tw = CONFIG.reduceMotion ? 1 : (0.55 + 0.45*Math.sin(t*0.001*st.s + st.p) * CONFIG.twinkle);
      const alpha = st.a * (0.7 + 0.6*tw);
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(st.x*W, st.y*H, st.r, 0, TAU);
      // slightly tinted stars
      const cool = 210 + 25*Math.sin(st.hue*TAU);
      ctx.fillStyle = `hsla(${cool}, 70%, 92%, 1)`;
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // moon-ish glow
    const moonX = W*0.78, moonY = H*0.20;
    const mg = ctx.createRadialGradient(moonX, moonY, 10, moonX, moonY, Math.max(W,H)*0.35);
    mg.addColorStop(0, 'rgba(255,255,255,0.10)');
    mg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = mg;
    ctx.fillRect(0,0,W,H);

    // vignette
    const vg = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.9);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, `rgba(0,0,0,${clamp(CONFIG.vignette,0,1)})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);
  }

  // Sunflowers
  class Sunflower {
    constructor(x, groundY, scale){
      this.x = x;
      this.groundY = groundY;
      this.scale = scale;
      this.height = rand(170, 360) * scale;
      this.stemW = rand(5.0, 9.0) * scale;
      this.headR  = rand(30, 54) * scale;
      this.petals = randi(18, 28);
      this.lean = rand(-0.14, 0.14);
      this.phase = rand(0, TAU);
      this.speed = rand(0.6, 1.25);
      this.depth = rand(0.55, 1.0);
      this.seed  = Math.random();
      this.leafSide = Math.random()<0.5 ? -1 : 1;

      // colors
      this.petal = { r: 245, g: 198, b: 60 };
      this.petal2= { r: 235, g: 170, b: 35 };
      this.center= { r: 64, g: 40, b: 22 };
      this.center2={ r: 92, g: 58, b: 28 };
      this.stem  = { r: 52, g: 166, b: 92 };
      this.stem2 = { r: 34, g: 128, b: 70 };
      this.leaf  = { r: 55, g: 190, b: 110 };
    }

    draw(t){
      const sway = CONFIG.reduceMotion ? 0 : Math.sin(t*0.001*CONFIG.sway*this.speed + this.phase) * 0.22 * CONFIG.sway;
      const breeze = CONFIG.reduceMotion ? 0 : Math.sin(t*0.0007 + this.seed*9) * 0.12 * CONFIG.breeze;
      const angle = this.lean + sway + breeze;

      const baseX = this.x;
      const baseY = this.groundY;
      const topY = baseY - this.height;

      const cp1x = baseX + Math.sin(this.phase)*12*this.scale;
      const cp1y = baseY - this.height*0.38;
      const cp2x = baseX + Math.cos(this.phase*1.7)*18*this.scale;
      const cp2y = baseY - this.height*0.74;

      const headX = baseX + Math.sin(angle) * 18 * this.scale;
      const headY = topY + Math.cos(angle) * 6 * this.scale;

      // leaves first (behind)
      this.drawLeaf(baseX, baseY, angle, this.leafSide);
      this.drawLeaf(baseX, baseY, angle, -this.leafSide, true);

      // stem
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      const stemGrad = ctx.createLinearGradient(baseX, baseY, headX, headY);
      stemGrad.addColorStop(0, rgba(this.stem2.r, this.stem2.g, this.stem2.b, 0.95));
      stemGrad.addColorStop(1, rgba(this.stem.r, this.stem.g, this.stem.b, 0.95));
      ctx.strokeStyle = stemGrad;
      ctx.lineWidth = this.stemW;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, headX, headY);
      ctx.stroke();

      // subtle highlight
      ctx.strokeStyle = rgba(255,255,255,0.06);
      ctx.lineWidth = Math.max(1, this.stemW*0.28);
      ctx.beginPath();
      ctx.moveTo(baseX+1.2*this.scale, baseY);
      ctx.bezierCurveTo(cp1x+1.2*this.scale, cp1y, cp2x+1.2*this.scale, cp2y, headX+1.2*this.scale, headY);
      ctx.stroke();
      ctx.restore();

      // head (petals + center)
      this.drawHead(headX, headY, angle, t);
    }

    drawLeaf(baseX, baseY, angle, side, second=false){
      const attachY = baseY - this.height * (second ? 0.62 : 0.42);
      const attachX = baseX;
      const len = (second ? 110 : 150) * this.scale;
      const wid = (second ? 34 : 46) * this.scale;
      const leafAngle = angle + side * (second ? 0.42 : 0.56);
      const tipX = attachX + Math.cos(leafAngle) * len;
      const tipY = attachY - Math.sin(leafAngle) * len;

      ctx.save();
      const g = ctx.createLinearGradient(attachX, attachY, tipX, tipY);
      g.addColorStop(0, rgba(this.leaf.r, this.leaf.g, this.leaf.b, 0.78));
      g.addColorStop(1, rgba(this.stem2.r, this.stem2.g, this.stem2.b, 0.90));
      ctx.fillStyle = g;
      ctx.strokeStyle = rgba(255,255,255,0.07);
      ctx.lineWidth = 1;

      ctx.beginPath();
      const midX = (attachX + tipX)*0.5 + side * 18*this.scale;
      const midY = (attachY + tipY)*0.5 - 10*this.scale;
      ctx.moveTo(attachX, attachY);
      ctx.quadraticCurveTo(midX, midY, tipX, tipY);
      ctx.quadraticCurveTo(midX + side*wid*0.55, midY + wid*0.55, attachX, attachY);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // midrib
      ctx.strokeStyle = rgba(255,255,255,0.06);
      ctx.beginPath();
      ctx.moveTo(attachX, attachY);
      ctx.quadraticCurveTo(midX, midY, tipX, tipY);
      ctx.stroke();

      ctx.restore();
    }

    drawHead(x, y, angle, t){
      const r = this.headR;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // soft glow
      ctx.shadowColor = rgba(this.petal.r, this.petal.g, this.petal.b, 0.35);
      ctx.shadowBlur = 16 + 22*this.depth;

      // petals
      for(let i=0;i<this.petals;i++){
        const a = (i/this.petals)*TAU;
        ctx.save();
        ctx.rotate(a);

        const wig = CONFIG.reduceMotion ? 0 : Math.sin(t*0.002 + i*0.8 + this.phase) * 0.06;
        const petLen = r * (1.65 + 0.22*wig);
        const petWid = r * 0.55;

        const pg = ctx.createLinearGradient(0, 0, petLen, 0);
        pg.addColorStop(0, rgba(this.petal.r, this.petal.g, this.petal.b, 0.95));
        pg.addColorStop(1, rgba(this.petal2.r, this.petal2.g, this.petal2.b, 0.85));

        ctx.fillStyle = pg;
        ctx.strokeStyle = rgba(255,255,255,0.08);
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(r*0.10, 0);
        ctx.quadraticCurveTo(petLen*0.35, -petWid*0.60, petLen, 0);
        ctx.quadraticCurveTo(petLen*0.35,  petWid*0.60, r*0.10, 0);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.stroke();

        ctx.restore();
      }

      // center disc
      ctx.shadowBlur = 18 + 20*this.depth;
      const cg = ctx.createRadialGradient(0,0, r*0.10, 0,0, r*0.95);
      cg.addColorStop(0, rgba(this.center2.r, this.center2.g, this.center2.b, 0.95));
      cg.addColorStop(1, rgba(this.center.r, this.center.g, this.center.b, 0.98));
      ctx.fillStyle = cg;
      ctx.beginPath();
      ctx.arc(0,0, r*0.72, 0, TAU);
      ctx.fill();

      // seed spiral dots (cheap but effective)
      ctx.shadowBlur = 0;
      ctx.fillStyle = rgba(15, 10, 6, 0.28);
      const dots = randi(70, 120);
      for(let i=0;i<dots;i++){
        const theta = i * 0.35;
        const rr = (i/dots) * r*0.66;
        const dx = Math.cos(theta) * rr;
        const dy = Math.sin(theta) * rr;
        ctx.beginPath();
        ctx.arc(dx, dy, r*0.03 + (i%7===0? r*0.02:0), 0, TAU);
        ctx.fill();
      }

      // little highlight
      ctx.fillStyle = rgba(255,255,255,0.06);
      ctx.beginPath();
      ctx.arc(-r*0.18, -r*0.22, r*0.22, 0, TAU);
      ctx.fill();

      ctx.restore();
    }
  }

  function groundY(){
    return H - Math.min(64, Math.max(44, H*0.10));
  }

  let sunflowers = [];
  function plant(force){
    if(force) sunflowers = [];

    const target = CONFIG.sunflowerCount;
    while(sunflowers.length < target){
      const margin = 24;
      const x = rand(margin, W - margin);
      const y = groundY() + rand(-2, 2);
      const scale = rand(0.75, 1.35) * lerp(0.9, 1.12, Math.min(1, W/900));
      sunflowers.push(new Sunflower(x, y, scale));
    }
    while(sunflowers.length > target) sunflowers.pop();

    // layer by depth
    sunflowers.sort((a,b)=>a.depth-b.depth);
  }

  // initial
  plant(true);

  // Touch/click to plant an extra sunflower
  function plantOne(clientX){
    const margin = 24;
    const x = clamp(clientX, margin, W - margin);
    const y = groundY();
    const scale = rand(0.8, 1.35) * lerp(0.9, 1.12, Math.min(1, W/900));
    sunflowers.push(new Sunflower(x, y, scale));
    // soft cap to keep phones happy
    const cap = CONFIG.sunflowerCount + 10;
    if(sunflowers.length > cap) sunflowers.splice(0, sunflowers.length - cap);
    sunflowers.sort((a,b)=>a.depth-b.depth);
  }

  canvas.addEventListener('pointerdown', (e)=>{
    hideHint();
    plantOne(e.clientX);
  }, { passive:true });

  // Optional: space pauses, R replants (desktop)
  let running = true;
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){ e.preventDefault(); running = !running; hideHint(); }
    if(e.key.toLowerCase() === 'r'){ plant(true); hideHint(); }
  });

  // Gentle ground haze
  function drawGround(){
    const y = groundY();
    const gh = ctx.createLinearGradient(0, H, 0, y - 220);
    gh.addColorStop(0, 'rgba(0,0,0,0.70)');
    gh.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gh;
    ctx.fillRect(0, y - 260, W, 260);

    // faint ground line
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, y+3);
    ctx.lineTo(W, y+3);
    ctx.stroke();
  }

  let lastT = 0;
  function frame(t){
    requestAnimationFrame(frame);
    drawBackground(t);
    drawGround();

    // keep base count steady
    plant(false);

    if(!running){
      for(const s of sunflowers) s.draw(0);
      return;
    }

    // avoid huge jumps
    const dt = Math.min(60, t - lastT);
    lastT = t;

    for(const s of sunflowers){
      s.draw(t);
    }
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
