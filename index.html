<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ramo de tulipanes rosados (noche)</title>
  <style>
    :root{
      --bg1:#070814;
      --bg2:#0b1030;
      --bg3:#151a40;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(900px 650px at 50% 10%, var(--bg3), var(--bg2), var(--bg1));
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

<script>
(() => {
  'use strict';

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  let HAS_FILTER = false; try{ ctx.filter = 'none'; HAS_FILTER = (typeof ctx.filter !== 'undefined'); }catch(_){ HAS_FILTER = false; }

  let W = 0, H = 0, DPR = 1;

  const TAU = Math.PI * 2;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rgba  = (r,g,b,a)=>`rgba(${r},${g},${b},${a})`;

  // Campo de viento global (compartido por pasto y tulipanes)
  const windField = (t) => {
    if(CONFIG.reduceMotion) return 0;
    // combinación lenta (natural y suave)
    return (Math.sin(t*0.00055)*0.78 + Math.sin(t*0.00023 + 1.7)*0.34);
  };

  const shuffleInPlace = (arr) => {
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  };

  const makePRNG = (seed) => {
    let s = (seed >>> 0) || 1;
    return () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);
  };

  const CONFIG = {
    stars: 240,
    twinkle: 0.80,
    sway: 0.28,
    reduceMotion: false,
    shootingStars: 1,

    // 0..1: “corona/picos” (arriba del tulipán). 0 = casi lisa
    crownStrength: 0.008,

    // Texto “en estrellas”
    starText: 'For you <3',
    starTextStrength: 0.95
  };

  try{
    const m = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
    if(m && m.matches) CONFIG.reduceMotion = true;
  }catch(_){}

  // ===== Stars =====
  const stars = [];
  const starLinks = [];
  const textStars = [];
  const tapSparkles = [];

  // Luz “luna” coherente (arriba-derecha)
  const LIGHT = { x: 0.82, y: 0.14 };
  const LIGHT_DIR = (() => {
    const dx = 0.74, dy = -0.52;
    const inv = 1 / Math.max(1e-6, Math.hypot(dx,dy));
    return { x: dx*inv, y: dy*inv };
  })();

  const shooting = { active:false, t0:0, dur:0, x0:0,y0:0, x1:0,y1:0 };

  function seedStars(){
    stars.length = 0;
    starLinks.length = 0;

    const clusters = [
      {cx: 0.28, cy: 0.20, r: 0.18},
      {cx: 0.72, cy: 0.16, r: 0.20},
      {cx: 0.52, cy: 0.30, r: 0.16},
    ];

    const mwBand = () => {
      const t = Math.random();
      const x = lerp(0.14, 0.92, t);
      const y = lerp(0.48, 0.20, t);
      const off = (Math.random()-0.5) * 0.10;
      return { x: clamp(x + off*0.90, 0, 1), y: clamp(y + off*(-0.55), 0, 1) };
    };

    const pick = () => {
      const r = Math.random();
      if(r < 0.62){
        const x = Math.random();
        const y = Math.pow(Math.random(), 1.55);
        return {x, y};
      }
      if(r < 0.78) return mwBand();

      const c = clusters[(Math.random()*clusters.length)|0];
      const a = Math.random()*TAU;
      const rr = Math.sqrt(Math.random()) * c.r;
      return { x: clamp(c.cx + Math.cos(a)*rr, 0, 1), y: clamp(c.cy + Math.sin(a)*rr, 0, 1) };
    };

    for(let i=0;i<CONFIG.stars;i++){
      const p = pick();
      const yBias = Math.pow(1 - p.y, 1.8);

      const roll = Math.random();
      const big = roll < (0.035 + 0.020*yBias);
      const mid = !big && roll < (0.18 + 0.05*yBias);

      const rBase = big ? (2.2 + Math.random()*3.0)
                  : (mid ? (1.2 + Math.random()*1.4) : (0.55 + Math.random()*0.95));
      const aBase = big ? (0.18 + Math.random()*0.28)
                  : (mid ? (0.10 + Math.random()*0.16) : (0.05 + Math.random()*0.12));

      let hue = 0;
      const temp = Math.random();
      if(temp < 0.10) hue = 205 + Math.random()*35;
      else if(temp < 0.16) hue = 35 + Math.random()*18;
      else if(big && temp < 0.45) hue = 200 + Math.random()*60;

      stars.push({
        x: p.x, y: p.y,
        z: big ? 0.92 : (mid ? 0.68 : (0.35 + Math.random()*0.35)),
        r: rBase, a: aBase,
        p: Math.random()*TAU,
        s: (0.25 + Math.random()*0.95),
        hue,
        flare: big ? (0.55 + Math.random()*0.45) : (mid ? (0.18 + Math.random()*0.35) : 0),
        tw: big ? (0.45 + Math.random()*0.40) : (mid ? (0.30 + Math.random()*0.30) : (0.18 + Math.random()*0.22))
      });
    }

    buildConstellations();

    shooting.active = false;
    shooting.t0 = 0;
    shooting.dur = 0;
  }

  function buildConstellations(){
    starLinks.length = 0;
    if(stars.length < 6) return;

    // Conectamos algunas estrellas brillantes en "constelaciones" sutiles (sin volverlo un mapa de metro)
    const ids = stars
      .map((s,i)=>({i, score: s.r * (0.85 + s.a)}))
      .sort((a,b)=>b.score-a.score)
      .slice(0, 18)
      .map(o=>o.i);

    const maxDist = 0.13;
    const used = new Set();

    for(const i of ids){
      let best1=-1,best2=-1;
      let d1=1e9,d2=1e9;

      for(const j of ids){
        if(j===i) continue;
        const dx = stars[i].x - stars[j].x;
        const dy = stars[i].y - stars[j].y;
        const d = Math.hypot(dx,dy);
        if(d > maxDist) continue;

        if(d < d1){ d2=d1; best2=best1; d1=d; best1=j; }
        else if(d < d2){ d2=d; best2=j; }
      }

      const add = (j, dist) => {
        if(j < 0 || !Number.isFinite(dist)) return;
        const a = Math.max(0.016, 0.055 - dist*0.22);
        const key = i<j ? `${i}-${j}` : `${j}-${i}`;
        if(used.has(key)) return;
        used.add(key);
        starLinks.push({i, j, a});
      };

      add(best1, d1);
      add(best2, d2);
    }
  }


  function maybeStartShootingStar(t){
    if(CONFIG.reduceMotion || !CONFIG.shootingStars) return;
    if(shooting.active) return;

    if(Math.random() < 0.0022){
      shooting.active = true;
      shooting.t0 = t;
      shooting.dur = 900 + Math.random()*900;

      const startX = Math.random()*W*0.90;
      const startY = Math.random()*H*0.35;
      const dx = (120 + Math.random()*220);
      const dy = (40 + Math.random()*120);

      shooting.x0 = startX; shooting.y0 = startY;
      shooting.x1 = startX + dx; shooting.y1 = startY + dy;
    }
  }

  function drawShootingStar(t){
    if(!shooting.active) return;

    const u = clamp((t - shooting.t0) / shooting.dur, 0, 1);
    const ease = u*u*(3-2*u);

    const x = lerp(shooting.x0, shooting.x1, ease);
    const y = lerp(shooting.y0, shooting.y1, ease);

    const tail = 120;
    const ang = Math.atan2(shooting.y1 - shooting.y0, shooting.x1 - shooting.x0);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = (1-u) * 0.85;

    const tx = x - Math.cos(ang)*tail;
    const ty = y - Math.sin(ang)*tail;

    const g = ctx.createLinearGradient(tx, ty, x, y);
    g.addColorStop(0, 'rgba(255,255,255,0)');
    g.addColorStop(0.55, 'rgba(255,255,255,0.14)');
    g.addColorStop(1, 'rgba(255,255,255,0.85)');

    ctx.strokeStyle = g;
    ctx.lineWidth = 2.0;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(x, y);
    ctx.stroke();

    ctx.globalAlpha = (1-u) * 0.95;
    ctx.shadowColor = 'rgba(255,255,255,0.8)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x,y, 1.8, 0, TAU);
    ctx.fill();

    ctx.restore();

    if(u >= 1) shooting.active = false;
  }

  // ===== Césped =====
  const grass = [];
  const soil = [];
  const grassAnim1 = [];
  const grassAnim2 = [];

  let groundCache = null;
  let skyCache = null;
  const bloomCache = new Map();

  function seedSoil(){
    soil.length = 0;
    const gy = H * 0.74;
    const groundH = H - gy;

    const blobs = clamp(Math.floor(W / 160), 6, 12);
    for(let i=0;i<blobs;i++){
      soil.push({
        x: W*(0.05 + Math.random()*0.90),
        y: gy + groundH*(0.25 + Math.random()*0.75),
        r: (90 + Math.random()*220),
        a: (0.08 + Math.random()*0.12)
      });
    }
  }

  function seedGrass(){
    grass.length = 0;

    const gy = H * 0.74;
    const groundH = H - gy;

    const tufts = clamp(Math.floor(W / 14), 42, 110);
    const bladesBase = 10;
    const bladesExtra = 10;

    for(let t=0;t<tufts;t++){
      const tx = (t + Math.random()*0.85) * (W / tufts);
      const tuftSeed = Math.random()*TAU;
      const count = bladesBase + Math.floor(Math.random()*bladesExtra);

      for(let i=0;i<count;i++){
        const r = Math.random();
        const layer = (r < 0.52) ? 0 : (r < 0.86 ? 1 : 2);

        const baseBand = layer===2 ? 0.72 : (layer===1 ? 0.64 : 0.56);
        const ty = gy + groundH*(baseBand + Math.random()*(1-baseBand));

        const jitterX = (Math.random()-0.5) * (12 + layer*22);
        const jitterY = (Math.random()-0.5) * (6 + layer*10);

        const hBase = layer===2 ? 84 : (layer===1 ? 62 : 44);
        const hVar  = layer===2 ? 98 : (layer===1 ? 72 : 54);

        const curlAmp = layer===2 ? 0.65 : (layer===1 ? 0.55 : 0.45);

        grass.push({
          layer,
          x: tx + jitterX,
          y: ty + jitterY,
          h: hBase + Math.random()*hVar,
          w: (layer===2 ? 1.55 : (layer===1 ? 1.05 : 0.78)) + Math.random()*(layer===2 ? 1.55 : (layer===1 ? 1.10 : 0.90)),
          p: tuftSeed + i*0.52 + Math.random()*0.85,
          s: (layer===2 ? 0.72 : (layer===1 ? 0.90 : 0.66)) + Math.random()*(layer===2 ? 1.05 : (layer===1 ? 1.05 : 1.00)),
          a: (layer===2 ? 0.18 : (layer===1 ? 0.14 : 0.11)) + Math.random()*(layer===2 ? 0.22 : (layer===1 ? 0.18 : 0.14)),
          bend: (layer===2 ? 1.35 : (layer===1 ? 1.10 : 0.95)) + Math.random()*0.35,
          curl: (Math.random()-0.5) * curlAmp,
          thick: layer===2 ? (0.55 + Math.random()*0.85) : 0,
          tip: 0.75 + Math.random()*0.9
        });
      }
    }

    grassAnim1.length = 0;
    grassAnim2.length = 0;

    const g1 = [];
    const g2 = [];
    for(const b of grass){
      if(b.layer === 1) g1.push(b);
      else if(b.layer === 2) g2.push(b);
    }

    shuffleInPlace(g1);
    shuffleInPlace(g2);

    const max1 = clamp(Math.floor(W * 0.55), 200, 650);
    const max2 = clamp(Math.floor(W * 0.40), 160, 520);

    grassAnim1.push(...g1.slice(0, max1));
    grassAnim2.push(...g2.slice(0, max2));
  }

  function rebuildGroundCache(){
    const off = document.createElement('canvas');
    off.width = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const gy = H * 0.74;
    const groundH = H - gy;

    const gg = g.createLinearGradient(0, gy, 0, H);
    gg.addColorStop(0, 'rgba(8,14,10,0.05)');
    gg.addColorStop(0.22, 'rgba(16,44,28,0.28)');
    gg.addColorStop(0.66, 'rgba(8,22,16,0.60)');
    gg.addColorStop(1, 'rgba(0,0,0,0.78)');
    g.fillStyle = gg;
    g.fillRect(0, gy, W, groundH);

    // variación de tono (parches) para evitar banda plana
    for(let i=0;i<8;i++){
      const x = Math.random()*W;
      const y = gy + Math.random()*groundH;
      const r = 120 + Math.random()*260;
      const pg = g.createRadialGradient(x,y, 10, x,y, r);
      pg.addColorStop(0, `rgba(${18+Math.random()*10|0},${70+Math.random()*50|0},${40+Math.random()*30|0},0.10)`);
      pg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = pg;
      g.fillRect(0, gy-20, W, groundH+40);
    }


    for(const b of soil){
      const rg = g.createRadialGradient(b.x, b.y, 8, b.x, b.y, b.r);
      rg.addColorStop(0, `rgba(25,85,48,${b.a})`);
      rg.addColorStop(0.55, `rgba(12,40,24,${b.a*0.55})`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = rg;
      g.fillRect(0,0,W,H);
    }

    g.save();
    g.globalAlpha = 0.10;
    g.fillStyle = 'rgba(255,255,255,0.08)';
    const dots = clamp(Math.floor(W * groundH / 1800), 180, 420);
    for(let i=0;i<dots;i++){
      const x = Math.random()*W;
      const y = gy + Math.random()*groundH;
      const r = 0.6 + Math.random()*1.4;
      g.beginPath();
      g.arc(x,y,r,0,TAU);
      g.fill();
    }
    g.restore();

    const drawStaticBlade = (b, front) => {
      const x0 = b.x, y0 = b.y;
      const len = b.h;
      const tilt = b.curl*0.18;

      const x1 = x0 + tilt * (10 + b.bend*5);
      const y1 = y0 - len;

      const cx = x0 + tilt * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      g.strokeStyle = front ? 'rgba(24,105,62,1)' : 'rgba(16,75,44,1)';
      g.lineWidth = b.w * (front ? 1.10 : 1.0);
      g.beginPath();
      g.moveTo(x0, y0);
      g.quadraticCurveTo(cx, cy, x1, y1);
      g.stroke();

      const old = g.globalAlpha;
      g.globalAlpha = old * (front ? 0.22 : 0.16);
      g.strokeStyle = 'rgba(190,255,220,1)';
      g.lineWidth = Math.max(0.7, b.w*0.30);
      g.beginPath();
      g.moveTo(x0 + 0.7, y0);
      g.quadraticCurveTo(cx + 0.5, cy, x1 + 0.3, y1);
      g.stroke();
      g.globalAlpha = old;
    };

    g.save();
    for(const b of grass){
      if(b.layer !== 0) continue;
      g.globalAlpha = 0.18 + b.a*0.90;
      drawStaticBlade(b, false);
    }
    g.restore();

    g.save();
    for(const b of grass){
      if(b.layer !== 1) continue;
      if(b.h > 90) continue;
      g.globalAlpha = 0.16 + b.a*0.80;
      drawStaticBlade(b, true);
    }
    g.restore();

    const fogTop = gy + groundH*0.18;
    const fog = g.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(1, 'rgba(0,0,0,0.34)');
    g.fillStyle = fog;
    g.fillRect(0, fogTop, W, H - fogTop);

    groundCache = off;
  }

  function drawGrass(t){
    if(groundCache){
      ctx.drawImage(groundCache, 0, 0, groundCache.width / DPR, groundCache.height / DPR);
    }

    const gy = H * 0.74;
    const groundH = H - gy;

    const wind = windField(t) * 0.75;

    const drawBlade = (b, front) => {
      const xN = (b.x / W) - 0.5;
      const gWind = CONFIG.reduceMotion ? 0 : (Math.sin(t*0.00062)*0.92 + Math.sin(t*0.00114)*0.32);
      const gust  = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00035 + xN*2.8) * 0.22;
      const micro = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00120*b.s + b.p) * 0.08;
      const sway  = (gWind*0.55 + gust + micro) * 0.22 * CONFIG.sway;
      const sway2 = CONFIG.reduceMotion ? 0 : Math.sin(t*0.00135*b.s + b.p*0.7) * 0.08;

      const x0 = b.x;
      const y0 = b.y;
      const len = b.h;

      const tilt = (sway + wind + b.curl*0.22);
      const x1 = x0 + tilt * (9 + b.bend*6);
      const y1 = y0 - len;

      const cx = x0 + (tilt + sway2) * (7 + b.bend*4);
      const cy = y0 - len*(0.58 + (front ? 0.05 : 0));

      if(front){
        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.18;
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        ctx.beginPath();
        ctx.ellipse(x0, y0+1.2, 3.2 + b.w, 1.2 + b.w*0.34, 0, 0, TAU);
        ctx.fill();
        ctx.globalAlpha = old;
      }

      if(b.layer === 2){
        const w0 = b.w * (1.00 + b.thick);
        const w1 = Math.max(0.8, w0 * 0.16);

        const t0x = x0, t0y = y0;
        const t1x = cx, t1y = cy;
        const t2x = x1, t2y = y1;

        const dx = t2x - t0x;
        const dy = t2y - t0y;
        const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
        const px = -dy * inv;
        const py =  dx * inv;

        const lg = ctx.createLinearGradient(x0, y0, x1, y1);
        lg.addColorStop(0, 'rgba(10,55,32,0.88)');
        lg.addColorStop(0.55, 'rgba(28,118,68,0.78)');
        lg.addColorStop(1, 'rgba(115,220,150,0.56)');

        ctx.save();
        ctx.fillStyle = lg;

        ctx.beginPath();
        ctx.moveTo(t0x + px*w0, t0y + py*w0);
        ctx.quadraticCurveTo(t1x + px*(w0*0.60), t1y + py*(w0*0.60), t2x + px*w1, t2y + py*w1);
        ctx.lineTo(t2x - px*w1, t2y - py*w1);
        ctx.quadraticCurveTo(t1x - px*(w0*0.52), t1y - py*(w0*0.52), t0x - px*w0, t0y - py*w0);
        ctx.closePath();
        ctx.fill();

        const old = ctx.globalAlpha;
        ctx.globalAlpha = old * 0.24;
        ctx.strokeStyle = 'rgba(215,255,235,0.32)';
        ctx.lineWidth = Math.max(0.8, b.w*0.34);
        ctx.beginPath();
        ctx.moveTo(x0 + px*0.4, y0 + py*0.4);
        ctx.quadraticCurveTo(cx + px*0.2, cy + py*0.2, x1 + px*0.10, y1 + py*0.10);
        ctx.stroke();
        ctx.globalAlpha = old;

        ctx.restore();
      }

      ctx.strokeStyle = front ? 'rgba(22,98,58,1)' : 'rgba(18,72,42,1)';
      ctx.lineWidth = b.w * (front ? 1.12 : 1.0);
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();

      const old = ctx.globalAlpha;
      ctx.globalAlpha = old * (front ? 0.22 : 0.16);
      ctx.strokeStyle = 'rgba(190,255,220,1)';
      ctx.lineWidth = Math.max(0.7, b.w*0.30);
      ctx.beginPath();
      ctx.moveTo(x0 + 0.8, y0);
      ctx.quadraticCurveTo(cx + 0.55, cy, x1 + 0.35, y1);
      ctx.stroke();
      ctx.globalAlpha = old;
    };

    ctx.save();
    for(const b of grassAnim1){
      ctx.globalAlpha = 0.16 + b.a*0.92;
      drawBlade(b, false);
    }
    ctx.restore();

    ctx.save();
    for(const b of grassAnim2){
      ctx.globalAlpha = 0.22 + b.a*0.98;
      drawBlade(b, true);
    }
    ctx.restore();


    // Bruma del horizonte: ayuda a que el césped no se vea "pegado" y disimula el corte con los tallos
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const hzTop = gy - 90;
    const hzBot = gy + 40;
    const hz = ctx.createLinearGradient(0, hzTop, 0, hzBot);
    hz.addColorStop(0, 'rgba(120,150,220,0)');
    hz.addColorStop(0.35, 'rgba(120,150,220,0.07)');
    hz.addColorStop(0.70, 'rgba(90,120,200,0.04)');
    hz.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = hz;
    ctx.fillRect(0, hzTop, W, hzBot - hzTop);
    ctx.restore();

    ctx.save();
    const thatchTop = gy + groundH*0.74;
    const tg = ctx.createLinearGradient(0, thatchTop, 0, H);
    tg.addColorStop(0, 'rgba(0,0,0,0)');
    tg.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = tg;
    ctx.fillRect(0, thatchTop, W, H - thatchTop);
    ctx.restore();
    if(!CONFIG.reduceMotion){
      ctx.save();
      ctx.globalAlpha = 0.05;
      ctx.fillStyle = 'rgba(220,255,240,0.18)';
      const drops = 16;
      for(let i=0;i<drops;i++){
        const x = W*(0.18 + Math.random()*0.64);
        const y = (gy + groundH*0.25) + Math.random()*(groundH*0.70);
        ctx.beginPath();
        ctx.arc(x,y, 0.9 + Math.random()*1.2, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  // ===== Texto hecho con estrellas =====
  function buildStarText(){
    textStars.length = 0;

    const sMin = Math.min(W, H);
    const fontSize = clamp(sMin * 0.09, 26, 58);

    const tc = document.createElement('canvas');
    tc.width = Math.floor(W);
    tc.height = Math.floor(H);
    const g = tc.getContext('2d', {alpha:true});

    const x = tc.width * 0.5;
    const y = tc.height * 0.28;

    g.clearRect(0,0,tc.width,tc.height);
    g.textAlign = 'center';
    g.textBaseline = 'middle';
    g.font = `700 ${Math.round(fontSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    g.fillStyle = 'rgba(255,255,255,1)';
    g.fillText(CONFIG.starText, x, y);

    const img = g.getImageData(0,0,tc.width,tc.height).data;

    const step = clamp(Math.round(fontSize / 7.2), 3, 7);
    const maxPts = clamp(Math.floor((W*H)/1300), 700, 1700);

    const pr = makePRNG((W*73856093) ^ (H*19349663) ^ 0xC0FFEE);

    const minX = Math.max(0, Math.floor(x - tc.width*0.45));
    const maxX = Math.min(tc.width-1, Math.floor(x + tc.width*0.45));
    const minY = Math.max(0, Math.floor(y - fontSize*1.2));
    const maxY = Math.min(tc.height-1, Math.floor(y + fontSize*1.0));

    const candidates = [];
    for(let yy=minY; yy<=maxY; yy+=step){
      for(let xx=minX; xx<=maxX; xx+=step){
        const idx = (yy*tc.width + xx)*4 + 3;
        const a = img[idx];
        if(a > 20){
          candidates.push({x: xx/tc.width, y: yy/tc.height, a: a/255});
        }
      }
    }

    shuffleInPlace(candidates);
    const chosen = candidates.slice(0, maxPts);

    for(const p of chosen){
      const sizeJ = pr();
      const r = (0.65 + sizeJ*1.25) * (fontSize/46);
      const alpha = (0.10 + p.a*0.35) * CONFIG.starTextStrength;

      const temp = pr();
      let hue = 0;
      if(temp < 0.20) hue = 205 + pr()*30;
      else if(temp < 0.28) hue = 35 + pr()*16;

      textStars.push({
        x: p.x, y: p.y,
        r,
        a: alpha,
        p: pr()*TAU,
        s: 0.55 + pr()*1.05,
        hue,
        flare: (pr() < 0.12) ? (0.15 + pr()*0.35) : 0
      });
    }

    // halo disperso alrededor del texto: suaviza bordes y lo integra al cielo
    const haloBudget = Math.min(28, Math.max(10, Math.floor(textStars.length * 0.20)));
    for(let i=0;i<haloBudget;i++){
      const b = textStars[(Math.random()*textStars.length)|0];
      const hx = clamp(b.x + (Math.random()*2-1)*0.032, 0.02, 0.98);
      const hy = clamp(b.y + (Math.random()*2-1)*0.020, 0.02, 0.60);

      textStars.push({
        x: hx, y: hy,
        r: b.r * (0.55 + Math.random()*0.25),
        a: b.a * (0.22 + Math.random()*0.18),
        tw: b.tw * (0.65 + Math.random()*0.25),
        p: Math.random()*TAU*3
      });
    }

  }

  function drawStarText(t){
    if(!textStars.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    const gx = W*0.5, gy = H*0.28;
    const fontHint = clamp(Math.min(W,H)*0.09, 26, 58);
    const glow = ctx.createRadialGradient(gx, gy, 10, gx, gy, fontHint*7.5);
    glow.addColorStop(0, 'rgba(210,230,255,0.09)');
    glow.addColorStop(1, 'rgba(210,230,255,0)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = glow;
    ctx.fillRect(0,0,W,H);

    for(const st of textStars){
      const tw = CONFIG.reduceMotion ? 1 : (0.78 + 0.22*Math.sin(t*0.0012*st.s + st.p));
      const alpha = st.a * (0.75 + 0.55*tw);

      const x = st.x*W;
      const y = st.y*H;

      ctx.globalAlpha = alpha;
      ctx.shadowColor = 'rgba(255,255,255,0.55)';
      ctx.shadowBlur = 9 + st.r*6;

      ctx.fillStyle = st.hue ? `hsla(${st.hue}, 75%, 92%, 1)` : 'rgba(255,255,255,1)';
      ctx.beginPath();
      ctx.arc(x, y, st.r, 0, TAU);
      ctx.fill();

      if(st.flare){
        ctx.save();
        ctx.shadowBlur = 0;
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = alpha * 0.40 * st.flare;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        const k = 3.0 + st.r*2.0;
        ctx.beginPath();
        ctx.moveTo(x-k, y); ctx.lineTo(x+k, y);
        ctx.moveTo(x, y-k); ctx.lineTo(x, y+k);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }

  // ===== Cielo (cache) =====

  const _spA = {x:0,y:0};
  const _spB = {x:0,y:0};

  function starPos(st, t, out){
    const z = (st.z ?? 0.55);
    if(CONFIG.reduceMotion){
      out.x = st.x * W;
      out.y = st.y * H;
      return out;
    }
    const px = (Math.sin(t*0.00009 + st.p) * 5 + Math.sin(t*0.00023 + st.p*0.7) * 2) * z;
    const py = (Math.cos(t*0.00008 + st.p*1.1) * 4 + Math.sin(t*0.00019 + st.p*0.5) * 1.5) * z;
    out.x = st.x * W + px;
    out.y = st.y * H + py;
    return out;
  }

  function drawConstellations(t){
    if(!starLinks.length) return;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = 'rgba(200,220,255,1)';

    for(const L of starLinks){
      const a = stars[L.i];
      const b = stars[L.j];
      starPos(a, t, _spA);
      starPos(b, t, _spB);

      // Mantén las líneas en la parte alta del cielo (para no ensuciar el ramo)
      if(_spA.y > H*0.62 || _spB.y > H*0.62) continue;

      ctx.globalAlpha = L.a;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(_spA.x, _spA.y);
      ctx.lineTo(_spB.x, _spB.y);
      ctx.stroke();
    }

    ctx.restore();
  }


  function rebuildSkyCache(){
    const off = document.createElement('canvas');
    off.width  = Math.floor(W * DPR);
    off.height = Math.floor(H * DPR);

    const g = off.getContext('2d', {alpha:true});
    g.setTransform(DPR,0,0,DPR,0,0);

    const sky = g.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, 'rgba(12,14,46,1)');
    sky.addColorStop(0.40, 'rgba(7,9,24,1)');
    sky.addColorStop(1, 'rgba(3,3,10,1)');
    g.fillStyle = sky;
    g.fillRect(0,0,W,H);


    // Luna suave (solo para dar dirección de luz, no para robarse el show)
    const moonX = W * LIGHT.x;
    const moonY = H * LIGHT.y;
    const moonR = Math.min(W,H) * 0.055;

    const halo = g.createRadialGradient(moonX, moonY, moonR*0.25, moonX, moonY, moonR*6.0);
    halo.addColorStop(0, 'rgba(255,255,255,0.18)');
    halo.addColorStop(0.22, 'rgba(210,230,255,0.08)');
    halo.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = halo;
    g.fillRect(0,0,W,H);

    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.85;
    g.fillStyle = 'rgba(245,250,255,0.85)';
    g.beginPath();
    g.arc(moonX, moonY, moonR, 0, TAU);
    g.fill();
    g.globalAlpha = 0.12;
    g.fillStyle = 'rgba(0,0,0,0.55)';
    // cráteres sutiles
    for(let i=0;i<6;i++){
      const a = Math.random()*TAU;
      const rr = moonR*(0.12 + Math.random()*0.28);
      const cx = moonX + Math.cos(a)*moonR*0.35;
      const cy = moonY + Math.sin(a)*moonR*0.28;
      g.beginPath();
      g.arc(cx, cy, rr, 0, TAU);
      g.fill();
    }
    g.restore();


    const neb = (x,y,r, a, cr,cg,cb) => {
      const gg = g.createRadialGradient(x,y, 10, x,y, r);
      gg.addColorStop(0, rgba(cr,cg,cb,a));
      gg.addColorStop(0.55, rgba(cr,cg,cb,a*0.26));
      gg.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = gg;
      g.fillRect(0,0,W,H);
    };
    neb(W*0.16, H*0.15, Math.max(W,H)*0.66, 0.09, 120,150,255);
    neb(W*0.82, H*0.20, Math.max(W,H)*0.60, 0.08, 160,120,255);
    neb(W*0.55, H*0.10, Math.max(W,H)*0.52, 0.06, 90,170,255);

    g.save();
    g.translate(W*0.56, H*0.34);
    g.rotate(-0.36);
    const mw = Math.max(W,H)*1.25;
    const mh = Math.max(W,H)*0.24;

    const mg = g.createRadialGradient(0,0, mh*0.03, 0,0, mh);
    mg.addColorStop(0, 'rgba(255,255,255,0.095)');
    mg.addColorStop(0.55, 'rgba(190,210,255,0.040)');
    mg.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = mg;
    g.beginPath();
    g.ellipse(0,0, mw*0.56, mh, 0, 0, TAU);
    g.fill();

    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.38;
    const dust = clamp(Math.floor((W*H)/8500), 160, 460);
    const prDust = makePRNG((W*2654435761) ^ (H*2246822519));
    for(let i=0;i<dust;i++){
      const dx = (prDust()-0.5) * mw*0.85;
      const dy = (prDust()-0.5) * mh*0.55;
      const rr = 0.6 + prDust()*1.9;
      g.fillStyle = 'rgba(255,255,255,0.11)';
      g.beginPath();
      g.arc(dx, dy, rr, 0, TAU);
      g.fill();
    }
    g.restore();

    g.save();
    g.globalCompositeOperation = 'screen';
    const pr = makePRNG((W*73856093) ^ (H*19349663) ^ 0xA53);
    const count = clamp(Math.floor((W*H)/2600), 520, 1500);
    for(let i=0;i<count;i++){
      const x = pr()*W;
      const y = Math.pow(pr(), 1.62) * (H*0.74);
      const a = 0.025 + pr()*0.085;
      const r = (pr()<0.90) ? (0.55 + pr()*0.85) : (0.95 + pr()*1.25);
      const warm = pr() < 0.18;
      g.fillStyle = warm ? `rgba(255,245,230,${a})` : `rgba(210,230,255,${a})`;
      g.beginPath();
      g.arc(x, y, r, 0, TAU);
      g.fill();
    }
    g.restore();

    const mx = W*0.80, my = H*0.14;
    const moon = g.createRadialGradient(mx, my, 10, mx, my, Math.max(W,H)*0.55);
    moon.addColorStop(0, 'rgba(245,250,255,0.12)');
    moon.addColorStop(0.35, 'rgba(210,225,255,0.06)');
    moon.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = moon;
    g.fillRect(0,0,W,H);

    const hz = g.createLinearGradient(0, H*0.56, 0, H*0.80);
    hz.addColorStop(0, 'rgba(120,150,255,0)');
    hz.addColorStop(1, 'rgba(90,120,210,0.06)');
    g.fillStyle = hz;
    g.fillRect(0,0,W,H);

    // Glow difuminado detrás del texto
    const sMin = Math.min(W, H);
    const fontSize = clamp(sMin * 0.09, 26, 58);
    g.save();
    g.globalCompositeOperation = 'screen';
    g.globalAlpha = 0.10;
    g.shadowColor = 'rgba(210,230,255,0.45)';
    g.shadowBlur = fontSize * 0.95;
    g.fillStyle = 'rgba(210,230,255,0.10)';
    g.textAlign = 'center';
    g.textBaseline = 'middle';
    g.font = `700 ${Math.round(fontSize)}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    g.fillText(CONFIG.starText, W*0.5, H*0.28);
    g.restore();

    g.save();
    g.globalAlpha = 0.045;
    g.fillStyle = 'rgba(255,255,255,0.06)';
    const n = clamp(Math.floor((W*H)/14000), 220, 520);
    const prG = makePRNG((W*1597334677) ^ (H*3812015801));
    for(let i=0;i<n;i++){
      const x = prG()*W;
      const y = prG()*(H*0.72);
      g.fillRect(x,y,1,1);
    }
    g.restore();

    const vg = g.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.18, W*0.5, H*0.55, Math.max(W,H)*0.98);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.62)');
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);

    skyCache = off;
  }

  function drawSky(t){
    ctx.clearRect(0,0,W,H);

    if(skyCache){
      ctx.drawImage(skyCache, 0, 0, skyCache.width / DPR, skyCache.height / DPR);
    }else{
      const sky = ctx.createLinearGradient(0, 0, 0, H);
      sky.addColorStop(0, 'rgba(12,14,46,1)');
      sky.addColorStop(0.40, 'rgba(7,9,24,1)');
      sky.addColorStop(1, 'rgba(3,3,10,1)');
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);
    }

    drawStarText(t);

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    drawConstellations(t);

    for(const st of stars){
      const tw = CONFIG.reduceMotion ? 1 : (0.72 + 0.28*Math.sin(t*0.0011*st.s + st.p)) * (0.85 + st.tw*0.30);
      const alpha = st.a * (0.72 + 0.58*tw) * CONFIG.twinkle;

      starPos(st, t, _spA);
      const x = _spA.x;
      const y = _spA.y;

      ctx.globalAlpha = alpha;

      if(st.r < 1.15){
        ctx.shadowBlur = 0;
      }else{
        ctx.shadowColor = 'rgba(255,255,255,0.55)';
        ctx.shadowBlur = 8 + st.r*3.2;
      }

      ctx.fillStyle = st.hue ? `hsla(${st.hue}, 80%, 90%, 1)` : 'rgba(255,255,255,1)';
      ctx.beginPath();
      ctx.arc(x, y, st.r, 0, TAU);
      ctx.fill();

      if(st.flare){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowBlur = 0;

        ctx.globalAlpha = alpha * 0.42 * st.flare;
        const rg = ctx.createRadialGradient(x,y, 0, x,y, 18 + st.r*11);
        rg.addColorStop(0, 'rgba(255,255,255,0.20)');
        rg.addColorStop(0.45, 'rgba(255,255,255,0.07)');
        rg.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(x,y, 18 + st.r*11, 0, TAU);
        ctx.fill();

        ctx.globalAlpha = alpha * 0.28 * st.flare;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        const k = 3.6 + st.r*1.6;
        ctx.beginPath();
        ctx.moveTo(x-k, y); ctx.lineTo(x+k, y);
        ctx.moveTo(x, y-k); ctx.lineTo(x, y+k);
        ctx.stroke();
        ctx.restore();
      }
    }
    ctx.restore();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';

    maybeStartShootingStar(t);
    drawShootingStar(t);
  }

  // ===== Hojas =====
  function drawTulipLeaf(attachX, attachY, angle, scale, side){
    const id = ((attachX * 97) ^ (attachY * 193) ^ (side * 911)) | 0;
    const j = (Math.sin(id) * 0.5 + 0.5);

    const len = (95 + j*10) * scale;
    const baseWid = (7.5 + j*1.2) * scale;

    const baseDir = Math.PI/2 + angle;
    const leafAngle = baseDir + side * (0.16 + j*0.03);

    const p0x = attachX, p0y = attachY;
    const p3x = attachX + Math.cos(leafAngle) * len;
    const p3y = attachY - Math.sin(leafAngle) * len;

    const p1x = attachX + side * baseWid * (0.34 + j*0.08);
    const p1y = attachY - len * (0.35 + j*0.05);

    const p2x = attachX + side * baseWid * (0.14 + j*0.06);
    const p2y = attachY - len * (0.82 + j*0.06);

    const bez = (t, a,b,c,d) => {
      const u = 1 - t;
      return u*u*u*a + 3*u*u*t*b + 3*u*t*t*c + t*t*t*d;
    };

    const G0 = {r:28,g:88,b:56};
    const G1 = {r:52,g:140,b:88};
    const G2 = {r:96,g:190,b:130};

    const grad = ctx.createLinearGradient(p0x, p0y, p3x, p3y);
    grad.addColorStop(0, rgba(G0.r,G0.g,G0.b, 0.92));
    grad.addColorStop(0.55, rgba(G1.r,G1.g,G1.b, 0.84));
    grad.addColorStop(1, rgba(G2.r,G2.g,G2.b, 0.70));

    const steps = 14;
    const L = [], R = [], C = [];

    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const x = bez(t, p0x,p1x,p2x,p3x);
      const y = bez(t, p0y,p1y,p2y,p3y);
      C.push({x,y});

      const t2 = Math.min(1, t + 0.015);
      const x2 = bez(t2, p0x,p1x,p2x,p3x);
      const y2 = bez(t2, p0y,p1y,p2y,p3y);
      const dx = x2-x, dy=y2-y;
      const inv = 1 / Math.max(1e-5, Math.hypot(dx,dy));
      const nx = -dy*inv, ny = dx*inv;

      const taper = Math.pow(1 - t, 1.55);
      const w = baseWid * (0.04 + 0.50*taper);

      L.push({x: x + nx*w, y: y + ny*w});
      R.push({x: x - nx*w, y: y - ny*w});
    }

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.14)';
    ctx.shadowBlur = 4 * scale;

    ctx.fillStyle = grad;
    ctx.strokeStyle = 'rgba(255,255,255,0.012)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(L[0].x, L[0].y);
    for(const p of L) ctx.lineTo(p.x, p.y);
    for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i].x, R[i].y);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.stroke();

    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(0,0,0,0.14)';
    ctx.lineWidth = Math.max(1, 1.15*scale);
    ctx.beginPath();
    for(let i=0;i<C.length;i++){
      const p = C[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.10;
    const edge = side < 0 ? L : R;
    ctx.strokeStyle = 'rgba(180,255,210,0.14)';
    ctx.lineWidth = Math.max(1, 0.9*scale);
    ctx.beginPath();
    for(let i=0;i<edge.length;i++){
      const p = edge[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawLeafSprig(x, y, angle, scale, side){
    const baseDir = Math.PI/2 + angle;
    const a = baseDir + side*(0.30);

    const len = 72 * scale;
    const spread = 14 * scale;

    const tipX = x + Math.cos(a) * len;
    const tipY = y - Math.sin(a) * len;

    const cX = x + side * spread;
    const cY = y - len * 0.55;

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const lg = ctx.createLinearGradient(x, y, tipX, tipY);
    lg.addColorStop(0, 'rgba(8,20,12,0.10)');
    lg.addColorStop(0.55, 'rgba(70,200,130,0.08)');
    lg.addColorStop(1, 'rgba(90,240,160,0.12)');

    ctx.strokeStyle = lg;
    ctx.lineWidth = Math.max(1, 0.9 * scale);

    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(cX, cY, tipX, tipY);
    ctx.stroke();

    ctx.globalAlpha = 0.45;
    ctx.beginPath();
    ctx.moveTo(x + side*2.0*scale, y + 1.3*scale);
    ctx.quadraticCurveTo(cX - side*spread*0.55, cY + len*0.12, tipX - side*3.0*scale, tipY + 1.2*scale);
    ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(120,255,180,0.08)';
    ctx.lineWidth = Math.max(1, 0.8 * scale);
    ctx.beginPath();
    ctx.moveTo(x + side*0.8*scale, y);
    ctx.quadraticCurveTo((x+tipX)*0.5, (y+tipY)*0.5, tipX, tipY);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Pétalos =====
  function getBloomSprite(w, h, col, seed, open){
    const key = `${Math.round(w)}x${Math.round(h)}_${col.r},${col.g},${col.b}_${seed}_${Math.round((open||1)*100)}`;
    const cached = bloomCache.get(key);
    if(cached) return cached;

    const ss = 2;
    const cw = Math.ceil(w * 2.8);
    const ch = Math.ceil(h * 2.4 + w * 0.35);

    const ax = Math.ceil(cw * 0.50);
    const ay = Math.ceil(h  * 1.55);

    const off = document.createElement('canvas');
    off.width  = cw * ss;
    off.height = ch * ss;

    const c2 = off.getContext('2d', { alpha:true });
    c2.setTransform(ss,0,0,ss,0,0);
    c2.translate(ax, ay);

    renderTulipBloomSprite(c2, w, h, col, seed, open);

    const obj = { canvas: off, ox: ax, oy: ay, ss };
    bloomCache.set(key, obj);
    return obj;
  }

  function renderTulipBloomSprite(c2, w, h, col, seed, open){
    let s = (seed >>> 0) || 1;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, s / 4294967296);

    const mix = (a,b,t)=>({
      r: Math.round(lerp(a.r,b.r,t)),
      g: Math.round(lerp(a.g,b.g,t)),
      b: Math.round(lerp(a.b,b.b,t))
    });

    const dark  = mix(col, {r:18,g:6,b:28}, 0.46);
    const deep  = mix(col, {r: 6,g:2,b:10}, 0.72);
    const lite  = mix(col, {r:255,g:255,b:255}, 0.36);
    const warm  = mix(col, {r:255,g:240,b:220}, 0.22);

    const op = clamp(((open||1) - 0.88) / 0.22, 0, 1);
    const spread = lerp(0.10, 0.22, op);

    c2.save();
    c2.globalCompositeOperation = 'lighter';
    c2.globalAlpha = 0.16;
    const gg = c2.createRadialGradient(0, -h*0.55, 10, 0, -h*0.40, w*1.55);
    gg.addColorStop(0, rgba(col.r,col.g,col.b,0.32));
    gg.addColorStop(1, rgba(col.r,col.g,col.b,0));
    c2.fillStyle = gg;
    c2.beginPath();
    c2.ellipse(0, -h*0.40, w*1.20, h*1.10, 0, 0, TAU);
    c2.fill();
    c2.restore();
    const petalPath = (petW, petH, notch, wave, lip) => {
      const cs = clamp(CONFIG.crownStrength, 0, 1);

      // Corona ultra suave: elimina picos visibles sin perder silueta
      const topBaseY = -petH * (0.995 + lip*0.85);
      const leftTopX  = -petW * (0.10 + wave*0.02);
      const rightTopX =  petW * (0.10 + wave*0.02);
      const leftTopY  = -petH * (0.965 - notch);
      const rightTopY = leftTopY;

      // levantamiento mínimo al centro (muy sutil)
      const capLift = petH * (0.006 + 0.010*cs);

      c2.beginPath();
      c2.moveTo(-petW*0.44, 0);

      c2.bezierCurveTo(
        -petW*0.66, -petH*0.26,
        -petW*0.48, -petH*0.84,
        leftTopX,   leftTopY
      );

      // Cap superior continuo (sin "puntos")
      c2.bezierCurveTo(
        leftTopX*0.35,  topBaseY - capLift,
        rightTopX*0.35, topBaseY - capLift,
        rightTopX, rightTopY
      );

      c2.bezierCurveTo(
        petW*0.48, -petH*0.84,
        petW*0.66, -petH*0.26,
        petW*0.44, 0
      );

      c2.quadraticCurveTo(0, petH*0.14, -petW*0.44, 0);
      c2.closePath();
    };

    const fillPetal = (front, idx) => {
      const v1 = (rnd()-0.5);
      const v2 = (rnd()-0.5);

      const petW = w * (front ? 0.62 : 0.56) * (1 + v1*0.05);
      const petH = h * (front ? 1.18 : 1.10) * (0.94 + op*0.10) * (1 + v2*0.035);
      const notch = 0.008 + rnd()*0.012;
      const wave  = (rnd()-0.5) * 0.22;

      const vg = c2.createLinearGradient(0, -petH, 0, petH*0.24);
      vg.addColorStop(0, rgba(lite.r,lite.g,lite.b, front ? 0.44 : 0.30));
      vg.addColorStop(0.22, rgba(warm.r,warm.g,warm.b, front ? 0.22 : 0.16));
      vg.addColorStop(0.38, rgba(col.r,col.g,col.b, front ? 0.98 : 0.88));
      vg.addColorStop(1, rgba(dark.r,dark.g,dark.b, 0.98));

      const hg = c2.createLinearGradient(-petW, -petH*0.35, petW, -petH*0.15);
      hg.addColorStop(0, rgba(0,0,0,0.18));
      hg.addColorStop(0.42, rgba(0,0,0,0));
      hg.addColorStop(1, rgba(0,0,0,0.22));

      const rim = c2.createRadialGradient(0, -petH*0.96, petW*0.02, 0, -petH*0.86, petW*0.95);
      rim.addColorStop(0, rgba(255,255,255, front ? 0.14 : 0.10));
      rim.addColorStop(0.55, rgba(255,255,255,0.04));
      rim.addColorStop(1, rgba(255,255,255,0));

      c2.save();
      c2.shadowColor = rgba(col.r,col.g,col.b, 0.10);
      c2.shadowBlur = Math.max(10, w*0.30);
      const lip = 0.016 + op*0.030;
      petalPath(petW, petH, notch, wave, lip);
      c2.fillStyle = vg;
      c2.fill();

      c2.shadowBlur = 0;
      c2.globalAlpha = front ? 0.06 : 0.045;
      c2.strokeStyle = rgba(255,255,255,0.22);
      c2.lineWidth = 1;
      c2.stroke();
      c2.globalAlpha = 1;

      c2.save();
      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = front ? 0.20 : 0.16;
      c2.fillStyle = hg;
      c2.fill();
      c2.restore();

      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = front ? 0.22 : 0.16;
      c2.fillStyle = rim;
      c2.fill();
      c2.restore();

      c2.save();
      c2.clip();


      // subsurface scattering (falso): glow cálido en el borde superior
      c2.save();
      c2.globalCompositeOperation = 'screen';
      c2.globalAlpha = front ? 0.20 : 0.14;
      const sss = c2.createRadialGradient(0, -petH*0.98, petW*0.06, 0, -petH*0.98, petW*0.92);
      sss.addColorStop(0, rgba(255,240,250,0.55));
      sss.addColorStop(0.35, rgba(col.r,col.g,col.b,0.20));
      sss.addColorStop(1, rgba(col.r,col.g,col.b,0));
      c2.fillStyle = sss;
      c2.beginPath();
      c2.ellipse(0, -petH*0.92, petW*0.74, petH*0.34, 0, 0, TAU);
      c2.fill();
      c2.restore();

      
      // grano muy sutil para que el pétalo no se vea plano
      c2.globalAlpha = front ? 0.030 : 0.024;
      c2.fillStyle = rgba(255,255,255,0.10);
      for(let k=0;k<(front?85:70);k++){
        const gx = (Math.random()*2 - 1) * petW * 0.55;
        const gy = -petH * (0.10 + Math.random()*0.85);
        const s = 0.6 + Math.random()*0.9;
        c2.fillRect(gx, gy, s, s);
      }

      c2.globalAlpha = front ? 0.10 : 0.075;
      c2.strokeStyle = rgba(255,255,255,0.14);
      c2.lineWidth = 1;
      const veins = 3 + (idx % 2);
      for(let i=-veins;i<=veins;i++){
        c2.beginPath();
        c2.moveTo(i*petW*0.10, -petH*0.96);
        c2.quadraticCurveTo(i*petW*0.08, -petH*0.55, i*petW*0.03, -petH*0.10);
        c2.stroke();
      }

      c2.globalAlpha = front ? 0.05 : 0.04;
      for(let k=0;k<12;k++){
        const px = (rnd()-0.5) * petW * 0.82;
        const py = -petH*(0.18 + rnd()*0.70);
        const pr = 0.6 + rnd()*1.0;
        c2.fillStyle = rgba(255,255,255, 0.10);
        c2.beginPath();
        c2.arc(px, py, pr, 0, TAU);
        c2.fill();
      }

      c2.globalCompositeOperation = 'multiply';
      c2.globalAlpha = front ? 0.16 : 0.12;
      const fg = c2.createRadialGradient(0, -petH*0.42, petW*0.08, 0, -petH*0.42, petW*0.70);
      fg.addColorStop(0, rgba(deep.r,deep.g,deep.b,0.30));
      fg.addColorStop(1, rgba(0,0,0,0));
      c2.fillStyle = fg;
      c2.beginPath();
      c2.ellipse(0, -petH*0.42, petW*0.50, petH*0.34, 0, 0, TAU);
      c2.fill();

      c2.restore();
      c2.restore();
    };

    for(let i=0;i<3;i++){
      c2.save();
      const a = (-spread + i*spread) + (rnd()-0.5)*0.018;
      c2.rotate(a);
      c2.translate(0, h*0.06);
      c2.scale(1, 1.02 - op*0.05);
      fillPetal(false, i);
      c2.restore();
    }

    c2.save();
    c2.globalCompositeOperation = 'multiply';
    const ig = c2.createRadialGradient(0, -h*0.30, w*0.06, 0, -h*0.22, w*1.05);
    ig.addColorStop(0, rgba(0,0,0,0));
    ig.addColorStop(1, rgba(0,0,0,0.36));
    c2.fillStyle = ig;
    c2.beginPath();
    c2.ellipse(0, -h*0.30, w*0.55, h*0.60, 0, 0, TAU);
    c2.fill();
    c2.restore();

    for(let i=0;i<3;i++){
      c2.save();
      const a = (-(spread+0.08) + i*(spread+0.08)) + (rnd()-0.5)*0.018;
      c2.rotate(a);
      c2.translate((i-1)*w*0.018*op, -h*0.01);
      c2.scale(1, 1.04);
      fillPetal(true, 3+i);
      c2.restore();
    }

    c2.save();
    c2.globalAlpha = 0.95;
    c2.fillStyle = rgba(50,170,105,0.92);
    c2.strokeStyle = rgba(255,255,255,0.06);
    c2.lineWidth = 1;
    for(let i=0;i<3;i++){
      const a = (-0.56 + i*0.56);
      c2.save();
      c2.rotate(a);
      c2.beginPath();
      c2.moveTo(-w*0.11, h*0.02);
      c2.quadraticCurveTo(0, -h*0.12, w*0.11, h*0.02);
      c2.quadraticCurveTo(0, h*0.16, -w*0.11, h*0.02);
      c2.closePath();
      c2.fill();
      c2.stroke();
      c2.restore();
    }
    c2.restore();

    c2.fillStyle = rgba(40,140,85,0.52);
    c2.beginPath();
    c2.ellipse(0, 0, w*0.18, h*0.10, 0, 0, TAU);
    c2.fill();

    c2.save();
    c2.globalAlpha = 0.28;
    c2.fillStyle = rgba(0,0,0,0.18);
    c2.beginPath();
    c2.ellipse(0, h*0.02, w*0.26, h*0.10, 0, 0, TAU);
    c2.fill();
    c2.restore();
  }

  function drawTulipBloom(w, h, col, seed, open){
    const spr = getBloomSprite(w, h, col, seed, open);
    ctx.drawImage(
      spr.canvas,
      -spr.ox,
      -spr.oy,
      spr.canvas.width / spr.ss,
      spr.canvas.height / spr.ss
    );
  }

  
  function drawBouquetWrap(cx, cy, s){
    // Un envoltorio simple (hojas + listón) para que sí se lea como "ramo"
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(s, s);

    const leaf = (rot, flip) => {
      ctx.save();
      ctx.rotate(rot);
      ctx.scale(flip, 1);

      const g = ctx.createLinearGradient(-40, 10, 40, -120);
      g.addColorStop(0, 'rgba(8,26,16,0.82)');
      g.addColorStop(0.55, 'rgba(38,130,78,0.66)');
      g.addColorStop(1, 'rgba(190,255,220,0.18)');

      ctx.fillStyle = g;
      ctx.shadowColor = 'rgba(0,0,0,0.28)';
      ctx.shadowBlur = 14;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-48, -30, -64, -92, -14, -138);
      ctx.bezierCurveTo(10, -156, 64, -116, 48, -56);
      ctx.bezierCurveTo(38, -18, 14, -6, 0, 0);
      ctx.closePath();
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-6, -6);
      ctx.quadraticCurveTo(10, -58, -2, -126);
      ctx.stroke();

      ctx.restore();
    };

    // hojas de envoltura
    leaf(-0.26, 1);
    leaf( 0.30, -1);
    leaf( 0.02, 1);

    // Listón oscuro con brillo
    ctx.save();
    ctx.translate(0, 10);

    const band = ctx.createLinearGradient(-80, 0, 80, 0);
    band.addColorStop(0, 'rgba(30,10,18,0.55)');
    band.addColorStop(0.5, 'rgba(80,22,38,0.48)');
    band.addColorStop(1, 'rgba(18,6,12,0.55)');

    ctx.fillStyle = band;
    ctx.shadowColor = 'rgba(0,0,0,0.40)';
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(-88, -10);
    ctx.quadraticCurveTo(0, 18, 88, -10);
    ctx.quadraticCurveTo(0, 34, -88, -10);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.16;
    ctx.strokeStyle = 'rgba(255,235,245,0.20)';
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.moveTo(-80, -8);
    ctx.quadraticCurveTo(0, 10, 80, -8);
    ctx.stroke();

    // nudo
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(50,14,24,0.62)';
    ctx.beginPath();
    ctx.ellipse(0, 2, 18, 12, 0, 0, TAU);
    ctx.fill();

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    ctx.ellipse(-5, -1, 8, 4, -0.2, 0, TAU);
    ctx.fill();

    ctx.restore();
    ctx.restore();
  }

// ===== Bouquet =====
  const DESCS = [
    // 10 tulipanes: más compacto y con capas para que se vea como un ramo
    {dx:-0.48, hf:0.70, bs:0.82},
    {dx: 0.48, hf:0.72, bs:0.84},

    {dx:-0.30, hf:0.84, bs:0.90},
    {dx: 0.30, hf:0.86, bs:0.92},

    {dx:-0.14, hf:0.98, bs:1.00},
    {dx: 0.14, hf:0.98, bs:1.00},

    {dx: 0.00, hf:1.06, bs:1.02}, // un poquito más alto al fondo

    // capa frontal
    {dx:-0.08, hf:0.80, bs:0.96},
    {dx: 0.08, hf:0.80, bs:0.96},
    {dx: 0.00, hf:0.86, bs:0.98},
  ];
  const COLORS = [
    { r: 155, g:  85, b: 245 }, // violet
    { r: 128, g:  62, b: 220 }, // deep violet
    { r: 198, g: 145, b: 255 }, // lavender
    { r: 172, g:  98, b: 242 }, // orchid purple
    { r: 112, g:  52, b: 190 }, // plum
  ];

  let bouquet = [];

  function seedBouquet(){
    const cx = W*0.5;
    const baseY = H*0.93;
    const scaleBase = lerp(0.74, 1.12, clamp(Math.min(W, H)/820, 0, 1));
    const spread = Math.min(W*0.44, 220 + W*0.05);

    bouquet = DESCS.map((p,i)=>{
      const scale = scaleBase * p.bs;
      const bw = (40 + ((i%3)-1)*2) * scale;
      const bh = (86 + ((i%4)-2)*4) * scale;
      const center = (DESCS.length - 1) / 2;
      const twist = (i - center) * 0.016;

      return {
        i,
        x: cx + p.dx*spread,
        baseY,
        scale,
        height: (235 * scaleBase) * p.hf,
        phase: i*0.85,
        bw, bh,
        twist,
        col: COLORS[i % COLORS.length],
        seed: 1337 + i*101,
        open: 0.92 + (i % 4) * 0.03
      };
    });
  }

  function drawBouquet(t){
    drawGrass(t);

    const hx = W*0.5, hy = H*0.78;
    const hg = ctx.createRadialGradient(hx, hy, 10, hx, hy, Math.max(W,H)*0.40);
    hg.addColorStop(0, 'rgba(0,0,0,0)');
    hg.addColorStop(1, 'rgba(0,0,0,0.30)');
    ctx.fillStyle = hg;
    ctx.fillRect(0,0,W,H);

    const bush = ctx.createRadialGradient(W*0.5, H*0.95, 10, W*0.5, H*0.95, Math.min(W,H)*0.45);
    bush.addColorStop(0, 'rgba(65,150,95,0.16)');
    bush.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = bush;
    ctx.fillRect(0,0,W,H);

    const STEM = {r:55,g:155,b:92};
    const STEM2= {r:35,g:120,b:72};

    const gw = windField(t) * CONFIG.sway;

    const order = bouquet.slice().sort((a,b)=> (b.height - a.height) || (a.x - b.x));

    for(const f of order){
      const sway = CONFIG.reduceMotion ? 0 : (gw*0.22 + Math.sin(t*0.001 + f.phase) * 0.08 * CONFIG.sway);
      const angle = sway + (f.x - W*0.5) * 0.0006;

      const baseX = f.x;
      const baseY = f.baseY;
      const topY  = baseY - f.height;

      const bloomX = baseX + Math.sin(angle) * 12 * f.scale;
      const bloomY = topY + Math.cos(angle) * 5 * f.scale;

      const cp1x = baseX + Math.sin(f.phase)*10*f.scale;
      const cp1y = baseY - f.height*0.40;
      const cp2x = baseX + Math.cos(f.phase*1.7)*16*f.scale;
      const cp2y = baseY - f.height*0.76;

      const leafMid1 = baseY - f.height*0.52;
      const leafMid2 = baseY - f.height*0.60;

      ctx.save();
      drawTulipLeaf(baseX, leafMid1, angle, f.scale*0.56, -1);
      drawTulipLeaf(baseX, leafMid2, angle, f.scale*0.50,  1);
      drawLeafSprig(baseX, baseY - f.height*0.56, angle, f.scale*0.52, -1);
      drawLeafSprig(baseX, baseY - f.height*0.64, angle, f.scale*0.46,  1);
      ctx.restore();

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const stemW = 7.0 * f.scale;

      const sg = ctx.createLinearGradient(baseX, baseY, bloomX, bloomY);
      sg.addColorStop(0.00, rgba(STEM2.r, STEM2.g, STEM2.b, 0.10));
      sg.addColorStop(0.10, rgba(STEM2.r, STEM2.g, STEM2.b, 0.45));
      sg.addColorStop(0.32, rgba(STEM.r,  STEM.g,  STEM.b,  0.95));
      sg.addColorStop(1.00, rgba(STEM.r,  STEM.g,  STEM.b,  0.95));

      ctx.strokeStyle = sg;
      ctx.lineWidth = stemW;

      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, bloomX, bloomY);
      ctx.stroke();


      // volumen del tallo: sombra (lado opuesto a la luna) + brillo (lado de la luna)
      const offX = LIGHT_DIR.x * stemW * 0.22;
      const offY = LIGHT_DIR.y * stemW * 0.22;

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = stemW * 0.55;
      ctx.beginPath();
      ctx.moveTo(baseX - offX, baseY - offY);
      ctx.bezierCurveTo(cp1x - offX, cp1y - offY, cp2x - offX, cp2y - offY, bloomX - offX, bloomY - offY);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.16;
      ctx.strokeStyle = 'rgba(210,255,230,0.55)';
      ctx.lineWidth = Math.max(1, stemW * 0.28);
      ctx.beginPath();
      ctx.moveTo(baseX + offX*0.75, baseY + offY*0.75);
      ctx.bezierCurveTo(cp1x + offX*0.75, cp1y + offY*0.75, cp2x + offX*0.75, cp2y + offY*0.75, bloomX + offX*0.75, bloomY + offY*0.75);
      ctx.stroke();
      ctx.restore();

      const fadeH = 92 * f.scale;
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      const fg = ctx.createLinearGradient(0, baseY + 2, 0, baseY - fadeH);
      fg.addColorStop(0.00, 'rgba(0,0,0,0.90)');
      fg.addColorStop(0.55, 'rgba(0,0,0,0.22)');
      fg.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      ctx.strokeStyle = fg;
      ctx.lineWidth = stemW + 5.0 * f.scale;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, bloomX, bloomY);
      ctx.stroke();
      ctx.restore();

      ctx.restore();

      // sombra de contacto bajo la flor (le da "peso" y profundidad)
      ctx.save();
      ctx.globalAlpha = 0.11;
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.beginPath();
      ctx.ellipse(bloomX, bloomY + 6*f.scale, 10*f.scale, 4.2*f.scale, angle, 0, TAU);
      ctx.fill();
      ctx.restore();


      f.bloomX = bloomX;
      f.bloomY = bloomY;
      f.angle = angle + f.twist;
    }

    
    // Envoltura + bruma para que el ramo no flote como sticker
    const wrapS = lerp(0.82, 1.10, clamp(Math.min(W,H)/820, 0, 1));
    drawBouquetWrap(W*0.5, H*0.935, wrapS);

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const fogTop = H*0.72;
    const fog = ctx.createLinearGradient(0, fogTop, 0, H);
    fog.addColorStop(0, 'rgba(120,150,220,0)');
    fog.addColorStop(0.55, 'rgba(120,150,220,0.06)');
    fog.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = fog;
    ctx.fillRect(0, fogTop, W, H - fogTop);
    ctx.restore();

    const bloomOrder = order.slice().sort((a,b)=>a.bloomY - b.bloomY);

for(const f of bloomOrder){
      ctx.save();
      ctx.translate(f.bloomX, f.bloomY);

      // Depth of field barato pero efectivo: las flores del fondo se suavizan un poco
      const ny = f.bloomY / H;
      const depth = clamp((ny - 0.34) / 0.34, 0, 1); // 0=lejos, 1=cerca
      const blur = (1 - depth) * (1 - depth) * 1.6;
      ctx.globalAlpha *= lerp(0.86, 1.0, depth);
      if(HAS_FILTER && blur > 0.02) ctx.filter = `blur(${blur.toFixed(2)}px)`;

      ctx.rotate(f.angle);
      ctx.shadowColor = `rgba(${f.col.r},${f.col.g},${f.col.b},0.16)`;
      ctx.shadowBlur = 10 + 12*f.scale;
      drawTulipBloom(f.bw, f.bh, f.col, f.seed, f.open);
      if(HAS_FILTER) ctx.filter = 'none';
      ctx.restore();
    }

    const knotX = W*0.5, knotY = H*0.935;
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath();
    ctx.ellipse(knotX, knotY, Math.min(110, W*0.20), 26, 0, 0, TAU);
    ctx.fill();
  }

  function addSparkle(x, y, t){
    tapSparkles.push({ x, y, t0: t, seed: Math.random()*9999 });
    if(tapSparkles.length > 28) tapSparkles.shift();
  }

  function drawTapSparkles(t){
    if(!tapSparkles.length) return;

    for(let i=tapSparkles.length-1;i>=0;i--){
      const s = tapSparkles[i];
      const age = (t - s.t0) / 1000;
      if(age > 0.95){ tapSparkles.splice(i,1); continue; }

      const k = 1 - age/0.95;
      const r = (14 + age*56);
      const pulse = 0.6 + 0.4*Math.sin((t*0.01) + s.seed);

      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.46 * k;

      const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, r);
      g.addColorStop(0, `rgba(255,255,255,${0.32*k})`);
      g.addColorStop(0.28, `rgba(200,220,255,${0.20*k})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;

      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, TAU);
      ctx.fill();

      ctx.globalAlpha = 0.18 * k * pulse;
      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.moveTo(s.x - r*0.55, s.y);
      ctx.lineTo(s.x + r*0.55, s.y);
      ctx.moveTo(s.x, s.y - r*0.55);
      ctx.lineTo(s.x, s.y + r*0.55);
      ctx.stroke();

      ctx.restore();
    }
  }


  function resize(){
    DPR = Math.min(1.8, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    bloomCache.clear();

    seedStars();
    buildStarText();
    rebuildSkyCache();

    seedBouquet();
    seedSoil();
    seedGrass();
    rebuildGroundCache();

    for(const f of bouquet){
      getBloomSprite(f.bw, f.bh, f.col, f.seed, f.open);
    }

    selfTest();
  }
  window.addEventListener('resize', resize, {passive:true});

  canvas.addEventListener('pointerdown', (e) => {
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left);
    const y = (e.clientY - r.top);
    addSparkle(x, y, performance.now());

    // si le picas cerca del cielo, regalamos una estrella fugaz
    if(y < H*0.55 && !shooting.active) maybeStartShootingStar(performance.now());
  }, {passive:true});



  function selfTest(){
    console.assert(!!canvas && !!ctx, 'Canvas/ctx no disponibles');
    console.assert(Number.isFinite(W) && W>0 && Number.isFinite(H) && H>0, 'Canvas size inválido');
    console.assert(Array.isArray(stars) && stars.length>0, 'Stars no inicializadas');
    console.assert(Array.isArray(starLinks), 'starLinks no existe');
    console.assert(stars.length < 40 || starLinks.length > 0, 'Constelaciones no generadas');
    console.assert(Array.isArray(tapSparkles), 'tapSparkles no existe');
    console.assert(Array.isArray(textStars) && textStars.length>200, 'Texto en estrellas no generado');
    console.assert(Array.isArray(grass) && grass.length>0, 'Grass no inicializado');
    console.assert(grassAnim1.length>0 && grassAnim2.length>0, 'Grass anim no inicializado');
    console.assert(Array.isArray(soil) && soil.length>0, 'Soil no inicializado');
    console.assert(!!groundCache && groundCache.width>0, 'Ground cache no generado');
    console.assert(!!skyCache && skyCache.width>0, 'Sky cache no generado');
    console.assert(Array.isArray(bouquet) && bouquet.length===DESCS.length, 'Bouquet no se generó correctamente');
    console.assert(CONFIG.crownStrength >= 0 && CONFIG.crownStrength <= 1, 'crownStrength fuera de rango');

    // Smoke test de dibujo: esto también calcula bloomX/bloomY
    try{ drawBouquet(0); }catch(e){ console.error('drawBouquet fallo', e); }
    console.assert(bouquet.every(f=>Number.isFinite(f.bloomX) && Number.isFinite(f.bloomY)), 'bloomX/bloomY no calculados');

    const spr = getBloomSprite(60, 100, {r:235,g:55,b:70}, 42, 0.95);
    console.assert(spr && spr.canvas && spr.ss === 2 && spr.canvas.width>0, 'Sprite inválido');
  }

  seedStars();
  resize();

  function frame(t){
    requestAnimationFrame(frame);
    drawSky(t);
    drawBouquet(t);
    drawTapSparkles(t);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
